//////////////////////////////////////////////////////////////////////
// This file was generated by piggi and should not be modified by hand
//////////////////////////////////////////////////////////////////////


#include <stdio.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <assert.h>

typedef int8_t  int8;
typedef int16_t int16;
typedef int32_t int32;
typedef int64_t int64;



























































struct String; typedef struct String String; struct String {
    const char* cstr;
    int32 length;
};

static String StringCreateEmpty() {
    String result;
    result.cstr = NULL;
    result.length = 0;
    return result;
}

static String StringCreateFromCStr(const char* str) {
    int32 length = 0;
    if (str != NULL) {
        const char* pos = str;
        while (*pos != '\0') {
            length += 1;
            pos += 1;
        }
    }
    String result;
    result.cstr = str;
    result.length = length;
    return result;
}

static bool StringEquals(String a, String b) {
    if (a.length != b.length) {
        return false;
    }
    for (int32 index = 0; index < a.length; index += 1) {
        if (a.cstr[index] != b.cstr[index]) {
            return false;
        }
    }
    return true;
}

struct LineAndColumnNumber; typedef struct LineAndColumnNumber LineAndColumnNumber; struct LineAndColumnNumber {
    int32 lineNumber;
    int32 columnNumber;
};

static LineAndColumnNumber StringGetLineAndColumnNumberAtPos(String str, int32 pos) {
    int32 curPos = 0;
    int32 curLine = 1;
    int32 curColumn = 1;
    while (curPos < pos && curPos < str.length) {
        if (str.cstr[curPos] == '\n') {
            curColumn = 1;
            curLine += 1;
        }
        curPos += 1;
    }
    LineAndColumnNumber result;
    result.lineNumber = curLine;
    result.columnNumber = curColumn;
    return result;
}

static String StringGetSubstring(String str, int32 start, int32 end) {
    assert(start <= end);
    int32 length = end - start;
    if (length == 0) {
        return StringCreateEmpty();
    }
    char* buffer = (char*)malloc(length + 1);
    for (int32 index = 0; index < length; index += 1) {
        buffer[index] = str.cstr[start + index];
    }
    buffer[length] = '\0';
    String result;
    result.cstr = buffer;
    result.length = length;
    return result;
}

static String StringAppend(String base, String suffix) {
    int32 length = base.length + suffix.length;
    char* buffer = (char*)malloc(length + 1);
    int32 pos = 0;
    for (int32 sourceIndex = 0; sourceIndex < base.length; sourceIndex += 1) {
        buffer[pos] = base.cstr[sourceIndex];
        pos += 1;
    }
    for (int32 sourceIndex = 0; sourceIndex < suffix.length; sourceIndex += 1) {
        buffer[pos] = suffix.cstr[sourceIndex];
        pos += 1;
    }
    buffer[pos] = '\0';
    String result;
    result.length = length;
    result.cstr = buffer;
    return result;
}

static int32 FindCharPosInString(String str, char ch) {
    for (int32 pos = 0; pos < str.length; pos += 1) {
        if (str.cstr[pos] == ch) {
            return pos;
        }
    }
    return -1;
}

struct SourceFile; typedef struct SourceFile SourceFile; struct SourceFile {
    String filepath;
    String content;
};

struct SourceFileArray; typedef struct SourceFileArray SourceFileArray; struct SourceFileArray {
    SourceFile* files;
    int32 count;
    int32 capacity;
};

static SourceFileArray SourceFileArrayCreate() {
    SourceFileArray result;
    result.files = NULL;
    result.count = 0;
    result.capacity = 0;
    return result;
}

static void SourceFileArrayGrow(SourceFileArray* array, int32 newCapacity) {
    array->capacity = newCapacity;
    array->files = (SourceFile*)realloc(array->files, newCapacity * sizeof(SourceFile));
    assert(array->files != NULL);
}

static int32 SourceFileArrayPush(SourceFileArray* array, SourceFile file) {
    if (array->count == array->capacity) {
        int32 newCapacity = 2 * array->capacity;
        if (newCapacity == 0) {
            newCapacity = 64;
        }
        SourceFileArrayGrow(array, newCapacity);
    }
    int32 insertionIndex = array->count;
    array->files[insertionIndex] = file;
    array->count += 1;
    return insertionIndex;
}

struct Source; typedef struct Source Source; struct Source {
    SourceFileArray files;
    String content;
};

static Source SourceCreateEmpty() {
    Source result;
    result.files = SourceFileArrayCreate();
    result.content = StringCreateEmpty();
    return result;
}

static bool SourceContainsFile(Source source, String filepath) {
    for (int32 index = 0; index < source.files.count; index += 1) {
        if (StringEquals(source.files.files[index].filepath, filepath)) {
            return true;
        }
    }
    return false;
}

static String SourceGetSubstring(Source source, int32 start, int32 end) {
    return StringGetSubstring(source.content, start, end);
}

static char SourceGetCharAtIndex(Source source, int32 charPos) {
    return source.content.cstr[charPos];
}

struct SourceLocation; typedef struct SourceLocation SourceLocation; struct SourceLocation {
    Source source;
    int32 charPos;
    char ch;
    String filepath;
    LineAndColumnNumber fileLineColumn;
};

static SourceLocation SourceGetLocationForCharPos(Source source, int32 charPos) {
    SourceLocation result;
    result.source = source;
    result.charPos = charPos;
    result.ch = SourceGetCharAtIndex(source, charPos);
    result.filepath = StringCreateEmpty();
    result.fileLineColumn.lineNumber = -1;
    result.fileLineColumn.columnNumber = -1;
    int32 remainder = charPos;
    for (int32 fileIndex = 0; fileIndex < source.files.count; fileIndex += 1) {
        String filepath = source.files.files[fileIndex].filepath;
        String fileContent = source.files.files[fileIndex].content;
        int32 fileLength = fileContent.length;
        if (remainder < fileLength) {
            result.filepath = filepath;
            result.fileLineColumn = StringGetLineAndColumnNumberAtPos(fileContent, remainder);
            result.ch = fileContent.cstr[remainder];
            break;
        }
        remainder -= fileLength;
    }
    return result;
}

struct SourceLocation2; typedef struct SourceLocation2 SourceLocation2; struct SourceLocation2 {
    Source source;
    int32 start;
    int32 end;
};

static SourceLocation2 SourceLocation2Create(Source source, int32 start, int32 end) {
    SourceLocation2 result;
    result.source = source;
    result.start = start;
    result.end = end;
    return result;
}

static void ReportLocation(SourceLocation location) {
    fprintf(stderr, "%s(%d)", location.filepath.cstr, location.fileLineColumn.lineNumber);
}

static void ReportError(SourceLocation location, char* format, ...) {
    ReportLocation(location);
    fprintf(stderr, ": Error - ", location.filepath.cstr, location.fileLineColumn.lineNumber);
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "\n");
    exit(1);
}

enum SyntaxKind; typedef enum SyntaxKind SyntaxKind; enum SyntaxKind {
    SyntaxKind_BadToken = 0,
    SyntaxKind_SkippedTextTrivia = 1,
    SyntaxKind_LineBreakTrivia = 2,
    SyntaxKind_WhitespaceTrivia = 3,
    SyntaxKind_SingleLineCommentTrivia = 4,
    SyntaxKind_MultiLineCommentTrivia = 5,
    SyntaxKind_EndOfFileToken = 6,
    SyntaxKind_BangToken = 7,
    SyntaxKind_TildeToken = 8,
    SyntaxKind_PlusToken = 9,
    SyntaxKind_MinusToken = 10,
    SyntaxKind_StarToken = 11,
    SyntaxKind_SlashToken = 12,
    SyntaxKind_PercentToken = 13,
    SyntaxKind_EqualsToken = 14,
    SyntaxKind_PlusEqualsToken = 15,
    SyntaxKind_MinusEqualsToken = 16,
    SyntaxKind_StarEqualsToken = 17,
    SyntaxKind_SlashEqualsToken = 18,
    SyntaxKind_PercentEqualsToken = 19,
    SyntaxKind_LessLessEqualsToken = 20,
    SyntaxKind_GreaterGreaterEqualsToken = 21,
    SyntaxKind_HatEqualsToken = 22,
    SyntaxKind_PipeEqualsToken = 23,
    SyntaxKind_AmpersandEqualsToken = 24,
    SyntaxKind_PipePipeToken = 25,
    SyntaxKind_AmpersandAmpersandToken = 26,
    SyntaxKind_EqualsEqualsToken = 27,
    SyntaxKind_BangEqualsToken = 28,
    SyntaxKind_LessToken = 29,
    SyntaxKind_LessEqualsToken = 30,
    SyntaxKind_GreaterToken = 31,
    SyntaxKind_GreaterEqualsToken = 32,
    SyntaxKind_LessLessToken = 33,
    SyntaxKind_GreaterGreaterToken = 34,
    SyntaxKind_HatToken = 35,
    SyntaxKind_PipeToken = 36,
    SyntaxKind_AmpersandToken = 37,
    SyntaxKind_QuestionmarkToken = 38,
    SyntaxKind_ColonToken = 39,
    SyntaxKind_ColonColonToken = 40,
    SyntaxKind_ArrowToken = 41,
    SyntaxKind_DotToken = 42,
    SyntaxKind_DotDotDotToken = 43,
    SyntaxKind_CommaToken = 44,
    SyntaxKind_SemicolonToken = 45,
    SyntaxKind_LeftBraceToken = 46,
    SyntaxKind_RightBraceToken = 47,
    SyntaxKind_LeftParenToken = 48,
    SyntaxKind_RightParenToken = 49,
    SyntaxKind_LeftBracketToken = 50,
    SyntaxKind_RightBracketToken = 51,
    SyntaxKind_IntegerLiteralToken = 52,
    SyntaxKind_CharacterLiteralToken = 53,
    SyntaxKind_StringLiteralToken = 54,
    SyntaxKind_IdentifierToken = 55,
    SyntaxKind_VoidKeyword = 56,
    SyntaxKind_CharKeyword = 57,
    SyntaxKind_ByteKeyword = 58,
    SyntaxKind_ShortKeyword = 59,
    SyntaxKind_IntKeyword = 60,
    SyntaxKind_LongKeyword = 61,
    SyntaxKind_NullKeyword = 62,
    SyntaxKind_CStringKeyword = 63,
    SyntaxKind_BoolKeyword = 64,
    SyntaxKind_TrueKeyword = 65,
    SyntaxKind_FalseKeyword = 66,
    SyntaxKind_LetKeyword = 67,
    SyntaxKind_LetLocalPersistKeyword = 68,
    SyntaxKind_FunKeyword = 69,
    SyntaxKind_StructKeyword = 70,
    SyntaxKind_UnionKeyword = 71,
    SyntaxKind_EnumKeyword = 72,
    SyntaxKind_ClassKeyword = 73,
    SyntaxKind_ImportKeyword = 74,
    SyntaxKind_IfKeyword = 75,
    SyntaxKind_ElseKeyword = 76,
    SyntaxKind_DoKeyword = 77,
    SyntaxKind_WhileKeyword = 78,
    SyntaxKind_ForKeyword = 79,
    SyntaxKind_ReturnKeyword = 80,
    SyntaxKind_BreakKeyword = 81,
    SyntaxKind_ContinueKeyword = 82,
    SyntaxKind_SwitchKeyword = 83,
    SyntaxKind_CaseKeyword = 84,
    SyntaxKind_DefaultKeyword = 85,
    SyntaxKind_AsKeyword = 86,
    SyntaxKind_SizeOfKeyword = 87,
    SyntaxKind_ExternKeyword = 88,
    SyntaxKind_IncludeDirectiveKeyword = 89,
    SyntaxKind_DefineDirectiveKeyword = 90,
    SyntaxKind_IfDirectiveKeyword = 91,
    SyntaxKind_EndIfDefinedDirectiveKeyword = 92,
    SyntaxKind_PragmaDirectiveKeyword = 93,
    SyntaxKind_TypedefKeyword = 94,
    SyntaxKind_UnaryExpression = 95,
    SyntaxKind_BinaryExpression = 96,
    SyntaxKind_FuncCallExpression = 97,
    SyntaxKind_ArrayIndexExpression = 98,
    SyntaxKind_MemberAccessExpression = 99,
    SyntaxKind_TypeCastExpression = 100,
    SyntaxKind_ParenthesizedExpression = 101,
    SyntaxKind_TernaryConditionalExpression = 102,
    SyntaxKind_SizeOfExpression = 103,
    SyntaxKind_NameExpression = 104,
    SyntaxKind_TypeExpression = 105,
    SyntaxKind_NullLiteralExpression = 106,
    SyntaxKind_IntegerLiteralExpression = 107,
    SyntaxKind_CharacterLiteralExpression = 108,
    SyntaxKind_BoolLiteralExpression = 109,
    SyntaxKind_StringLiteralExpression = 110,
    SyntaxKind_EnumValueLiteralExpression = 111,
    SyntaxKind_ArrayLiteralExpression = 112,
    SyntaxKind_EnumMemberClauseSyntax = 113,
    SyntaxKind_BlockStatement = 114,
    SyntaxKind_ExpressionStatement = 115,
    SyntaxKind_IfStatement = 116,
    SyntaxKind_DoWhileStatement = 117,
    SyntaxKind_WhileStatement = 118,
    SyntaxKind_ForStatement = 119,
    SyntaxKind_ReturnStatement = 120,
    SyntaxKind_BreakStatement = 121,
    SyntaxKind_ContinueStatement = 122,
    SyntaxKind_SwitchStatement = 123,
    SyntaxKind_CaseStatement = 124,
    SyntaxKind_DefaultStatement = 125,
    SyntaxKind_VariableDeclarationStatement = 126,
    SyntaxKind_Module = 127,
    SyntaxKind_ImportDeclarationStatement = 128,
    SyntaxKind_GlobalVariableDeclarationStatement = 129,
    SyntaxKind_EnumDeclarationStatement = 130,
    SyntaxKind_EnumDefinitionStatement = 131,
    SyntaxKind_StructOrUnionDeclarationStatement = 132,
    SyntaxKind_StructOrUniontDefinitionStatement = 133,
    SyntaxKind_FunctionDeclarationStatement = 134,
    SyntaxKind_FunctionDefinitionStatement = 135,
};

union SyntaxNode; typedef union SyntaxNode SyntaxNode;

struct ModuleStatementSyntax; typedef struct ModuleStatementSyntax ModuleStatementSyntax;

struct SyntaxTree; typedef struct SyntaxTree SyntaxTree; struct SyntaxTree {
    Source source;
    ModuleStatementSyntax* moduleRoot;
};

struct SyntaxInfo; typedef struct SyntaxInfo SyntaxInfo; struct SyntaxInfo {
    SyntaxKind kind;
    SyntaxTree* tree;
};

struct SyntaxNodeArray; typedef struct SyntaxNodeArray SyntaxNodeArray; struct SyntaxNodeArray {
    SyntaxNode** nodes;
    int32 count;
    int32 capacity;
};

static SyntaxNodeArray SyntaxNodeArrayCreate() {
    SyntaxNodeArray result;
    result.nodes = NULL;
    result.count = 0;
    result.capacity = 0;
    return result;
}

static int32 SyntaxNodeArrayPush(SyntaxNodeArray* array, SyntaxNode* node) {
    if (array->count == array->capacity) {
        int32 newCapacity = 2 * array->capacity;
        if (newCapacity == 0) {
            newCapacity = 64;
        }
        array->capacity = newCapacity;
        array->nodes = (SyntaxNode**)realloc(array->nodes, newCapacity * sizeof(SyntaxNode*));
        assert(array->nodes != NULL);
    }
    int32 insertionIndex = array->count;
    array->nodes[insertionIndex] = node;
    array->count += 1;
    return insertionIndex;
}

struct SyntaxTrivia; typedef struct SyntaxTrivia SyntaxTrivia; struct SyntaxTrivia {
    SyntaxKind kind;
    SourceLocation2 location;
};

static SyntaxTrivia SyntaxTriviaCreate(SyntaxKind kind, SourceLocation2 location) {
    SyntaxTrivia result;
    result.kind = kind;
    result.location = location;
    return result;
}

struct SyntaxTriviaArray; typedef struct SyntaxTriviaArray SyntaxTriviaArray; struct SyntaxTriviaArray {
    SyntaxTrivia* nodes;
    int32 count;
    int32 capacity;
};

static SyntaxTriviaArray SyntaxTriviaArrayCreate() {
    SyntaxTriviaArray result;
    result.nodes = NULL;
    result.count = 0;
    result.capacity = 0;
    return result;
}

static int32 SyntaxTriviaArrayPush(SyntaxTriviaArray* array, SyntaxTrivia node) {
    if (array->count == array->capacity) {
        int32 newCapacity = 2 * array->capacity;
        if (newCapacity == 0) {
            newCapacity = 64;
        }
        array->capacity = newCapacity;
        array->nodes = (SyntaxTrivia*)realloc(array->nodes, newCapacity * sizeof(SyntaxTrivia));
        assert(array->nodes != NULL);
    }
    int32 insertionIndex = array->count;
    array->nodes[insertionIndex] = node;
    array->count += 1;
    return insertionIndex;
}

struct SyntaxToken; typedef struct SyntaxToken SyntaxToken; struct SyntaxToken {
    SyntaxKind kind;
    SyntaxTree* tree;
    SourceLocation2 location;
    SyntaxTriviaArray leadingTrivia;
    SyntaxTriviaArray trailingTrivia;
    int64 intvalue;
    bool intvalueIsHex;
    String stringValueWithoutQuotes;
    String debugString;
};

static SyntaxToken SyntaxTokenCreateEmpty(SyntaxTree* tree) {
    SyntaxToken result;
    result.kind = SyntaxKind_BadToken;
    result.tree = tree;
    result.location.source = tree->source;
    result.location.start = 0;
    result.location.end = 0;
    result.leadingTrivia = SyntaxTriviaArrayCreate();
    result.trailingTrivia = SyntaxTriviaArrayCreate();
    result.intvalue = 0;
    result.intvalueIsHex = false;
    result.stringValueWithoutQuotes = StringCreateEmpty();
    result.debugString = StringCreateEmpty();
    return result;
}

static String TokenKindToString(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind_EndOfFileToken: {
            return StringCreateFromCStr("eof");
        }
        case SyntaxKind_PlusToken: {
            return StringCreateFromCStr("+");
        }
        case SyntaxKind_PlusEqualsToken: {
            return StringCreateFromCStr("+=");
        }
        case SyntaxKind_MinusToken: {
            return StringCreateFromCStr("-");
        }
        case SyntaxKind_MinusEqualsToken: {
            return StringCreateFromCStr("-=");
        }
        case SyntaxKind_StarToken: {
            return StringCreateFromCStr("*");
        }
        case SyntaxKind_StarEqualsToken: {
            return StringCreateFromCStr("*=");
        }
        case SyntaxKind_SlashToken: {
            return StringCreateFromCStr("/");
        }
        case SyntaxKind_SlashEqualsToken: {
            return StringCreateFromCStr("/=");
        }
        case SyntaxKind_PercentToken: {
            return StringCreateFromCStr("%");
        }
        case SyntaxKind_PercentEqualsToken: {
            return StringCreateFromCStr("%=");
        }
        case SyntaxKind_EqualsToken: {
            return StringCreateFromCStr("=");
        }
        case SyntaxKind_EqualsEqualsToken: {
            return StringCreateFromCStr("==");
        }
        case SyntaxKind_BangToken: {
            return StringCreateFromCStr("!");
        }
        case SyntaxKind_BangEqualsToken: {
            return StringCreateFromCStr("!=");
        }
        case SyntaxKind_LessToken: {
            return StringCreateFromCStr("<");
        }
        case SyntaxKind_LessEqualsToken: {
            return StringCreateFromCStr("<=");
        }
        case SyntaxKind_GreaterToken: {
            return StringCreateFromCStr(">");
        }
        case SyntaxKind_GreaterEqualsToken: {
            return StringCreateFromCStr(">=");
        }
        case SyntaxKind_LessLessToken: {
            return StringCreateFromCStr("<<");
        }
        case SyntaxKind_LessLessEqualsToken: {
            return StringCreateFromCStr("<<=");
        }
        case SyntaxKind_GreaterGreaterToken: {
            return StringCreateFromCStr(">>");
        }
        case SyntaxKind_GreaterGreaterEqualsToken: {
            return StringCreateFromCStr(">>=");
        }
        case SyntaxKind_TildeToken: {
            return StringCreateFromCStr("~");
        }
        case SyntaxKind_HatToken: {
            return StringCreateFromCStr("^");
        }
        case SyntaxKind_HatEqualsToken: {
            return StringCreateFromCStr("^=");
        }
        case SyntaxKind_PipeToken: {
            return StringCreateFromCStr("|");
        }
        case SyntaxKind_PipeEqualsToken: {
            return StringCreateFromCStr("|=");
        }
        case SyntaxKind_PipePipeToken: {
            return StringCreateFromCStr("||");
        }
        case SyntaxKind_AmpersandToken: {
            return StringCreateFromCStr("&");
        }
        case SyntaxKind_AmpersandEqualsToken: {
            return StringCreateFromCStr("&=");
        }
        case SyntaxKind_AmpersandAmpersandToken: {
            return StringCreateFromCStr("&&");
        }
        case SyntaxKind_QuestionmarkToken: {
            return StringCreateFromCStr("?");
        }
        case SyntaxKind_ColonToken: {
            return StringCreateFromCStr(":");
        }
        case SyntaxKind_ColonColonToken: {
            return StringCreateFromCStr("::");
        }
        case SyntaxKind_ArrowToken: {
            return StringCreateFromCStr("->");
        }
        case SyntaxKind_DotToken: {
            return StringCreateFromCStr(".");
        }
        case SyntaxKind_DotDotDotToken: {
            return StringCreateFromCStr("...");
        }
        case SyntaxKind_CommaToken: {
            return StringCreateFromCStr(",");
        }
        case SyntaxKind_SemicolonToken: {
            return StringCreateFromCStr(";");
        }
        case SyntaxKind_LeftBraceToken: {
            return StringCreateFromCStr("{");
        }
        case SyntaxKind_RightBraceToken: {
            return StringCreateFromCStr("}");
        }
        case SyntaxKind_LeftParenToken: {
            return StringCreateFromCStr("(");
        }
        case SyntaxKind_RightParenToken: {
            return StringCreateFromCStr(")");
        }
        case SyntaxKind_LeftBracketToken: {
            return StringCreateFromCStr("[");
        }
        case SyntaxKind_RightBracketToken: {
            return StringCreateFromCStr("]");
        }
        case SyntaxKind_IntegerLiteralToken: {
            return StringCreateFromCStr("int-lit");
        }
        case SyntaxKind_CharacterLiteralToken: {
            return StringCreateFromCStr("chr-lit");
        }
        case SyntaxKind_StringLiteralToken: {
            return StringCreateFromCStr("str-lit");
        }
        case SyntaxKind_CharKeyword: {
            return StringCreateFromCStr("char");
        }
        case SyntaxKind_ByteKeyword: {
            return StringCreateFromCStr("byte");
        }
        case SyntaxKind_ShortKeyword: {
            return StringCreateFromCStr("short");
        }
        case SyntaxKind_IntKeyword: {
            return StringCreateFromCStr("int");
        }
        case SyntaxKind_LongKeyword: {
            return StringCreateFromCStr("longint");
        }
        case SyntaxKind_VoidKeyword: {
            return StringCreateFromCStr("void");
        }
        case SyntaxKind_NullKeyword: {
            return StringCreateFromCStr("nullptr");
        }
        case SyntaxKind_CStringKeyword: {
            return StringCreateFromCStr("cstring");
        }
        case SyntaxKind_BoolKeyword: {
            return StringCreateFromCStr("bool");
        }
        case SyntaxKind_TrueKeyword: {
            return StringCreateFromCStr("true");
        }
        case SyntaxKind_FalseKeyword: {
            return StringCreateFromCStr("false");
        }
        case SyntaxKind_IfKeyword: {
            return StringCreateFromCStr("if");
        }
        case SyntaxKind_ElseKeyword: {
            return StringCreateFromCStr("else");
        }
        case SyntaxKind_DoKeyword: {
            return StringCreateFromCStr("do");
        }
        case SyntaxKind_WhileKeyword: {
            return StringCreateFromCStr("while");
        }
        case SyntaxKind_ForKeyword: {
            return StringCreateFromCStr("for");
        }
        case SyntaxKind_ReturnKeyword: {
            return StringCreateFromCStr("return");
        }
        case SyntaxKind_BreakKeyword: {
            return StringCreateFromCStr("break");
        }
        case SyntaxKind_ContinueKeyword: {
            return StringCreateFromCStr("continue");
        }
        case SyntaxKind_SwitchKeyword: {
            return StringCreateFromCStr("switch");
        }
        case SyntaxKind_CaseKeyword: {
            return StringCreateFromCStr("case");
        }
        case SyntaxKind_DefaultKeyword: {
            return StringCreateFromCStr("default");
        }
        case SyntaxKind_AsKeyword: {
            return StringCreateFromCStr("as");
        }
        case SyntaxKind_SizeOfKeyword: {
            return StringCreateFromCStr("sizeof");
        }
        case SyntaxKind_LetKeyword: {
            return StringCreateFromCStr("let");
        }
        case SyntaxKind_LetLocalPersistKeyword: {
            return StringCreateFromCStr("letpersist");
        }
        case SyntaxKind_FunKeyword: {
            return StringCreateFromCStr("fun");
        }
        case SyntaxKind_StructKeyword: {
            return StringCreateFromCStr("struct");
        }
        case SyntaxKind_UnionKeyword: {
            return StringCreateFromCStr("union");
        }
        case SyntaxKind_EnumKeyword: {
            return StringCreateFromCStr("enum");
        }
        case SyntaxKind_ClassKeyword: {
            return StringCreateFromCStr("class");
        }
        case SyntaxKind_ImportKeyword: {
            return StringCreateFromCStr("import");
        }
        case SyntaxKind_ExternKeyword: {
            return StringCreateFromCStr("extern");
        }
        case SyntaxKind_IncludeDirectiveKeyword: {
            return StringCreateFromCStr("#include");
        }
        case SyntaxKind_DefineDirectiveKeyword: {
            return StringCreateFromCStr("#define");
        }
        case SyntaxKind_IfDirectiveKeyword: {
            return StringCreateFromCStr("#if");
        }
        case SyntaxKind_EndIfDefinedDirectiveKeyword: {
            return StringCreateFromCStr("#endif");
        }
        case SyntaxKind_PragmaDirectiveKeyword: {
            return StringCreateFromCStr("#pragma");
        }
        case SyntaxKind_TypedefKeyword: {
            return StringCreateFromCStr("typedef");
        }
        case SyntaxKind_IdentifierToken: {
            return StringCreateFromCStr("identifier");
        }
        default: {
            fprintf(stderr, "Unrecognized token in `TokenKindToString`: %d", kind);
            exit(1);
        }
    }
}

static SyntaxKind GetKeywordForIdentifier(String identifier) {
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_CharKeyword))) {
        return SyntaxKind_CharKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_ByteKeyword))) {
        return SyntaxKind_ByteKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_ShortKeyword))) {
        return SyntaxKind_ShortKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_IntKeyword))) {
        return SyntaxKind_IntKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_LongKeyword))) {
        return SyntaxKind_LongKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_VoidKeyword))) {
        return SyntaxKind_VoidKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_NullKeyword))) {
        return SyntaxKind_NullKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_CStringKeyword))) {
        return SyntaxKind_CStringKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_BoolKeyword))) {
        return SyntaxKind_BoolKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_TrueKeyword))) {
        return SyntaxKind_TrueKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_FalseKeyword))) {
        return SyntaxKind_FalseKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_IfKeyword))) {
        return SyntaxKind_IfKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_ElseKeyword))) {
        return SyntaxKind_ElseKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_DoKeyword))) {
        return SyntaxKind_DoKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_WhileKeyword))) {
        return SyntaxKind_WhileKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_ForKeyword))) {
        return SyntaxKind_ForKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_ReturnKeyword))) {
        return SyntaxKind_ReturnKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_BreakKeyword))) {
        return SyntaxKind_BreakKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_ContinueKeyword))) {
        return SyntaxKind_ContinueKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_SwitchKeyword))) {
        return SyntaxKind_SwitchKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_CaseKeyword))) {
        return SyntaxKind_CaseKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_DefaultKeyword))) {
        return SyntaxKind_DefaultKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_AsKeyword))) {
        return SyntaxKind_AsKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_SizeOfKeyword))) {
        return SyntaxKind_SizeOfKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_FunKeyword))) {
        return SyntaxKind_FunKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_LetKeyword))) {
        return SyntaxKind_LetKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_LetLocalPersistKeyword))) {
        return SyntaxKind_LetLocalPersistKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_StructKeyword))) {
        return SyntaxKind_StructKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_UnionKeyword))) {
        return SyntaxKind_UnionKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_EnumKeyword))) {
        return SyntaxKind_EnumKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_ClassKeyword))) {
        return SyntaxKind_ClassKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_ImportKeyword))) {
        return SyntaxKind_ImportKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_ExternKeyword))) {
        return SyntaxKind_ExternKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_IncludeDirectiveKeyword))) {
        return SyntaxKind_IncludeDirectiveKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_DefineDirectiveKeyword))) {
        return SyntaxKind_DefineDirectiveKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_IfDirectiveKeyword))) {
        return SyntaxKind_IfDirectiveKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_EndIfDefinedDirectiveKeyword))) {
        return SyntaxKind_EndIfDefinedDirectiveKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_PragmaDirectiveKeyword))) {
        return SyntaxKind_PragmaDirectiveKeyword;
    }
    if (StringEquals(identifier, TokenKindToString(SyntaxKind_TypedefKeyword))) {
        return SyntaxKind_TypedefKeyword;
    }
    return SyntaxKind_EndOfFileToken;
}

static String TokenGetText(SyntaxToken token) {
    return SourceGetSubstring(token.location.source, token.location.start, token.location.end);
}

static SourceLocation TokenGetLocation(SyntaxToken token) {
    return SourceGetLocationForCharPos(token.location.source, token.location.start);
}

struct StringLiteralExpressionSyntax; typedef struct StringLiteralExpressionSyntax StringLiteralExpressionSyntax; struct StringLiteralExpressionSyntax {
    SyntaxInfo info;
    SyntaxNodeArray stringLiteralTokens;
};

struct NullLiteralExpressionSyntax; typedef struct NullLiteralExpressionSyntax NullLiteralExpressionSyntax; struct NullLiteralExpressionSyntax {
    SyntaxInfo info;
    SyntaxToken nullLiteral;
};

struct IntegerLiteralExpressionSyntax; typedef struct IntegerLiteralExpressionSyntax IntegerLiteralExpressionSyntax; struct IntegerLiteralExpressionSyntax {
    SyntaxInfo info;
    SyntaxToken integerLiteral;
};

struct CharacterLiteralExpressionSyntax; typedef struct CharacterLiteralExpressionSyntax CharacterLiteralExpressionSyntax; struct CharacterLiteralExpressionSyntax {
    SyntaxInfo info;
    SyntaxToken characterLiteral;
};

struct BoolLiteralExpressionSyntax; typedef struct BoolLiteralExpressionSyntax BoolLiteralExpressionSyntax; struct BoolLiteralExpressionSyntax {
    SyntaxInfo info;
    SyntaxToken boolLiteral;
};

struct EnumLiteralExpressionSyntax; typedef struct EnumLiteralExpressionSyntax EnumLiteralExpressionSyntax; struct EnumLiteralExpressionSyntax {
    SyntaxInfo info;
    SyntaxToken enumIdentifier;
    SyntaxToken coloncolon;
    SyntaxToken valueIdentifier;
};

struct ArrayLiteralExpressionSyntax; typedef struct ArrayLiteralExpressionSyntax ArrayLiteralExpressionSyntax; struct ArrayLiteralExpressionSyntax {
    SyntaxInfo info;
    SyntaxToken leftBrace;
    SyntaxNodeArray elemsWithSeparators;
    SyntaxToken rightBrace;
};

struct NameExpressionSyntax; typedef struct NameExpressionSyntax NameExpressionSyntax; struct NameExpressionSyntax {
    SyntaxInfo info;
    SyntaxToken identifier;
};

struct UnaryExpressionSyntax; typedef struct UnaryExpressionSyntax UnaryExpressionSyntax; struct UnaryExpressionSyntax {
    SyntaxInfo info;
    SyntaxToken operatorToken;
    SyntaxNode* operand;
};

struct BinaryExpressionSyntax; typedef struct BinaryExpressionSyntax BinaryExpressionSyntax; struct BinaryExpressionSyntax {
    SyntaxInfo info;
    SyntaxNode* left;
    SyntaxToken operatorToken;
    SyntaxNode* right;
};

struct ParenthesizedExpressionSyntax; typedef struct ParenthesizedExpressionSyntax ParenthesizedExpressionSyntax; struct ParenthesizedExpressionSyntax {
    SyntaxInfo info;
    SyntaxToken leftParen;
    SyntaxNode* expression;
    SyntaxToken rightParen;
};

struct FuncCallExpressionSyntax; typedef struct FuncCallExpressionSyntax FuncCallExpressionSyntax; struct FuncCallExpressionSyntax {
    SyntaxInfo info;
    SyntaxNode* func;
    SyntaxToken leftParen;
    SyntaxNodeArray argumentsWithSeparators;
    SyntaxToken rightParen;
};

struct ArrayIndexExpressionSyntax; typedef struct ArrayIndexExpressionSyntax ArrayIndexExpressionSyntax; struct ArrayIndexExpressionSyntax {
    SyntaxInfo info;
    SyntaxNode* arr;
    SyntaxToken leftBracket;
    SyntaxNode* indexExpression;
    SyntaxToken rightBracket;
};

struct MemberAccessExpressionSyntax; typedef struct MemberAccessExpressionSyntax MemberAccessExpressionSyntax; struct MemberAccessExpressionSyntax {
    SyntaxInfo info;
    SyntaxNode* container;
    SyntaxToken accessToken;
    SyntaxToken memberIdentifier;
};

struct TypeCastExpressionSyntax; typedef struct TypeCastExpressionSyntax TypeCastExpressionSyntax; struct TypeCastExpressionSyntax {
    SyntaxInfo info;
    SyntaxToken leftParen;
    SyntaxToken asKeyword;
    SyntaxNode* targetTypeExpression;
    SyntaxToken rightParen;
    SyntaxNode* expression;
};

struct TernaryConditionalExpressionSyntax; typedef struct TernaryConditionalExpressionSyntax TernaryConditionalExpressionSyntax; struct TernaryConditionalExpressionSyntax {
    SyntaxInfo info;
    SyntaxNode* conditionExpression;
    SyntaxToken questionmark;
    SyntaxNode* thenExpression;
    SyntaxToken colon;
    SyntaxNode* elseExpression;
};

struct SizeofExpressionSyntax; typedef struct SizeofExpressionSyntax SizeofExpressionSyntax; struct SizeofExpressionSyntax {
    SyntaxInfo info;
    SyntaxToken sizeofKeyword;
    SyntaxToken leftParen;
    SyntaxNode* typeExpression;
    SyntaxToken rightParen;
};

struct TypeExpressionSyntax; typedef struct TypeExpressionSyntax TypeExpressionSyntax; struct TypeExpressionSyntax {
    SyntaxInfo info;
    SyntaxNodeArray typeTokens;
};

struct BlockStatementSyntax; typedef struct BlockStatementSyntax BlockStatementSyntax; struct BlockStatementSyntax {
    SyntaxInfo info;
    SyntaxToken leftBrace;
    SyntaxNodeArray statements;
    SyntaxToken rightBrace;
};

struct ExpressionStatementSyntax; typedef struct ExpressionStatementSyntax ExpressionStatementSyntax; struct ExpressionStatementSyntax {
    SyntaxInfo info;
    SyntaxNode* expression;
    SyntaxToken semicolon;
};

struct IfStatementSyntax; typedef struct IfStatementSyntax IfStatementSyntax; struct IfStatementSyntax {
    SyntaxInfo info;
    SyntaxToken ifKeyword;
    SyntaxToken leftParen;
    SyntaxNode* condition;
    SyntaxToken rightParen;
    SyntaxNode* thenBlock;
    SyntaxToken elseKeyword;
    SyntaxNode* elseBlock;
};

struct DoWhileStatementSyntax; typedef struct DoWhileStatementSyntax DoWhileStatementSyntax; struct DoWhileStatementSyntax {
    SyntaxInfo info;
    SyntaxToken doKeyword;
    SyntaxNode* body;
    SyntaxToken whileKeyword;
    SyntaxToken leftParen;
    SyntaxNode* condition;
    SyntaxToken rightParen;
    SyntaxToken semicolon;
};

struct WhileStatementSyntax; typedef struct WhileStatementSyntax WhileStatementSyntax; struct WhileStatementSyntax {
    SyntaxInfo info;
    SyntaxToken whileKeyword;
    SyntaxToken leftParen;
    SyntaxNode* condition;
    SyntaxToken rightParen;
    SyntaxNode* body;
};

struct ForStatementSyntax; typedef struct ForStatementSyntax ForStatementSyntax; struct ForStatementSyntax {
    SyntaxInfo info;
    SyntaxToken forKeyword;
    SyntaxToken leftParen;
    SyntaxNode* initializerStatement;
    SyntaxNode* conditionStatement;
    SyntaxNode* incrementExpression;
    SyntaxToken rightParen;
    SyntaxNode* body;
};

struct ReturnStatementSyntax; typedef struct ReturnStatementSyntax ReturnStatementSyntax; struct ReturnStatementSyntax {
    SyntaxInfo info;
    SyntaxToken returnKeyword;
    SyntaxNode* returnExpression;
    SyntaxToken semicolon;
};

struct BreakStatementSyntax; typedef struct BreakStatementSyntax BreakStatementSyntax; struct BreakStatementSyntax {
    SyntaxInfo info;
    SyntaxToken breakKeyword;
    SyntaxToken semicolon;
};

struct ContinueStatementSyntax; typedef struct ContinueStatementSyntax ContinueStatementSyntax; struct ContinueStatementSyntax {
    SyntaxInfo info;
    SyntaxToken continueKeyword;
    SyntaxToken semicolon;
};

struct SwitchStatementSyntax; typedef struct SwitchStatementSyntax SwitchStatementSyntax; struct SwitchStatementSyntax {
    SyntaxInfo info;
    SyntaxToken switchKeyword;
    SyntaxToken leftParen;
    SyntaxNode* switchExpression;
    SyntaxToken rightParen;
    SyntaxToken leftBrace;
    SyntaxNodeArray caseStatements;
    SyntaxToken rightBrace;
};

struct CaseStatementSyntax; typedef struct CaseStatementSyntax CaseStatementSyntax; struct CaseStatementSyntax {
    SyntaxInfo info;
    SyntaxToken caseKeyword;
    SyntaxNode* literalExpression;
    SyntaxToken colon;
    SyntaxNode* body;
};

struct DefaultStatementSyntax; typedef struct DefaultStatementSyntax DefaultStatementSyntax; struct DefaultStatementSyntax {
    SyntaxInfo info;
    SyntaxToken defaultKeyword;
    SyntaxToken colon;
    SyntaxNode* body;
};

struct VariableDeclarationStatementSyntax; typedef struct VariableDeclarationStatementSyntax VariableDeclarationStatementSyntax; struct VariableDeclarationStatementSyntax {
    SyntaxInfo info;
    SyntaxToken letKeyword;
    SyntaxNode* typeExpression;
    SyntaxToken identifier;
    SyntaxToken leftBracket;
    SyntaxToken arraySizeLiteral;
    SyntaxToken rightBracket;
    SyntaxToken equalsToken;
    SyntaxNode* initializerExpression;
    SyntaxToken terminatorToken;
};

struct ModuleStatementSyntax; typedef struct ModuleStatementSyntax ModuleStatementSyntax; struct ModuleStatementSyntax {
    SyntaxInfo info;
    SyntaxNodeArray globalStatements;
};

struct ImportDeclarationStatementSyntax; typedef struct ImportDeclarationStatementSyntax ImportDeclarationStatementSyntax; struct ImportDeclarationStatementSyntax {
    SyntaxInfo info;
    SyntaxToken importKeyword;
    SyntaxToken modulenameLiteral;
};

struct GlobalVariableStatementSyntax; typedef struct GlobalVariableStatementSyntax GlobalVariableStatementSyntax; struct GlobalVariableStatementSyntax {
    SyntaxInfo info;
    SyntaxToken externKeyword;
    SyntaxNode* variableDeclarationStatement;
};

struct EnumMemberClauseSyntax; typedef struct EnumMemberClauseSyntax EnumMemberClauseSyntax; struct EnumMemberClauseSyntax {
    SyntaxInfo info;
    SyntaxToken identifier;
    SyntaxToken equals;
    SyntaxToken integerLiteral;
    SyntaxToken comma;
};

struct EnumDeclarationStatementSyntax; typedef struct EnumDeclarationStatementSyntax EnumDeclarationStatementSyntax; struct EnumDeclarationStatementSyntax {
    SyntaxInfo info;
    SyntaxToken externKeyword;
    SyntaxToken enumKeyword;
    SyntaxToken classKeyword;
    SyntaxToken identifier;
    SyntaxToken semicolon;
};

struct EnumDefinitionStatementSyntax; typedef struct EnumDefinitionStatementSyntax EnumDefinitionStatementSyntax; struct EnumDefinitionStatementSyntax {
    SyntaxInfo info;
    SyntaxToken externKeyword;
    SyntaxToken enumKeyword;
    SyntaxToken classKeyword;
    SyntaxToken identifier;
    SyntaxToken leftBrace;
    SyntaxNodeArray memberClauses;
    SyntaxToken rightBrace;
    SyntaxToken semicolon;
};

struct StructOrUnionDeclarationStatementSyntax; typedef struct StructOrUnionDeclarationStatementSyntax StructOrUnionDeclarationStatementSyntax; struct StructOrUnionDeclarationStatementSyntax {
    SyntaxInfo info;
    SyntaxToken externKeyword;
    SyntaxToken structOrUnionKeyword;
    SyntaxToken identifier;
    SyntaxToken semicolon;
};

struct StructOrUnionDefinitionStatementSyntax; typedef struct StructOrUnionDefinitionStatementSyntax StructOrUnionDefinitionStatementSyntax; struct StructOrUnionDefinitionStatementSyntax {
    SyntaxInfo info;
    SyntaxToken externKeyword;
    SyntaxToken structOrUnionKeyword;
    SyntaxToken identifier;
    SyntaxToken leftBrace;
    SyntaxNodeArray memberDeclarationStatements;
    SyntaxToken rightBrace;
    SyntaxToken semicolon;
};

struct FunctionParameterClauseSyntax; typedef struct FunctionParameterClauseSyntax FunctionParameterClauseSyntax; struct FunctionParameterClauseSyntax {
    SyntaxInfo info;
    SyntaxNode* typeExpression;
    SyntaxToken identifier;
    SyntaxToken comma;
    SyntaxToken dotdot;
};

struct FunctionDeclarationStatementSyntax; typedef struct FunctionDeclarationStatementSyntax FunctionDeclarationStatementSyntax; struct FunctionDeclarationStatementSyntax {
    SyntaxInfo info;
    SyntaxToken externKeyword;
    SyntaxToken funKeyword;
    SyntaxNode* returnType;
    SyntaxToken identifier;
    SyntaxToken leftParen;
    SyntaxNodeArray params;
    SyntaxToken rightParen;
    SyntaxToken semicolon;
};

struct FunctionDefinitionStatementSyntax; typedef struct FunctionDefinitionStatementSyntax FunctionDefinitionStatementSyntax; struct FunctionDefinitionStatementSyntax {
    SyntaxInfo info;
    SyntaxToken externKeyword;
    SyntaxToken funKeyword;
    SyntaxNode* returnType;
    SyntaxToken identifier;
    SyntaxToken leftParen;
    SyntaxNodeArray params;
    SyntaxToken rightParen;
    SyntaxNode* body;
};

union SyntaxNode; typedef union SyntaxNode SyntaxNode; union SyntaxNode{
    SyntaxKind kind;
    SyntaxInfo info;
    SyntaxToken token;
    StringLiteralExpressionSyntax stringLiteralExpr;
    NullLiteralExpressionSyntax nullLiteralExpr;
    IntegerLiteralExpressionSyntax integerLiteralExpr;
    CharacterLiteralExpressionSyntax characterLiteralExpr;
    BoolLiteralExpressionSyntax boolLiteralExpr;
    EnumLiteralExpressionSyntax enumLiteralExpr;
    ArrayLiteralExpressionSyntax arrayLiteralExpr;
    NameExpressionSyntax nameExpr;
    UnaryExpressionSyntax unaryExpr;
    BinaryExpressionSyntax binaryExpr;
    ParenthesizedExpressionSyntax parenthesizedExpr;
    FuncCallExpressionSyntax funcCallExpr;
    ArrayIndexExpressionSyntax arrayIndexExpr;
    MemberAccessExpressionSyntax memberAccessExpr;
    TypeCastExpressionSyntax typeCastExpr;
    TernaryConditionalExpressionSyntax ternaryConditionalExpr;
    SizeofExpressionSyntax sizeofExpr;
    TypeExpressionSyntax typeExpr;
    BlockStatementSyntax blockStmt;
    ExpressionStatementSyntax expressionStmt;
    IfStatementSyntax ifStmt;
    DoWhileStatementSyntax doWhileStmt;
    WhileStatementSyntax whileStmt;
    ForStatementSyntax forStmt;
    ReturnStatementSyntax returnStmt;
    BreakStatementSyntax breakStmt;
    ContinueStatementSyntax continueStmt;
    SwitchStatementSyntax switchStmt;
    CaseStatementSyntax caseStmt;
    DefaultStatementSyntax defaultStmt;
    VariableDeclarationStatementSyntax variableDeclarationStmt;
    EnumMemberClauseSyntax enumMember;
    ModuleStatementSyntax moduleStmt;
    ImportDeclarationStatementSyntax importStmt;
    GlobalVariableStatementSyntax globalVariableStmt;
    EnumDeclarationStatementSyntax enumDeclarationStmt;
    EnumDefinitionStatementSyntax enumDefinitionStmt;
    StructOrUnionDeclarationStatementSyntax structOrUnionDeclarationStmt;
    StructOrUnionDefinitionStatementSyntax structOrUnionDefinitionStmt;
    FunctionDeclarationStatementSyntax functionDeclarationStmt;
    FunctionDefinitionStatementSyntax functionDefinitionStmt;
};

static SyntaxNode* SyntaxNodeCreate(SyntaxKind kind, SyntaxTree* tree) {
    SyntaxNode* node = (SyntaxNode*)malloc(sizeof(SyntaxNode));
    assert(node != NULL);
    node->info.kind = kind;
    node->info.tree = tree;
    return node;
}

enum TypeKind; typedef enum TypeKind TypeKind; enum TypeKind {
    TypeKind_PrimitiveNull = 0,
    TypeKind_PrimitiveVoid = 1,
    TypeKind_PrimitiveBool = 2,
    TypeKind_PrimitiveChar = 3,
    TypeKind_PrimitiveByte = 4,
    TypeKind_PrimitiveShort = 5,
    TypeKind_PrimitiveInt = 6,
    TypeKind_PrimitiveLong = 7,
    TypeKind_PrimitiveCString = 8,
    TypeKind_Struct = 9,
    TypeKind_Union = 10,
    TypeKind_Enum = 11,
};

struct Type; typedef struct Type Type; struct Type {
    TypeKind kind;
    int32 baseIndirectionLevel;
    String name;
    bool isArray;
    int64 arrayElementCount;
};

static Type TypeCreate(TypeKind kind, int32 baseIndirectionLevel, String name) {
    Type result;
    result.kind = kind;
    result.baseIndirectionLevel = baseIndirectionLevel;
    result.name = name;
    result.isArray = false;
    result.arrayElementCount = -1;
    return result;
}

static int32 TypeGetIndirectionLevel(Type type) {
    return type.baseIndirectionLevel + (int32)type.isArray + (int32)(type.kind == TypeKind_PrimitiveCString);
}

static Type GetElementTypeForArrayType(Type type) {
    assert(type.isArray);
    type.isArray = false;
    return type;
}

static String TypeGetText(Type type) {
    char* buffer = (char*)malloc(128);
    int32 bufferpos = 0;
    switch (type.kind) {
        case TypeKind_PrimitiveNull: {
            bufferpos = snprintf(buffer, 128, "void");
            assert(!type.isArray);
            assert(type.baseIndirectionLevel == 1);
            break;
        }
        case TypeKind_PrimitiveVoid: {
            bufferpos = snprintf(buffer, 128, "void");
            break;
        }
        case TypeKind_PrimitiveBool: {
            bufferpos = snprintf(buffer, 128, "bool");
            break;
        }
        case TypeKind_PrimitiveChar: {
            bufferpos = snprintf(buffer, 128, "char");
            break;
        }
        case TypeKind_PrimitiveByte: {
            bufferpos = snprintf(buffer, 128, "byte");
            break;
        }
        case TypeKind_PrimitiveShort: {
            bufferpos = snprintf(buffer, 128, "short");
            break;
        }
        case TypeKind_PrimitiveInt: {
            bufferpos = snprintf(buffer, 128, "int");
            break;
        }
        case TypeKind_PrimitiveLong: {
            bufferpos = snprintf(buffer, 128, "long");
            break;
        }
        case TypeKind_PrimitiveCString: {
            bufferpos = snprintf(buffer, 128, "cstring");
            break;
        }
        case TypeKind_Struct: // Fallthrough
        case TypeKind_Union: // Fallthrough
        case TypeKind_Enum: {
            bufferpos = snprintf(buffer, 128, "%s", type.name.cstr);
            break;
        }
        default: {
            assert(false && "unknown kind");
        }
    }
    for (int32 index = 0; index < type.baseIndirectionLevel; index += 1) {
        buffer[bufferpos] = '*';
        bufferpos += 1;
    }
    if (type.isArray) {
        buffer[bufferpos] = '[';
        bufferpos += 1;
        buffer[bufferpos] = ']';
        bufferpos += 1;
    }
    buffer[bufferpos] = '\0';
    String result;
    result.cstr = buffer;
    result.length = bufferpos;
    return result;
}

static Type TypeCreatePrimitive(TypeKind kind) {
    assert(kind != TypeKind_Struct);
    return TypeCreate(kind, 0, StringCreateEmpty());
}

static Type TypeCreateVoid() {
    return TypeCreatePrimitive(TypeKind_PrimitiveVoid);
}

static bool IsNull(Type type) {
    return type.kind == TypeKind_PrimitiveNull;
}

static bool IsVoidType(Type type) {
    return type.kind == TypeKind_PrimitiveVoid && TypeGetIndirectionLevel(type) == 0;
}

static bool IsVoidPointer(Type type) {
    return type.kind == TypeKind_PrimitiveVoid && type.baseIndirectionLevel == 1 && !type.isArray;
}

static bool IsCharType(Type type) {
    if (TypeGetIndirectionLevel(type) > 0) {
        return false;
    }
    return type.kind == TypeKind_PrimitiveChar;
}

static bool IsNumberType(Type type) {
    if (TypeGetIndirectionLevel(type) > 0) {
        return false;
    }
    switch (type.kind) {
        case TypeKind_PrimitiveBool: // Fallthrough
        case TypeKind_PrimitiveByte: // Fallthrough
        case TypeKind_PrimitiveShort: // Fallthrough
        case TypeKind_PrimitiveInt: // Fallthrough
        case TypeKind_PrimitiveLong: {
            return true;
        }
        default: {
            return false;
        }
    }
}

static bool IsPointerType(Type type) {
    return type.kind == TypeKind_PrimitiveCString || (type.baseIndirectionLevel > 0 && !type.isArray);
}

static bool TypesIdentical(Type a, Type b) {
    if (a.kind != b.kind) {
        return false;
    }
    if (TypeGetIndirectionLevel(a) != TypeGetIndirectionLevel(b)) {
        return false;
    }
    return StringEquals(a.name, b.name);
}

enum TypeConversionResult; typedef enum TypeConversionResult TypeConversionResult; enum TypeConversionResult {
    TypeConversionResult_NonConvertible = 0,
    TypeConversionResult_Identical = 1,
    TypeConversionResult_ImplictlyConvertible = 2,
    TypeConversionResult_ExplicitlyConvertible = 3,
};

static TypeConversionResult CanConvertTypeFromTo(Type from, Type to) {
    if (IsVoidType(from) || IsVoidType(to)) {
        return TypeConversionResult_NonConvertible;
    }
    if (TypesIdentical(from, to)) {
        return TypeConversionResult_Identical;
    }
    if (TypeGetIndirectionLevel(from) == 0 && TypeGetIndirectionLevel(to) == 0) {
        if (IsNumberType(from) && IsNumberType(to)) {
            if (from.kind <= to.kind) {
                return TypeConversionResult_ImplictlyConvertible;
            } else {
                return TypeConversionResult_ExplicitlyConvertible;
            }
        }
        if (from.kind == TypeKind_PrimitiveChar && IsNumberType(to)) {
            return TypeConversionResult_ExplicitlyConvertible;
        }
        if (IsNumberType(from) && to.kind == TypeKind_PrimitiveChar) {
            return TypeConversionResult_ExplicitlyConvertible;
        }
        if (from.kind == TypeKind_Enum && IsNumberType(to)) {
            return TypeConversionResult_ExplicitlyConvertible;
        }
        if (IsNumberType(from) && to.kind == TypeKind_Enum) {
            return TypeConversionResult_ExplicitlyConvertible;
        }
    }
    if (IsPointerType(from) && IsVoidPointer(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (IsVoidPointer(from) && IsPointerType(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (from.baseIndirectionLevel == 1 && to.baseIndirectionLevel == 1) {
        if (from.kind == TypeKind_PrimitiveVoid || to.kind == TypeKind_PrimitiveVoid) {
            return TypeConversionResult_ImplictlyConvertible;
        } else {
            if (IsNull(from) || IsNull(to)) {
                return TypeConversionResult_ImplictlyConvertible;
            } else {
                return TypeConversionResult_ExplicitlyConvertible;
            }
        }
    }
    if (IsPointerType(from) && IsNull(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (IsNull(from) && IsPointerType(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (IsNull(from) && to.kind == TypeKind_PrimitiveCString) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (from.kind == TypeKind_PrimitiveCString && IsNull(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (from.kind == to.kind && from.isArray && !to.isArray && TypeGetIndirectionLevel(from) == TypeGetIndirectionLevel(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (from.kind == TypeKind_PrimitiveChar && to.kind == TypeKind_PrimitiveCString && TypeGetIndirectionLevel(from) == TypeGetIndirectionLevel(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    return TypeConversionResult_NonConvertible;
}

static Type GetPointerTypeForBaseType(Type type) {
    assert(type.kind != TypeKind_PrimitiveNull);
    Type result = type;
    result.baseIndirectionLevel += 1;
    return result;
}

static Type GetBaseTypeForPointerType(Type type) {
    assert(type.baseIndirectionLevel > 0 || type.kind == TypeKind_PrimitiveCString);
    Type result = type;
    if (result.baseIndirectionLevel > 0) {
        result.baseIndirectionLevel -= 1;
    } else {
        if (type.kind == TypeKind_PrimitiveCString) {
            result.kind = TypeKind_PrimitiveChar;
        }
    }
    return result;
}

static Type GetTypeThatFitsBothTypes(Type a, Type b) {
    TypeConversionResult conversion = CanConvertTypeFromTo(a, b);
    if (TypesIdentical(a, b)) {
        return a;
    }
    if (a.baseIndirectionLevel == 0 && b.baseIndirectionLevel == 0) {
        if (IsNumberType(a) && IsNumberType(b)) {
            if (a.kind <= b.kind) {
                return b;
            } else {
                return a;
            }
        }
    }
    if (IsPointerType(a) && IsNull(b)) {
        return a;
    }
    if (IsPointerType(b) && IsNull(a)) {
        return b;
    }
    return TypeCreateVoid();
}

enum ASTNodeKind; typedef enum ASTNodeKind ASTNodeKind; enum ASTNodeKind {
    ASTNodeKind_Identity = 0,
    ASTNodeKind_Negation = 1,
    ASTNodeKind_LogicalNegation = 2,
    ASTNodeKind_BitwiseNegation = 3,
    ASTNodeKind_Dereference = 4,
    ASTNodeKind_Address = 5,
    ASTNodeKind_Assignment = 6,
    ASTNodeKind_Add = 7,
    ASTNodeKind_AddAssignment = 8,
    ASTNodeKind_Subtract = 9,
    ASTNodeKind_SubtractAssignment = 10,
    ASTNodeKind_Multiply = 11,
    ASTNodeKind_MultiplyAssignment = 12,
    ASTNodeKind_Divide = 13,
    ASTNodeKind_DivideAssignment = 14,
    ASTNodeKind_Remainder = 15,
    ASTNodeKind_RemainderAssignment = 16,
    ASTNodeKind_BitwiseXor = 17,
    ASTNodeKind_BitwiseXorAssignment = 18,
    ASTNodeKind_BitwiseAnd = 19,
    ASTNodeKind_BitwiseAndAssignment = 20,
    ASTNodeKind_BitwiseOr = 21,
    ASTNodeKind_BitwiseOrAssignment = 22,
    ASTNodeKind_BitshiftLeft = 23,
    ASTNodeKind_BitshiftLeftAssignment = 24,
    ASTNodeKind_BitshiftRight = 25,
    ASTNodeKind_BitshiftRightAssignment = 26,
    ASTNodeKind_LogicalAnd = 27,
    ASTNodeKind_LogicalOr = 28,
    ASTNodeKind_AddToPointer = 29,
    ASTNodeKind_AddToPointerAssignment = 30,
    ASTNodeKind_SubtractFromPointer = 31,
    ASTNodeKind_SubtractFromPointerAssignment = 32,
    ASTNodeKind_DistanceBetweenPointers = 33,
    ASTNodeKind_Equals = 34,
    ASTNodeKind_NotEquals = 35,
    ASTNodeKind_Less = 36,
    ASTNodeKind_LessEquals = 37,
    ASTNodeKind_Greater = 38,
    ASTNodeKind_GreaterEquals = 39,
    ASTNodeKind_NameExpression = 40,
    ASTNodeKind_FunccallExpression = 41,
    ASTNodeKind_Arrayindexing = 42,
    ASTNodeKind_Memberaccess = 43,
    ASTNodeKind_CastExpression = 44,
    ASTNodeKind_ParenthesizedExpression = 45,
    ASTNodeKind_TernaryConditionalExpression = 46,
    ASTNodeKind_SizeOfExpression = 47,
    ASTNodeKind_TypeExpression = 48,
    ASTNodeKind_NullLiteral = 49,
    ASTNodeKind_IntegerLiteral = 50,
    ASTNodeKind_CharacterLiteral = 51,
    ASTNodeKind_BoolLiteral = 52,
    ASTNodeKind_StringLiteral = 53,
    ASTNodeKind_EnumValueLiteral = 54,
    ASTNodeKind_ArrayLiteral = 55,
    ASTNodeKind_BlockStatement = 56,
    ASTNodeKind_ExpressionStatement = 57,
    ASTNodeKind_IfStatement = 58,
    ASTNodeKind_DoWhileStatement = 59,
    ASTNodeKind_WhileStatement = 60,
    ASTNodeKind_ForStatement = 61,
    ASTNodeKind_ReturnStatement = 62,
    ASTNodeKind_BreakStatement = 63,
    ASTNodeKind_ContinueStatement = 64,
    ASTNodeKind_SwitchStatement = 65,
    ASTNodeKind_CaseStatement = 66,
    ASTNodeKind_DefaultStatement = 67,
    ASTNodeKind_EnumDeclarationStatement = 68,
    ASTNodeKind_EnumDefinitionStatement = 69,
    ASTNodeKind_StructDeclarationStatement = 70,
    ASTNodeKind_StructDefinitionStatement = 71,
    ASTNodeKind_UnionDeclarationStatement = 72,
    ASTNodeKind_UnionDefinitionStatement = 73,
    ASTNodeKind_FunctionDeclarationStatement = 74,
    ASTNodeKind_FunctionDefinitionStatement = 75,
    ASTNodeKind_VariableDeclarationStatement = 76,
    ASTNodeKind_ArrayDeclarationStatement = 77,
    ASTNodeKind_Module = 78,
};

struct ASTNode; typedef struct ASTNode ASTNode;

struct ASTNodeArray; typedef struct ASTNodeArray ASTNodeArray; struct ASTNodeArray {
    ASTNode** nodes;
    int32 count;
    int32 capacity;
};

static ASTNodeArray ASTNodeArrayCreate() {
    ASTNodeArray result;
    result.nodes = NULL;
    result.count = 0;
    result.capacity = 0;
    return result;
}

static void ASTNodeArrayGrow(ASTNodeArray* array, int32 newCapacity) {
    array->capacity = newCapacity;
    array->nodes = (ASTNode**)realloc(array->nodes, newCapacity * sizeof(ASTNode*));
    if (array->nodes == NULL) {
        fprintf(stderr, "Unable to malloc new AST array buffer");
        exit(1);
    }
}

static int32 ASTNodeArrayPush(ASTNodeArray* array, ASTNode* node) {
    if (array->count == array->capacity) {
        int32 newCapacity = 2 * array->capacity;
        if (newCapacity == 0) {
            newCapacity = 64;
        }
        ASTNodeArrayGrow(array, newCapacity);
    }
    int32 insertionIndex = array->count;
    array->nodes[insertionIndex] = node;
    array->count += 1;
    return insertionIndex;
}

struct Symbol; typedef struct Symbol Symbol;

struct SymbolTable; typedef struct SymbolTable SymbolTable;

struct ASTNode; typedef struct ASTNode ASTNode; struct ASTNode {
    ASTNodeKind kind;
    Type type;
    SymbolTable* symbolTable;
    SyntaxNode* syntax;
    SyntaxToken token;
    ASTNode* left;
    ASTNode* right;
    ASTNode* extra1;
    ASTNode* extra2;
    bool isRValue;
    int64 intvalue;
    String stringvalue;
    Symbol* symbol;
    ASTNodeArray children;
};

static ASTNode* ASTNodeCreate(ASTNodeKind kind, SymbolTable* symbolTable, SyntaxToken token) {
    ASTNode* node = (ASTNode*)malloc(sizeof(ASTNode));
    if (node == NULL) {
        fprintf(stderr, "Unable to malloc new AST Node");
        exit(1);
    }
    node->kind = kind;
    node->type = TypeCreateVoid();
    node->symbolTable = symbolTable;
    node->token = token;
    node->syntax = NULL;
    node->left = NULL;
    node->right = NULL;
    node->extra1 = NULL;
    node->extra2 = NULL;
    node->isRValue = false;
    node->intvalue = 0;
    node->symbol = NULL;
    node->children = ASTNodeArrayCreate();
    return node;
}

static ASTNode* ASTNodeCreate2(ASTNodeKind kind, SymbolTable* symbolTable, SyntaxNode* syntax) {
    ASTNode* node = (ASTNode*)malloc(sizeof(ASTNode));
    if (node == NULL) {
        fprintf(stderr, "Unable to malloc new AST Node");
        exit(1);
    }
    node->kind = kind;
    node->type = TypeCreateVoid();
    node->symbolTable = symbolTable;
    node->syntax = syntax;
    node->left = NULL;
    node->right = NULL;
    node->extra1 = NULL;
    node->extra2 = NULL;
    node->isRValue = false;
    node->intvalue = 0;
    node->symbol = NULL;
    node->children = ASTNodeArrayCreate();
    return node;
}

enum SymbolKind; typedef enum SymbolKind SymbolKind; enum SymbolKind {
    SymbolKind_Function = 0,
    SymbolKind_Struct = 1,
    SymbolKind_Union = 2,
    SymbolKind_Enum = 3,
    SymbolKind_Variable = 4,
    SymbolKind_Parameter = 5,
    SymbolKind_Member = 6,
    SymbolKind_Enumvalue = 7,
};

enum SymbolScopeKind; typedef enum SymbolScopeKind SymbolScopeKind; enum SymbolScopeKind {
    SymbolScopeKind_Extern = 0,
    SymbolScopeKind_Global = 1,
    SymbolScopeKind_Local = 2,
    SymbolScopeKind_LocalPersist = 3,
};

struct SymbolTable; typedef struct SymbolTable SymbolTable;

struct Symbol; typedef struct Symbol Symbol; struct Symbol {
    String name;
    SymbolKind kind;
    SymbolScopeKind scopeKind;
    Type type;
    bool isVariadric;
    SymbolTable* membersSymbolTable;
    bool alreadyDefined;
    int64 enumValue;
};

static Symbol* SymbolCreate(String name, SymbolKind kind, SymbolScopeKind scopeKind, Type type) {
    Symbol* newSymbol = (Symbol*)malloc(sizeof(Symbol));
    newSymbol->name = name;
    newSymbol->kind = kind;
    newSymbol->scopeKind = scopeKind;
    newSymbol->type = type;
    newSymbol->isVariadric = false;
    newSymbol->membersSymbolTable = NULL;
    newSymbol->alreadyDefined = false;
    newSymbol->enumValue = 0;
    return newSymbol;
}

struct SymbolTable; typedef struct SymbolTable SymbolTable; struct SymbolTable {
    SymbolTable* parent;
    Symbol** symbols;
    int32 count;
    int32 capacity;
};

static SymbolTable* SymbolTableCreate(SymbolTable* parent) {
    SymbolTable* result = (SymbolTable*)malloc(sizeof(SymbolTable));
    result->parent = parent;
    result->symbols = NULL;
    result->count = 0;
    result->capacity = 0;
    return result;
}

static void SymbolTableGrow(SymbolTable* table, int32 newCapacity) {
    table->capacity = newCapacity;
    table->symbols = (Symbol**)realloc(table->symbols, newCapacity * sizeof(Symbol*));
    if (table->symbols == NULL) {
        fprintf(stderr, "Unable to malloc new AST array buffer");
        exit(1);
    }
}

static int32 SymbolTablePush(SymbolTable* table, Symbol* symbol) {
    if (table->count == table->capacity) {
        int32 newCapacity = 2 * table->capacity;
        if (newCapacity == 0) {
            newCapacity = 64;
        }
        SymbolTableGrow(table, newCapacity);
    }
    int32 insertionIndex = table->count;
    table->symbols[insertionIndex] = symbol;
    table->count += 1;
    return insertionIndex;
}

static Symbol* GetSymbolFromLocalScope(SymbolTable* table, String name) {
    for (int32 index = 0; index < table->count; index += 1) {
        if (StringEquals(name, table->symbols[index]->name)) {
            return table->symbols[index];
        }
    }
    return NULL;
}

static Symbol* GetSymbol(SymbolTable* table, String name) {
    Symbol* result = GetSymbolFromLocalScope(table, name);
    if (result != NULL) {
        return result;
    }
    if (table->parent != NULL) {
        return GetSymbol(table->parent, name);
    }
    return NULL;
}

static Symbol* AddSymbol(SymbolTable* table, String name, SymbolKind kind, SymbolScopeKind scopeKind, Type type) {
    Symbol* existingLocal = GetSymbolFromLocalScope(table, name);
    if (existingLocal != NULL) {
        return NULL;
    }
    Symbol* existing = GetSymbol(table, name);
    if (existing != NULL) {
        if (existing->kind == SymbolKind_Parameter) {
            return NULL;
        }
    }
    Symbol* newSymbol = SymbolCreate(name, kind, scopeKind, type);
    SymbolTablePush(table, newSymbol);
    return newSymbol;
}

static int32 GetUnaryOperatorPrecedence(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind_PlusToken: // Fallthrough
        case SyntaxKind_MinusToken: // Fallthrough
        case SyntaxKind_BangToken: // Fallthrough
        case SyntaxKind_TildeToken: // Fallthrough
        case SyntaxKind_StarToken: // Fallthrough
        case SyntaxKind_AmpersandToken: {
            return 13;
        }
        default: {
            return 0;
        }
    }
}

static bool IsBinaryOperatorRightAssociative(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind_EqualsToken: // Fallthrough
        case SyntaxKind_PlusEqualsToken: // Fallthrough
        case SyntaxKind_MinusEqualsToken: // Fallthrough
        case SyntaxKind_StarEqualsToken: // Fallthrough
        case SyntaxKind_SlashEqualsToken: // Fallthrough
        case SyntaxKind_PercentEqualsToken: // Fallthrough
        case SyntaxKind_HatEqualsToken: // Fallthrough
        case SyntaxKind_AmpersandEqualsToken: // Fallthrough
        case SyntaxKind_PipeEqualsToken: // Fallthrough
        case SyntaxKind_LessLessEqualsToken: // Fallthrough
        case SyntaxKind_GreaterGreaterEqualsToken: {
            return true;
        }
        default: {
            return false;
        }
    }
}

static int32 GetBinaryOperatorPrecedence(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind_StarToken: // Fallthrough
        case SyntaxKind_SlashToken: // Fallthrough
        case SyntaxKind_PercentToken: {
            return 12;
        }
        case SyntaxKind_PlusToken: // Fallthrough
        case SyntaxKind_MinusToken: {
            return 11;
        }
        case SyntaxKind_LessLessToken: // Fallthrough
        case SyntaxKind_GreaterGreaterToken: {
            return 10;
        }
        case SyntaxKind_LessToken: // Fallthrough
        case SyntaxKind_LessEqualsToken: // Fallthrough
        case SyntaxKind_GreaterToken: // Fallthrough
        case SyntaxKind_GreaterEqualsToken: {
            return 9;
        }
        case SyntaxKind_EqualsEqualsToken: // Fallthrough
        case SyntaxKind_BangEqualsToken: {
            return 8;
        }
        case SyntaxKind_AmpersandToken: {
            return 7;
        }
        case SyntaxKind_HatToken: {
            return 6;
        }
        case SyntaxKind_PipeToken: {
            return 5;
        }
        case SyntaxKind_AmpersandAmpersandToken: {
            return 4;
        }
        case SyntaxKind_PipePipeToken: {
            return 3;
        }
        default: {
            return 0;
        }
    }
}

struct UnaryOperator; typedef struct UnaryOperator UnaryOperator; struct UnaryOperator {
    SyntaxKind tokenKind;
    ASTNodeKind operatorKind;
    Type operandType;
    Type resultType;
    bool resultIsRValue;
    bool operandMustBeLValue;
};

static UnaryOperator GetUnaryOperationForToken(SyntaxToken token, Type operandType) {
    UnaryOperator result;
    result.tokenKind = token.kind;
    result.operandType = operandType;
    result.resultType = operandType;
    result.resultIsRValue = true;
    result.operandMustBeLValue = false;
    if (IsPointerType(operandType) || operandType.kind == TypeKind_PrimitiveCString) {
        if (token.kind == SyntaxKind_StarToken) {
            result.operatorKind = ASTNodeKind_Dereference;
            result.resultType = GetBaseTypeForPointerType(operandType);
            result.resultIsRValue = false;
            result.operandMustBeLValue = true;
            return result;
        }
    } else {
        if (IsNumberType(operandType)) {
            if (token.kind == SyntaxKind_PlusToken) {
                result.operatorKind = ASTNodeKind_Identity;
                return result;
            }
            if (token.kind == SyntaxKind_MinusToken) {
                result.operatorKind = ASTNodeKind_Negation;
                return result;
            }
            if (token.kind == SyntaxKind_BangToken) {
                result.operatorKind = ASTNodeKind_LogicalNegation;
                return result;
            }
            if (token.kind == SyntaxKind_TildeToken) {
                result.operatorKind = ASTNodeKind_BitwiseNegation;
                return result;
            }
        }
    }
    if (token.kind == SyntaxKind_AmpersandToken) {
        result.operatorKind = ASTNodeKind_Address;
        result.resultType = GetPointerTypeForBaseType(operandType);
        result.resultIsRValue = false;
        result.operandMustBeLValue = true;
        return result;
    }
    ReportError(TokenGetLocation(token), "No applicable unary operation for combination token '%s', type '%s'", TokenKindToString(token.kind).cstr, TypeGetText(operandType).cstr);
    exit(1);
}

struct BinaryOperator; typedef struct BinaryOperator BinaryOperator; struct BinaryOperator {
    SyntaxKind tokenKind;
    ASTNodeKind operatorKind;
    Type leftType;
    Type rightType;
    Type resultType;
    bool resultIsRValue;
    bool leftMustBeLValue;
    bool rightMustBeLValue;
};

static BinaryOperator GetBinaryOperationForToken(SyntaxToken token, Type leftType, Type rightType) {
    BinaryOperator result;
    result.tokenKind = token.kind;
    result.leftType = leftType;
    result.rightType = rightType;
    result.resultType = leftType;
    result.resultIsRValue = true;
    result.leftMustBeLValue = false;
    result.rightMustBeLValue = false;
    if (token.kind == SyntaxKind_EqualsToken) {
        TypeConversionResult conversion = CanConvertTypeFromTo(rightType, leftType);
        if (conversion == TypeConversionResult_NonConvertible) {
            ReportError(TokenGetLocation(token), "Incompatible types for assignment '%s' = '%s'", TypeGetText(leftType).cstr, TypeGetText(rightType).cstr);
        }
        if (conversion == TypeConversionResult_ExplicitlyConvertible) {
            ReportError(TokenGetLocation(token), "Cannot implicitly convert types for assignment '%s' = '%s'", TypeGetText(leftType).cstr, TypeGetText(rightType).cstr);
        }
        result.operatorKind = ASTNodeKind_Assignment;
        result.leftMustBeLValue = true;
        return result;
    }
    if ((token.kind == SyntaxKind_PlusToken) && IsPointerType(leftType) && IsNumberType(rightType)) {
        result.operatorKind = ASTNodeKind_AddToPointer;
        result.resultIsRValue = false;
        result.leftMustBeLValue = true;
        return result;
    }
    if ((token.kind == SyntaxKind_PlusEqualsToken) && IsPointerType(leftType) && IsNumberType(rightType)) {
        result.operatorKind = ASTNodeKind_AddToPointerAssignment;
        result.resultIsRValue = false;
        result.leftMustBeLValue = true;
        return result;
    }
    if ((token.kind == SyntaxKind_MinusToken) && IsPointerType(leftType) && IsNumberType(rightType)) {
        result.operatorKind = ASTNodeKind_SubtractFromPointer;
        result.resultIsRValue = false;
        result.leftMustBeLValue = true;
        return result;
    }
    if ((token.kind == SyntaxKind_MinusEqualsToken) && IsPointerType(leftType) && IsNumberType(rightType)) {
        result.operatorKind = ASTNodeKind_SubtractFromPointerAssignment;
        result.resultIsRValue = false;
        result.leftMustBeLValue = true;
        return result;
    }
    if ((token.kind == SyntaxKind_MinusToken) && IsPointerType(leftType) && IsPointerType(rightType) && leftType.baseIndirectionLevel == rightType.baseIndirectionLevel && (leftType.kind == rightType.kind)) {
        result.operatorKind = ASTNodeKind_DistanceBetweenPointers;
        result.leftMustBeLValue = true;
        result.rightMustBeLValue = true;
        result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveLong);
        return result;
    }
    if (token.kind == SyntaxKind_EqualsEqualsToken) {
        TypeConversionResult conversion = CanConvertTypeFromTo(leftType, rightType);
        if (conversion == TypeConversionResult_ImplictlyConvertible || conversion == TypeConversionResult_Identical) {
            result.operatorKind = ASTNodeKind_Equals;
            result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
            return result;
        }
    }
    if (token.kind == SyntaxKind_BangEqualsToken) {
        TypeConversionResult conversion = CanConvertTypeFromTo(leftType, rightType);
        if (conversion == TypeConversionResult_ImplictlyConvertible || conversion == TypeConversionResult_Identical) {
            result.operatorKind = ASTNodeKind_NotEquals;
            result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
            return result;
        }
    }
    if (leftType.kind == TypeKind_Enum && rightType.kind == TypeKind_Enum) {
        switch (token.kind) {
            case SyntaxKind_EqualsEqualsToken: {
                result.operatorKind = ASTNodeKind_Equals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case SyntaxKind_BangEqualsToken: {
                result.operatorKind = ASTNodeKind_NotEquals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case SyntaxKind_LessToken: {
                result.operatorKind = ASTNodeKind_Less;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case SyntaxKind_LessEqualsToken: {
                result.operatorKind = ASTNodeKind_LessEquals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case SyntaxKind_GreaterToken: {
                result.operatorKind = ASTNodeKind_Greater;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case SyntaxKind_GreaterEqualsToken: {
                result.operatorKind = ASTNodeKind_GreaterEquals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
        }
    }
    if (token.kind == SyntaxKind_AmpersandAmpersandToken && !IsVoidType(leftType) && !IsVoidType(rightType)) {
        result.operatorKind = ASTNodeKind_LogicalAnd;
        return result;
    }
    if (token.kind == SyntaxKind_PipePipeToken && !IsVoidType(leftType) && !IsVoidType(rightType)) {
        result.operatorKind = ASTNodeKind_LogicalOr;
        return result;
    }
    if (IsNumberType(leftType) && IsNumberType(rightType) || IsCharType(leftType) && IsCharType(rightType)) {
        switch (token.kind) {
            case SyntaxKind_PlusToken: {
                result.operatorKind = ASTNodeKind_Add;
                return result;
            }
            case SyntaxKind_PlusEqualsToken: {
                result.operatorKind = ASTNodeKind_AddAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case SyntaxKind_MinusToken: {
                result.operatorKind = ASTNodeKind_Subtract;
                return result;
            }
            case SyntaxKind_MinusEqualsToken: {
                result.operatorKind = ASTNodeKind_SubtractAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case SyntaxKind_StarToken: {
                result.operatorKind = ASTNodeKind_Multiply;
                return result;
            }
            case SyntaxKind_StarEqualsToken: {
                result.operatorKind = ASTNodeKind_MultiplyAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case SyntaxKind_SlashToken: {
                result.operatorKind = ASTNodeKind_Divide;
                return result;
            }
            case SyntaxKind_SlashEqualsToken: {
                result.operatorKind = ASTNodeKind_DivideAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case SyntaxKind_PercentToken: {
                result.operatorKind = ASTNodeKind_Remainder;
                return result;
            }
            case SyntaxKind_PercentEqualsToken: {
                result.operatorKind = ASTNodeKind_RemainderAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case SyntaxKind_LessLessToken: {
                result.operatorKind = ASTNodeKind_BitshiftLeft;
                return result;
            }
            case SyntaxKind_LessLessEqualsToken: {
                result.operatorKind = ASTNodeKind_BitshiftLeftAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case SyntaxKind_GreaterGreaterToken: {
                result.operatorKind = ASTNodeKind_BitshiftRight;
                return result;
            }
            case SyntaxKind_GreaterGreaterEqualsToken: {
                result.operatorKind = ASTNodeKind_BitshiftRightAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case SyntaxKind_HatToken: {
                result.operatorKind = ASTNodeKind_BitwiseXor;
                return result;
            }
            case SyntaxKind_HatEqualsToken: {
                result.operatorKind = ASTNodeKind_BitwiseXorAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case SyntaxKind_AmpersandToken: {
                result.operatorKind = ASTNodeKind_BitwiseAnd;
                return result;
            }
            case SyntaxKind_AmpersandEqualsToken: {
                result.operatorKind = ASTNodeKind_BitwiseAndAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case SyntaxKind_PipeToken: {
                result.operatorKind = ASTNodeKind_BitwiseOr;
                return result;
            }
            case SyntaxKind_PipeEqualsToken: {
                result.operatorKind = ASTNodeKind_BitwiseOrAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case SyntaxKind_EqualsEqualsToken: {
                result.operatorKind = ASTNodeKind_Equals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case SyntaxKind_BangEqualsToken: {
                result.operatorKind = ASTNodeKind_NotEquals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case SyntaxKind_LessToken: {
                result.operatorKind = ASTNodeKind_Less;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case SyntaxKind_LessEqualsToken: {
                result.operatorKind = ASTNodeKind_LessEquals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case SyntaxKind_GreaterToken: {
                result.operatorKind = ASTNodeKind_Greater;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case SyntaxKind_GreaterEqualsToken: {
                result.operatorKind = ASTNodeKind_GreaterEquals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
        }
    }
    ReportError(TokenGetLocation(token), "No applicable binary operation for combination token '%s', left type '%s', right type '%s'", TokenKindToString(token.kind).cstr, TypeGetText(leftType).cstr, TypeGetText(rightType).cstr);
    exit(1);
}

static bool AreLiteralsEqual(ASTNode* a, ASTNode* b) {
    if (a->kind == ASTNodeKind_EnumValueLiteral) {
        assert(b->kind == ASTNodeKind_EnumValueLiteral);
        Symbol* aSym = a->symbol;
        Symbol* bSym = b->symbol;
        assert(a != NULL);
        assert(b != NULL);
        return StringEquals(aSym->name, bSym->name);
    } else {
        if (a->kind == ASTNodeKind_StringLiteral) {
            assert(b->kind == ASTNodeKind_StringLiteral);
            return StringEquals(a->stringvalue, b->stringvalue);
        } else {
            if (a->kind == ASTNodeKind_IntegerLiteral) {
                assert(b->kind == ASTNodeKind_IntegerLiteral);
                return a->intvalue == b->intvalue;
            } else {
                if (a->kind == ASTNodeKind_CharacterLiteral) {
                    assert(b->kind == ASTNodeKind_CharacterLiteral);
                    return a->intvalue == b->intvalue;
                } else {
                    assert(false && "Unexpected literal type");
                }
            }
        }
    }
    return false;
}

static bool IsWhiteSpace(char ch) {
    return (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n' || ch == '\f');
}

static bool IsDigit(char ch) {
    return '0' <= ch && ch <= '9';
}

static char ToLower(char ch) {
    if ('A' <= ch && ch <= 'Z') {
        return ch + ('a' - 'A');
    } else {
        return ch;
    }
}

static char ToUpper(char ch) {
    if ('a' <= ch && ch <= 'z') {
        return ch - ('a' - 'A');
    } else {
        return ch;
    }
}

static bool IsAlpha(char ch) {
    return ToLower(ch) != ToUpper(ch);
}

struct Scanner; typedef struct Scanner Scanner; struct Scanner {
    SyntaxTree* tree;
    Source source;
    int32 start;
    int32 pos;
    SyntaxToken token;
    char debugCharPrev;
    char debugCharCur;
    char debugCharNext;
    char debugCharNextNext;
};

static Scanner ScannerCreate(SyntaxTree* tree) {
    Scanner result;
    result.tree = tree;
    result.source = tree->source;
    result.start = 0;
    result.pos = 0;
    result.token = SyntaxTokenCreateEmpty(tree);
    result.debugCharPrev = '\0';
    result.debugCharCur = '\0';
    result.debugCharNext = '\0';
    result.debugCharNextNext = '\0';
    return result;
}

static char PeekChar(Scanner* scanner, int32 offset) {
    int32 index = scanner->pos + offset;
    return SourceGetCharAtIndex(scanner->source, index);
}

static char CurrentChar(Scanner* scanner) {
    return PeekChar(scanner, 0);
}

static char Lookahead(Scanner* scanner) {
    return PeekChar(scanner, 1);
}

static char AdvanceChar(Scanner* scanner) {
    char result = CurrentChar(scanner);
    scanner->pos += 1;
    scanner->debugCharPrev = scanner->debugCharCur;
    scanner->debugCharCur = result;
    scanner->debugCharNext = PeekChar(scanner, 1);
    scanner->debugCharNextNext = PeekChar(scanner, 2);
    return result;
}

static void ReadLineBreak(Scanner* scanner) {
    scanner->token.kind = SyntaxKind_LineBreakTrivia;
    if (CurrentChar(scanner) == '\r' && Lookahead(scanner) == '\n') {
        AdvanceChar(scanner);
        AdvanceChar(scanner);
    } else {
        AdvanceChar(scanner);
    }
}

static void ReadWhiteSpace(Scanner* scanner) {
    scanner->token.kind = SyntaxKind_WhitespaceTrivia;
    while (true) {
        switch (CurrentChar(scanner)) {
            case '\0': // Fallthrough
            case '\r': // Fallthrough
            case '\n': {
                return;
            }
            default: {
                if (!IsWhiteSpace(CurrentChar(scanner))) {
                    return;
                } else {
                    AdvanceChar(scanner);
                }
            }
        }
    }
}

static void ReadSingleLineComment(Scanner* scanner) {
    scanner->token.kind = SyntaxKind_SingleLineCommentTrivia;
    AdvanceChar(scanner);
    AdvanceChar(scanner);
    while (true) {
        switch (CurrentChar(scanner)) {
            case '\0': // Fallthrough
            case '\r': // Fallthrough
            case '\n': {
                return;
            }
            default: {
                AdvanceChar(scanner);
            }
        }
    }
}

static void ReadMultiLineComment(Scanner* scanner) {
    scanner->token.kind = SyntaxKind_MultiLineCommentTrivia;
    AdvanceChar(scanner);
    AdvanceChar(scanner);
    while (true) {
        switch (CurrentChar(scanner)) {
            case '\0': {
                SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->pos);
                ReportError(location, "Unterminated multiline comment");
                return;
            }
            case '*': {
                AdvanceChar(scanner);
                if (CurrentChar(scanner) == '/') {
                    AdvanceChar(scanner);
                    return;
                }
                break;
            }
            default: {
                AdvanceChar(scanner);
                break;
            }
        }
    }
}

static SyntaxTriviaArray ReadTrivia(Scanner* scanner, bool isLeading) {
    SyntaxTriviaArray result = SyntaxTriviaArrayCreate();
    bool done = false;
    while (!done) {
        scanner->start = scanner->pos;
        scanner->token = SyntaxTokenCreateEmpty(scanner->tree);
        switch (CurrentChar(scanner)) {
            case '\0': {
                done = true;
                break;
            }
            case '/': {
                if (Lookahead(scanner) == '/') {
                    ReadSingleLineComment(scanner);
                } else {
                    if (Lookahead(scanner) == '*') {
                        ReadMultiLineComment(scanner);
                    } else {
                        done = true;
                    }
                }
                break;
            }
            case '\n': // Fallthrough
            case '\r': {
                if (!isLeading) {
                    done = true;
                }
                ReadLineBreak(scanner);
                break;
            }
            case ' ': // Fallthrough
            case '\t': {
                ReadWhiteSpace(scanner);
                break;
            }
            default: {
                if (IsWhiteSpace(CurrentChar(scanner))) {
                    ReadWhiteSpace(scanner);
                } else {
                    done = true;
                }
                break;
            }
        }
        if (scanner->pos > scanner->start) {
            SourceLocation2 location = SourceLocation2Create(scanner->source, scanner->start, scanner->pos);
            SyntaxTrivia trivia = SyntaxTriviaCreate(scanner->token.kind, location);
            SyntaxTriviaArrayPush(&result, trivia);
        }
    }
    return result;
}

static int64 ReadPositiveIntegerLiteralWithRadix(Scanner* scanner, int32 radix) {
    if (FindCharPosInString(StringCreateFromCStr("0123456789ABCDEF"), ToUpper(CurrentChar(scanner))) == -1) {
        SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->pos);
        ReportError(location, "Unexpected character in integer literal '%c'", CurrentChar(scanner));
    }
    int64 result = 0;
    int32 digit;
    while (true) {
        digit = FindCharPosInString(StringCreateFromCStr("0123456789ABCDEF"), ToUpper(CurrentChar(scanner)));
        if (digit == -1) {
            break;
        }
        if (digit >= radix) {
            SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->pos);
            ReportError(location, "Invalid digit in integer literal '%c'", CurrentChar(scanner));
        }
        result = result * radix + digit;
        AdvanceChar(scanner);
    }
    return result;
}

static void ReadIntegerLiteral(Scanner* scanner) {
    bool isNegative = false;
    if (CurrentChar(scanner) == '-') {
        isNegative = true;
        AdvanceChar(scanner);
    }
    int32 radix = 10;
    if (CurrentChar(scanner) == '0' && Lookahead(scanner) == 'x') {
        radix = 16;
        AdvanceChar(scanner);
        AdvanceChar(scanner);
    }
    int64 intvalue = ReadPositiveIntegerLiteralWithRadix(scanner, radix);
    scanner->token.kind = SyntaxKind_IntegerLiteralToken;
    scanner->token.intvalueIsHex = radix == 16;
    scanner->token.intvalue = isNegative ? -intvalue : intvalue;
}

static char ReadCharWithEscapeSequence(Scanner* scanner) {
    char ch = AdvanceChar(scanner);
    if (ch == '\\') {
        char escape = AdvanceChar(scanner);
        switch (escape) {
            case 'a': {
                return '\a';
            }
            case 'b': {
                return '\b';
            }
            case 'f': {
                return '\f';
            }
            case 'n': {
                return '\n';
            }
            case 'r': {
                return '\r';
            }
            case 't': {
                return '\t';
            }
            case 'v': {
                return '\v';
            }
            case '\\': {
                return '\\';
            }
            case '"': {
                return '"';
            }
            case '\'': {
                return '\'';
            }
            case '0': {
                return '0';
            }
            case 'x': {
                int64 number = ReadPositiveIntegerLiteralWithRadix(scanner, 16);
                if (number > UCHAR_MAX) {
                    SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->pos);
                    ReportError(location, "Hexadecimal character literal cannot be bigger than '\\xFF'");
                }
                return (char)number;
            }
            default: {
                SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->pos);
                ReportError(location, "Unknown escape sequence '\\%c'", escape);
            }
        }
    }
    return ch;
}

static void ReadCharacterLiteral(Scanner* scanner) {
    char openingQuote = AdvanceChar(scanner);
    int32 start = scanner->pos;
    char ch = ReadCharWithEscapeSequence(scanner);
    int32 end = scanner->pos;
    char closingQuote = AdvanceChar(scanner);
    if (closingQuote != '\'') {
        SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->start);
        ReportError(location, "Expected closing quote \"'\" character after character literal but got '%c'", closingQuote);
    }
    scanner->token.kind = SyntaxKind_CharacterLiteralToken;
    scanner->token.stringValueWithoutQuotes = SourceGetSubstring(scanner->source, start, end);
    scanner->token.intvalue = (int64)ch;
}

static void ReadStringLiteral(Scanner* scanner) {
    char openingQuote = AdvanceChar(scanner);
    int32 start = scanner->pos;
    while (CurrentChar(scanner) != '\0' && CurrentChar(scanner) != '\n') {
        char ch = CurrentChar(scanner);
        if (ch == '\\' && Lookahead(scanner) == '"') {
            AdvanceChar(scanner);
            AdvanceChar(scanner);
            continue;
        }
        if (ch == '"') {
            break;
        }
        AdvanceChar(scanner);
    }
    int32 end = scanner->pos;
    char closingQuote = AdvanceChar(scanner);
    if (closingQuote != '\"') {
        SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->start);
        ReportError(location, "Unterminated string literal");
    }
    scanner->token.kind = SyntaxKind_StringLiteralToken;
    scanner->token.stringValueWithoutQuotes = SourceGetSubstring(scanner->source, start, end);
}

static void ReadPreprocessorDirective(Scanner* scanner) {
    assert(CurrentChar(scanner) == '#');
    AdvanceChar(scanner);
    while (IsAlpha(CurrentChar(scanner)) || (CurrentChar(scanner) == '_')) {
        AdvanceChar(scanner);
    }
    String identifier = SourceGetSubstring(scanner->source, scanner->start, scanner->pos);
    SyntaxKind keywordKind = GetKeywordForIdentifier(identifier);
    if (keywordKind != SyntaxKind_EndOfFileToken) {
        scanner->token.kind = keywordKind;
    } else {
        SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->start);
        ReportError(location, "Unknown preprocesser directive '%s'", identifier.cstr);
    }
}

static void ReadIdentifierOrKeyword(Scanner* scanner) {
    while (IsAlpha(CurrentChar(scanner)) || IsDigit(CurrentChar(scanner)) || (CurrentChar(scanner) == '_')) {
        AdvanceChar(scanner);
    }
    String identifier = SourceGetSubstring(scanner->source, scanner->start, scanner->pos);
    SyntaxKind keywordKind = GetKeywordForIdentifier(identifier);
    if (keywordKind != SyntaxKind_EndOfFileToken) {
        scanner->token.kind = keywordKind;
    } else {
        scanner->token.kind = SyntaxKind_IdentifierToken;
    }
}

static SyntaxToken ReadToken(Scanner* scanner) {
    scanner->start = scanner->pos;
    scanner->token = SyntaxTokenCreateEmpty(scanner->tree);
    char ch = CurrentChar(scanner);
    switch (ch) {
        case '\0': {
            scanner->token.kind = SyntaxKind_EndOfFileToken;
            break;
        }
        case '+': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = SyntaxKind_PlusEqualsToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = SyntaxKind_PlusToken;
                AdvanceChar(scanner);
            }
            break;
        }
        case '-': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = SyntaxKind_MinusEqualsToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                if (Lookahead(scanner) == '>') {
                    scanner->token.kind = SyntaxKind_ArrowToken;
                    AdvanceChar(scanner);
                    AdvanceChar(scanner);
                } else {
                    if (IsDigit(Lookahead(scanner))) {
                        ReadIntegerLiteral(scanner);
                    } else {
                        scanner->token.kind = SyntaxKind_MinusToken;
                        AdvanceChar(scanner);
                    }
                }
            }
            break;
        }
        case '*': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = SyntaxKind_StarEqualsToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = SyntaxKind_StarToken;
                AdvanceChar(scanner);
            }
            break;
        }
        case '/': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = SyntaxKind_SlashEqualsToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = SyntaxKind_SlashToken;
                AdvanceChar(scanner);
            }
            break;
        }
        case '%': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = SyntaxKind_PercentEqualsToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = SyntaxKind_PercentToken;
                AdvanceChar(scanner);
            }
            break;
        }
        case '.': {
            if (PeekChar(scanner, 1) == '.' && PeekChar(scanner, 2)) {
                scanner->token.kind = SyntaxKind_DotDotDotToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = SyntaxKind_DotToken;
                AdvanceChar(scanner);
            }
            break;
        }
        case ',': {
            scanner->token.kind = SyntaxKind_CommaToken;
            AdvanceChar(scanner);
            break;
        }
        case '?': {
            scanner->token.kind = SyntaxKind_QuestionmarkToken;
            AdvanceChar(scanner);
            break;
        }
        case ':': {
            if (Lookahead(scanner) == ':') {
                scanner->token.kind = SyntaxKind_ColonColonToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = SyntaxKind_ColonToken;
                AdvanceChar(scanner);
            }
            break;
        }
        case ';': {
            scanner->token.kind = SyntaxKind_SemicolonToken;
            AdvanceChar(scanner);
            break;
        }
        case '~': {
            scanner->token.kind = SyntaxKind_TildeToken;
            AdvanceChar(scanner);
            break;
        }
        case '^': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = SyntaxKind_HatEqualsToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = SyntaxKind_HatToken;
                AdvanceChar(scanner);
            }
            break;
        }
        case '&': {
            if (Lookahead(scanner) == '&') {
                scanner->token.kind = SyntaxKind_AmpersandAmpersandToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                if (Lookahead(scanner) == '=') {
                    scanner->token.kind = SyntaxKind_AmpersandEqualsToken;
                    AdvanceChar(scanner);
                    AdvanceChar(scanner);
                } else {
                    scanner->token.kind = SyntaxKind_AmpersandToken;
                    AdvanceChar(scanner);
                }
            }
            break;
        }
        case '|': {
            if (Lookahead(scanner) == '|') {
                scanner->token.kind = SyntaxKind_PipePipeToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                if (Lookahead(scanner) == '=') {
                    scanner->token.kind = SyntaxKind_PipeEqualsToken;
                    AdvanceChar(scanner);
                    AdvanceChar(scanner);
                } else {
                    scanner->token.kind = SyntaxKind_PipeToken;
                    AdvanceChar(scanner);
                }
            }
            break;
        }
        case '{': {
            scanner->token.kind = SyntaxKind_LeftBraceToken;
            AdvanceChar(scanner);
            break;
        }
        case '}': {
            scanner->token.kind = SyntaxKind_RightBraceToken;
            AdvanceChar(scanner);
            break;
        }
        case '(': {
            scanner->token.kind = SyntaxKind_LeftParenToken;
            AdvanceChar(scanner);
            break;
        }
        case ')': {
            scanner->token.kind = SyntaxKind_RightParenToken;
            AdvanceChar(scanner);
            break;
        }
        case '[': {
            scanner->token.kind = SyntaxKind_LeftBracketToken;
            AdvanceChar(scanner);
            break;
        }
        case ']': {
            scanner->token.kind = SyntaxKind_RightBracketToken;
            AdvanceChar(scanner);
            break;
        }
        case '=': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = SyntaxKind_EqualsEqualsToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = SyntaxKind_EqualsToken;
                AdvanceChar(scanner);
            }
            break;
        }
        case '!': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = SyntaxKind_BangEqualsToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                AdvanceChar(scanner);
                scanner->token.kind = SyntaxKind_BangToken;
            }
            break;
        }
        case '<': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = SyntaxKind_LessEqualsToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                if (Lookahead(scanner) == '<') {
                    scanner->token.kind = SyntaxKind_LessLessToken;
                    AdvanceChar(scanner);
                    AdvanceChar(scanner);
                    if (CurrentChar(scanner) == '=') {
                        scanner->token.kind = SyntaxKind_LessLessEqualsToken;
                        AdvanceChar(scanner);
                    }
                } else {
                    scanner->token.kind = SyntaxKind_LessToken;
                    AdvanceChar(scanner);
                }
            }
            break;
        }
        case '>': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = SyntaxKind_GreaterEqualsToken;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                if (Lookahead(scanner) == '>') {
                    scanner->token.kind = SyntaxKind_GreaterGreaterToken;
                    AdvanceChar(scanner);
                    AdvanceChar(scanner);
                    if (CurrentChar(scanner) == '=') {
                        scanner->token.kind = SyntaxKind_GreaterGreaterEqualsToken;
                        AdvanceChar(scanner);
                    }
                } else {
                    scanner->token.kind = SyntaxKind_GreaterToken;
                    AdvanceChar(scanner);
                }
            }
            break;
        }
        default: {
            if (IsDigit(ch)) {
                ReadIntegerLiteral(scanner);
                break;
            } else {
                if (IsAlpha(ch) || (ch == '_')) {
                    ReadIdentifierOrKeyword(scanner);
                    break;
                } else {
                    if (ch == '#') {
                        ReadPreprocessorDirective(scanner);
                        break;
                    } else {
                        if (ch == '\'') {
                            ReadCharacterLiteral(scanner);
                            break;
                        } else {
                            if (ch == '"') {
                                ReadStringLiteral(scanner);
                                break;
                            }
                        }
                    }
                }
            }
            SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->start);
            ReportError(location, "Unexpected character '%c'", ch);
        }
    }
    scanner->token.location.start = scanner->start;
    scanner->token.location.end = scanner->pos;
    scanner->token.debugString = SourceGetSubstring(scanner->source, scanner->start, scanner->pos);
    if (0) {
        fprintf(stdout, "Token %s", TokenKindToString(scanner->token.kind).cstr);
        if (scanner->token.kind == SyntaxKind_IntegerLiteralToken) {
            fprintf(stdout, ", value '%lld'", scanner->token.intvalue);
        }
        if (scanner->token.kind == SyntaxKind_CharacterLiteralToken) {
            fprintf(stdout, ", value '%s'", scanner->token.stringValueWithoutQuotes.cstr);
        }
        if (scanner->token.kind == SyntaxKind_StringLiteralToken) {
            fprintf(stdout, ", value '%s'", scanner->token.stringValueWithoutQuotes.cstr);
        }
        if (scanner->token.kind == SyntaxKind_IdentifierToken) {
            fprintf(stdout, ", name '%s'", TokenGetText(scanner->token).cstr);
        }
        fprintf(stdout, "\n");
    }
    return scanner->token;
}

static SyntaxToken NextToken(Scanner* scanner) {
    SyntaxTriviaArray leadingTrivia = ReadTrivia(scanner, true);
    SyntaxToken result = ReadToken(scanner);
    SyntaxTriviaArray trailingTrivia = ReadTrivia(scanner, false);
    result.leadingTrivia = leadingTrivia;
    result.trailingTrivia = trailingTrivia;
    return result;
}

struct Parser; typedef struct Parser Parser; struct Parser {
    Scanner scanner;
    SyntaxTree* tree;
    SyntaxToken tokenPrev;
    SyntaxToken tokenCur;
    SyntaxToken tokenNext;
    SyntaxToken tokenNextAfter;
    int32 loopLevel;
    int32 switchCaseLevel;
    int32 functionLevel;
};

static Parser ParserCreate(Source source) {
    SyntaxTree* tree = (SyntaxTree*)malloc(sizeof(SyntaxTree));
    tree->source = source;
    tree->moduleRoot = NULL;
    Parser result;
    result.tree = tree;
    result.scanner = ScannerCreate(tree);
    result.tokenPrev = SyntaxTokenCreateEmpty(tree);
    result.tokenCur = NextToken(&result.scanner);
    result.tokenNext = NextToken(&result.scanner);
    result.tokenNextAfter = NextToken(&result.scanner);
    result.loopLevel = 0;
    result.switchCaseLevel = 0;
    result.functionLevel = 0;
    return result;
}

static SyntaxToken AdvanceToken(Parser* parser) {
    SyntaxToken result = parser->tokenCur;
    parser->tokenPrev = parser->tokenCur;
    parser->tokenCur = parser->tokenNext;
    parser->tokenNext = parser->tokenNextAfter;
    parser->tokenNextAfter = NextToken(&parser->scanner);
    return result;
}

static SyntaxToken MatchAndAdvanceToken(Parser* parser, SyntaxKind kind) {
    if (kind == parser->tokenCur.kind) {
        return AdvanceToken(parser);
    }
    ReportError(TokenGetLocation(parser->tokenCur), "Expected token '%s' but got token '%s'", TokenKindToString(kind).cstr, TokenKindToString(parser->tokenCur.kind).cstr);
    exit(1);
}

static SyntaxNode* WrapTokenInNode(Parser* parser, SyntaxToken token) {
    SyntaxNode* wrapper = SyntaxNodeCreate(token.kind, parser->tree);
    wrapper->token = token;
    return wrapper;
}

SyntaxNode* ParseStatement(Parser* parser);

SyntaxNode* ParseExpression(Parser* parser);

SyntaxNode* ParseBinaryExpression(Parser* parser, int32 parentPrecedence);

SyntaxNode* ParseUnaryExpression(Parser* parser, int32 parentPrecedence);

static SyntaxNode* ParseTypeExpression(Parser* parser) {
    switch (parser->tokenCur.kind) {
        case SyntaxKind_VoidKeyword: // Fallthrough
        case SyntaxKind_CharKeyword: // Fallthrough
        case SyntaxKind_BoolKeyword: // Fallthrough
        case SyntaxKind_ByteKeyword: // Fallthrough
        case SyntaxKind_ShortKeyword: // Fallthrough
        case SyntaxKind_IntKeyword: // Fallthrough
        case SyntaxKind_LongKeyword: // Fallthrough
        case SyntaxKind_CStringKeyword: // Fallthrough
        case SyntaxKind_IdentifierToken: {
            break;
        }
        default: {
            ReportError(TokenGetLocation(parser->tokenCur), "Expected primitive type or identifier token - got token '%s'", TokenGetText(parser->tokenCur).cstr);
        }
    }
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_TypeExpression, parser->tree);
    result->typeExpr.typeTokens = SyntaxNodeArrayCreate();
    SyntaxToken identifier = AdvanceToken(parser);
    SyntaxNode* identifierWrapper = WrapTokenInNode(parser, identifier);
    SyntaxNodeArrayPush(&result->typeExpr.typeTokens, identifierWrapper);
    while (parser->tokenCur.kind == SyntaxKind_StarToken) {
        SyntaxToken star = AdvanceToken(parser);
        SyntaxNode* starWrapper = WrapTokenInNode(parser, star);
        SyntaxNodeArrayPush(&result->typeExpr.typeTokens, starWrapper);
    }
    return result;
}

static SyntaxNode* ParseFunctionCallExpression(Parser* parser, SyntaxNode* func) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_FuncCallExpression, parser->tree);
    result->funcCallExpr.func = func;
    result->funcCallExpr.leftParen = MatchAndAdvanceToken(parser, SyntaxKind_LeftParenToken);
    result->funcCallExpr.argumentsWithSeparators = SyntaxNodeArrayCreate();
    while (parser->tokenCur.kind != SyntaxKind_RightParenToken) {
        SyntaxNode* argument = ParseExpression(parser);
        SyntaxNodeArrayPush(&result->funcCallExpr.argumentsWithSeparators, argument);
        if (parser->tokenCur.kind == SyntaxKind_CommaToken) {
            SyntaxToken comma = MatchAndAdvanceToken(parser, SyntaxKind_CommaToken);
            SyntaxNode* commaWrapper = WrapTokenInNode(parser, comma);
            SyntaxNodeArrayPush(&result->funcCallExpr.argumentsWithSeparators, commaWrapper);
        } else {
            break;
        }
    }
    result->funcCallExpr.rightParen = MatchAndAdvanceToken(parser, SyntaxKind_RightParenToken);
    return result;
}

static SyntaxNode* ParseArrayIndexingExpression(Parser* parser, SyntaxNode* arr) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_ArrayIndexExpression, parser->tree);
    result->arrayIndexExpr.arr = arr;
    result->arrayIndexExpr.leftBracket = MatchAndAdvanceToken(parser, SyntaxKind_LeftBracketToken);
    result->arrayIndexExpr.indexExpression = ParseExpression(parser);
    result->arrayIndexExpr.rightBracket = MatchAndAdvanceToken(parser, SyntaxKind_RightBracketToken);
    return result;
}

static SyntaxNode* ParseMemberAccess(Parser* parser, SyntaxNode* container) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_MemberAccessExpression, parser->tree);
    result->memberAccessExpr.container = container;
    if (parser->tokenCur.kind == SyntaxKind_ArrowToken) {
        result->memberAccessExpr.accessToken = MatchAndAdvanceToken(parser, SyntaxKind_ArrowToken);
    } else {
        result->memberAccessExpr.accessToken = MatchAndAdvanceToken(parser, SyntaxKind_DotToken);
    }
    result->memberAccessExpr.memberIdentifier = MatchAndAdvanceToken(parser, SyntaxKind_IdentifierToken);
    return result;
}

static SyntaxNode* ParseEnumLiteralExpression(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_EnumValueLiteralExpression, parser->tree);
    result->enumLiteralExpr.enumIdentifier = MatchAndAdvanceToken(parser, SyntaxKind_IdentifierToken);
    result->enumLiteralExpr.coloncolon = MatchAndAdvanceToken(parser, SyntaxKind_ColonColonToken);
    result->enumLiteralExpr.valueIdentifier = MatchAndAdvanceToken(parser, SyntaxKind_IdentifierToken);
    return result;
}

static SyntaxNode* ParsePrimaryExpression(Parser* parser) {
    switch (parser->tokenCur.kind) {
        case SyntaxKind_LeftParenToken: {
            SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_ParenthesizedExpression, parser->tree);
            result->parenthesizedExpr.leftParen = MatchAndAdvanceToken(parser, SyntaxKind_LeftParenToken);
            result->parenthesizedExpr.expression = ParseExpression(parser);
            result->parenthesizedExpr.rightParen = MatchAndAdvanceToken(parser, SyntaxKind_RightParenToken);
            return result;
        }
        case SyntaxKind_SizeOfKeyword: {
            SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_SizeOfExpression, parser->tree);
            result->sizeofExpr.sizeofKeyword = MatchAndAdvanceToken(parser, SyntaxKind_SizeOfKeyword);
            result->sizeofExpr.leftParen = MatchAndAdvanceToken(parser, SyntaxKind_LeftParenToken);
            result->sizeofExpr.typeExpression = ParseTypeExpression(parser);
            result->sizeofExpr.rightParen = MatchAndAdvanceToken(parser, SyntaxKind_RightParenToken);
            return result;
        }
        case SyntaxKind_IdentifierToken: {
            if (parser->tokenNext.kind == SyntaxKind_ColonColonToken) {
                return ParseEnumLiteralExpression(parser);
            }
            SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_NameExpression, parser->tree);
            result->nameExpr.identifier = MatchAndAdvanceToken(parser, SyntaxKind_IdentifierToken);
            return result;
        }
        case SyntaxKind_StringLiteralToken: {
            SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_StringLiteralExpression, parser->tree);
            result->stringLiteralExpr.stringLiteralTokens = SyntaxNodeArrayCreate();
            while (parser->tokenCur.kind == SyntaxKind_StringLiteralToken) {
                SyntaxToken literal = MatchAndAdvanceToken(parser, SyntaxKind_StringLiteralToken);
                SyntaxNode* literalWrapper = WrapTokenInNode(parser, literal);
                SyntaxNodeArrayPush(&result->stringLiteralExpr.stringLiteralTokens, literalWrapper);
            }
            return result;
        }
        case SyntaxKind_NullKeyword: {
            SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_NullLiteralExpression, parser->tree);
            result->nullLiteralExpr.nullLiteral = MatchAndAdvanceToken(parser, SyntaxKind_NullKeyword);
            return result;
        }
        case SyntaxKind_CharacterLiteralToken: {
            SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_CharacterLiteralExpression, parser->tree);
            result->characterLiteralExpr.characterLiteral = MatchAndAdvanceToken(parser, SyntaxKind_CharacterLiteralToken);
            return result;
        }
        case SyntaxKind_FalseKeyword: // Fallthrough
        case SyntaxKind_TrueKeyword: {
            SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_BoolLiteralExpression, parser->tree);
            result->boolLiteralExpr.boolLiteral = AdvanceToken(parser);
            return result;
        }
        case SyntaxKind_IntegerLiteralToken: // Fallthrough
        default: {
            SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_IntegerLiteralExpression, parser->tree);
            result->integerLiteralExpr.integerLiteral = MatchAndAdvanceToken(parser, SyntaxKind_IntegerLiteralToken);
            return result;
        }
    }
}

static SyntaxNode* ParseArrayLiteralExpression(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_ArrayLiteralExpression, parser->tree);
    result->arrayLiteralExpr.leftBrace = MatchAndAdvanceToken(parser, SyntaxKind_LeftBraceToken);
    result->arrayLiteralExpr.elemsWithSeparators = SyntaxNodeArrayCreate();
    while (parser->tokenCur.kind != SyntaxKind_RightBraceToken) {
        SyntaxNode* expression = ParseExpression(parser);
        SyntaxNodeArrayPush(&result->arrayLiteralExpr.elemsWithSeparators, expression);
        if (parser->tokenCur.kind == SyntaxKind_CommaToken) {
            SyntaxToken comma = MatchAndAdvanceToken(parser, SyntaxKind_CommaToken);
            SyntaxNode* commaWrapper = WrapTokenInNode(parser, comma);
            SyntaxNodeArrayPush(&result->arrayLiteralExpr.elemsWithSeparators, commaWrapper);
        } else {
            break;
        }
    }
    result->arrayLiteralExpr.rightBrace = MatchAndAdvanceToken(parser, SyntaxKind_RightBraceToken);
    return result;
}

static SyntaxNode* ParsePostFixExpression(Parser* parser) {
    SyntaxNode* left = ParsePrimaryExpression(parser);
    bool foundPostfix = false;
    do {
        foundPostfix = false;
        if (parser->tokenCur.kind == SyntaxKind_LeftParenToken) {
            foundPostfix = true;
            left = ParseFunctionCallExpression(parser, left);
        }
        if (parser->tokenCur.kind == SyntaxKind_DotToken || parser->tokenCur.kind == SyntaxKind_ArrowToken) {
            foundPostfix = true;
            left = ParseMemberAccess(parser, left);
        }
        if (parser->tokenCur.kind == SyntaxKind_LeftBracketToken) {
            foundPostfix = true;
            left = ParseArrayIndexingExpression(parser, left);
        }
    } while (foundPostfix);
    return left;
}

static SyntaxNode* ParseCastExpression(Parser* parser) {
    if (parser->tokenCur.kind != SyntaxKind_LeftParenToken || parser->tokenNext.kind != SyntaxKind_AsKeyword) {
        return ParsePostFixExpression(parser);
    }
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_TypeCastExpression, parser->tree);
    result->typeCastExpr.leftParen = MatchAndAdvanceToken(parser, SyntaxKind_LeftParenToken);
    result->typeCastExpr.asKeyword = MatchAndAdvanceToken(parser, SyntaxKind_AsKeyword);
    result->typeCastExpr.targetTypeExpression = ParseTypeExpression(parser);
    result->typeCastExpr.rightParen = MatchAndAdvanceToken(parser, SyntaxKind_RightParenToken);
    result->typeCastExpr.expression = ParseUnaryExpression(parser, 0);
    return result;
}

static SyntaxNode* ParseUnaryExpression(Parser* parser, int32 parentPrecedence) {
    SyntaxNode* left = NULL;
    int32 unaryOperatorPrecedence = GetUnaryOperatorPrecedence(parser->tokenCur.kind);
    if ((unaryOperatorPrecedence != 0) && (unaryOperatorPrecedence >= parentPrecedence)) {
        SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_UnaryExpression, parser->tree);
        result->unaryExpr.operatorToken = AdvanceToken(parser);
        result->unaryExpr.operand = ParseBinaryExpression(parser, unaryOperatorPrecedence);
        left = result;
    } else {
        left = ParseCastExpression(parser);
    }
    return left;
}

static SyntaxNode* ParseBinaryExpression(Parser* parser, int32 parentPrecedence) {
    SyntaxNode* left = ParseUnaryExpression(parser, parentPrecedence);
    while (true) {
        int32 precedence = GetBinaryOperatorPrecedence(parser->tokenCur.kind);
        if (precedence == 0 || precedence < parentPrecedence || precedence == parentPrecedence && !IsBinaryOperatorRightAssociative(parser->tokenCur.kind)) {
            break;
        }
        SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_BinaryExpression, parser->tree);
        result->binaryExpr.left = left;
        result->binaryExpr.operatorToken = AdvanceToken(parser);
        result->binaryExpr.right = ParseBinaryExpression(parser, precedence);
        left = result;
    }
    return left;
}

static SyntaxNode* ParseTernaryConditionExpression(Parser* parser) {
    SyntaxNode* left = ParseBinaryExpression(parser, 0);
    if (parser->tokenCur.kind == SyntaxKind_QuestionmarkToken) {
        SyntaxNode* ternary = SyntaxNodeCreate(SyntaxKind_TernaryConditionalExpression, parser->tree);
        ternary->ternaryConditionalExpr.conditionExpression = left;
        ternary->ternaryConditionalExpr.questionmark = MatchAndAdvanceToken(parser, SyntaxKind_QuestionmarkToken);
        ternary->ternaryConditionalExpr.thenExpression = ParseTernaryConditionExpression(parser);
        ternary->ternaryConditionalExpr.colon = MatchAndAdvanceToken(parser, SyntaxKind_ColonToken);
        ternary->ternaryConditionalExpr.elseExpression = ParseTernaryConditionExpression(parser);
        return ternary;
    }
    return left;
}

static SyntaxNode* ParseAssignmentExpression(Parser* parser) {
    SyntaxNode* left = ParseTernaryConditionExpression(parser);
    switch (parser->tokenCur.kind) {
        case SyntaxKind_EqualsToken: // Fallthrough
        case SyntaxKind_PlusEqualsToken: // Fallthrough
        case SyntaxKind_MinusEqualsToken: // Fallthrough
        case SyntaxKind_StarEqualsToken: // Fallthrough
        case SyntaxKind_SlashEqualsToken: // Fallthrough
        case SyntaxKind_PercentEqualsToken: // Fallthrough
        case SyntaxKind_HatEqualsToken: // Fallthrough
        case SyntaxKind_AmpersandEqualsToken: // Fallthrough
        case SyntaxKind_PipeEqualsToken: // Fallthrough
        case SyntaxKind_LessLessEqualsToken: // Fallthrough
        case SyntaxKind_GreaterGreaterEqualsToken: {
            SyntaxNode* assignment = SyntaxNodeCreate(SyntaxKind_BinaryExpression, parser->tree);
            assignment->binaryExpr.left = left;
            assignment->binaryExpr.operatorToken = AdvanceToken(parser);
            assignment->binaryExpr.right = ParseAssignmentExpression(parser);
            return assignment;
        }
    }
    return left;
}

static SyntaxNode* ParseExpression(Parser* parser) {
    return ParseAssignmentExpression(parser);
}

static SyntaxNode* ParseExpressionStatement(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_ExpressionStatement, parser->tree);
    result->expressionStmt.expression = ParseExpression(parser);
    result->expressionStmt.semicolon = MatchAndAdvanceToken(parser, SyntaxKind_SemicolonToken);
    return result;
}

static SyntaxNode* ParseVariableDefinitionStatement(Parser* parser, bool skipLet, bool allowInitializer, SyntaxKind terminator) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_VariableDeclarationStatement, parser->tree);
    if (skipLet) {
        result->variableDeclarationStmt.letKeyword = SyntaxTokenCreateEmpty(parser->tree);
    } else {
        if (parser->tokenCur.kind == SyntaxKind_LetLocalPersistKeyword) {
            result->variableDeclarationStmt.letKeyword = MatchAndAdvanceToken(parser, SyntaxKind_LetLocalPersistKeyword);
        } else {
            result->variableDeclarationStmt.letKeyword = MatchAndAdvanceToken(parser, SyntaxKind_LetKeyword);
        }
    }
    result->variableDeclarationStmt.typeExpression = ParseTypeExpression(parser);
    result->variableDeclarationStmt.identifier = MatchAndAdvanceToken(parser, SyntaxKind_IdentifierToken);
    if (parser->tokenCur.kind == SyntaxKind_LeftBracketToken) {
        result->variableDeclarationStmt.leftBracket = MatchAndAdvanceToken(parser, SyntaxKind_LeftBracketToken);
        if (parser->tokenCur.kind == SyntaxKind_IntegerLiteralToken) {
            result->variableDeclarationStmt.arraySizeLiteral = MatchAndAdvanceToken(parser, SyntaxKind_IntegerLiteralToken);
        }
        result->variableDeclarationStmt.rightBracket = MatchAndAdvanceToken(parser, SyntaxKind_RightBracketToken);
        if (parser->tokenCur.kind == SyntaxKind_EqualsToken && allowInitializer) {
            result->variableDeclarationStmt.equalsToken = MatchAndAdvanceToken(parser, SyntaxKind_EqualsToken);
            result->variableDeclarationStmt.initializerExpression = ParseArrayLiteralExpression(parser);
        } else {
            result->variableDeclarationStmt.equalsToken = SyntaxTokenCreateEmpty(parser->tree);
            result->variableDeclarationStmt.initializerExpression = NULL;
        }
    } else {
        result->variableDeclarationStmt.leftBracket = SyntaxTokenCreateEmpty(parser->tree);
        result->variableDeclarationStmt.arraySizeLiteral = SyntaxTokenCreateEmpty(parser->tree);
        result->variableDeclarationStmt.rightBracket = SyntaxTokenCreateEmpty(parser->tree);
        if (parser->tokenCur.kind == SyntaxKind_EqualsToken && allowInitializer) {
            result->variableDeclarationStmt.equalsToken = MatchAndAdvanceToken(parser, SyntaxKind_EqualsToken);
            result->variableDeclarationStmt.initializerExpression = ParseExpression(parser);
        } else {
            result->variableDeclarationStmt.equalsToken = SyntaxTokenCreateEmpty(parser->tree);
            result->variableDeclarationStmt.initializerExpression = NULL;
        }
    }
    if (terminator == SyntaxKind_BadToken) {
        result->variableDeclarationStmt.terminatorToken = SyntaxTokenCreateEmpty(parser->tree);
    } else {
        result->variableDeclarationStmt.terminatorToken = MatchAndAdvanceToken(parser, terminator);
    }
    return result;
}

static SyntaxNode* ParseIfStatement(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_IfStatement, parser->tree);
    result->ifStmt.ifKeyword = MatchAndAdvanceToken(parser, SyntaxKind_IfKeyword);
    result->ifStmt.leftParen = MatchAndAdvanceToken(parser, SyntaxKind_LeftParenToken);
    result->ifStmt.condition = ParseExpression(parser);
    result->ifStmt.rightParen = MatchAndAdvanceToken(parser, SyntaxKind_RightParenToken);
    result->ifStmt.thenBlock = ParseStatement(parser);
    result->ifStmt.elseBlock = NULL;
    result->ifStmt.elseKeyword = SyntaxTokenCreateEmpty(parser->tree);
    if (parser->tokenCur.kind == SyntaxKind_ElseKeyword) {
        result->ifStmt.elseKeyword = MatchAndAdvanceToken(parser, SyntaxKind_ElseKeyword);
        result->ifStmt.elseBlock = ParseStatement(parser);
    }
    return result;
}

static SyntaxNode* ParseWhileStatement(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_WhileStatement, parser->tree);
    result->whileStmt.whileKeyword = MatchAndAdvanceToken(parser, SyntaxKind_WhileKeyword);
    result->whileStmt.leftParen = MatchAndAdvanceToken(parser, SyntaxKind_LeftParenToken);
    result->whileStmt.condition = ParseExpression(parser);
    result->whileStmt.rightParen = MatchAndAdvanceToken(parser, SyntaxKind_RightParenToken);
    parser->loopLevel += 1;
    result->whileStmt.body = ParseStatement(parser);
    parser->loopLevel -= 1;
    return result;
}

static SyntaxNode* ParseDoWhileStatement(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_DoWhileStatement, parser->tree);
    result->doWhileStmt.doKeyword = MatchAndAdvanceToken(parser, SyntaxKind_DoKeyword);
    parser->loopLevel += 1;
    result->doWhileStmt.body = ParseStatement(parser);
    parser->loopLevel -= 1;
    result->doWhileStmt.whileKeyword = MatchAndAdvanceToken(parser, SyntaxKind_WhileKeyword);
    result->doWhileStmt.leftParen = MatchAndAdvanceToken(parser, SyntaxKind_LeftParenToken);
    result->doWhileStmt.condition = ParseExpression(parser);
    result->doWhileStmt.rightParen = MatchAndAdvanceToken(parser, SyntaxKind_RightParenToken);
    result->doWhileStmt.semicolon = MatchAndAdvanceToken(parser, SyntaxKind_SemicolonToken);
    return result;
}

static SyntaxNode* ParseForStatement(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_ForStatement, parser->tree);
    result->forStmt.forKeyword = MatchAndAdvanceToken(parser, SyntaxKind_ForKeyword);
    result->forStmt.leftParen = MatchAndAdvanceToken(parser, SyntaxKind_LeftParenToken);
    if (parser->tokenCur.kind == SyntaxKind_LetKeyword) {
        result->forStmt.initializerStatement = ParseVariableDefinitionStatement(parser, false, true, SyntaxKind_SemicolonToken);
    } else {
        result->forStmt.initializerStatement = ParseExpressionStatement(parser);
    }
    result->forStmt.conditionStatement = ParseExpressionStatement(parser);
    result->forStmt.incrementExpression = ParseExpression(parser);
    result->forStmt.rightParen = MatchAndAdvanceToken(parser, SyntaxKind_RightParenToken);
    parser->loopLevel += 1;
    result->forStmt.body = ParseStatement(parser);
    parser->loopLevel -= 1;
    return result;
}

static SyntaxNode* ParseReturnStatement(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_ReturnStatement, parser->tree);
    result->returnStmt.returnKeyword = MatchAndAdvanceToken(parser, SyntaxKind_ReturnKeyword);
    if (parser->functionLevel == 0) {
        ReportError(TokenGetLocation(result->returnStmt.returnKeyword), "Invalid 'return' keyword found outside of function definition");
    }
    if (parser->tokenCur.kind != SyntaxKind_SemicolonToken) {
        result->returnStmt.returnExpression = ParseExpression(parser);
    } else {
        result->returnStmt.returnExpression = NULL;
    }
    result->returnStmt.semicolon = MatchAndAdvanceToken(parser, SyntaxKind_SemicolonToken);
    return result;
}

static SyntaxNode* ParseBreakStatement(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_BreakStatement, parser->tree);
    result->breakStmt.breakKeyword = MatchAndAdvanceToken(parser, SyntaxKind_BreakKeyword);
    if (parser->loopLevel == 0 && parser->switchCaseLevel == 0) {
        ReportError(TokenGetLocation(result->breakStmt.breakKeyword), "Invalid 'break' keyword found outside of loop or switch-case definition");
    }
    result->returnStmt.semicolon = MatchAndAdvanceToken(parser, SyntaxKind_SemicolonToken);
    return result;
}

static SyntaxNode* ParseContinueStatement(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_ContinueStatement, parser->tree);
    result->continueStmt.continueKeyword = MatchAndAdvanceToken(parser, SyntaxKind_ContinueKeyword);
    if (parser->loopLevel == 0) {
        ReportError(TokenGetLocation(result->continueStmt.continueKeyword), "Invalid 'continue' keyword found outside of loop definition");
    }
    result->returnStmt.semicolon = MatchAndAdvanceToken(parser, SyntaxKind_SemicolonToken);
    return result;
}

static SyntaxNode* ParseBlockStatement(Parser* parser, bool inSwitch) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_BlockStatement, parser->tree);
    if (parser->tokenCur.kind == SyntaxKind_LeftBraceToken || !inSwitch) {
        result->blockStmt.leftBrace = MatchAndAdvanceToken(parser, SyntaxKind_LeftBraceToken);
    } else {
        result->blockStmt.leftBrace = SyntaxTokenCreateEmpty(parser->tree);
    }
    result->blockStmt.statements = SyntaxNodeArrayCreate();
    while (parser->tokenCur.kind != SyntaxKind_RightBraceToken) {
        if (inSwitch && parser->tokenCur.kind == SyntaxKind_CaseKeyword) {
            break;
        }
        if (inSwitch && parser->tokenCur.kind == SyntaxKind_DefaultKeyword) {
            break;
        }
        SyntaxNode* statement = ParseStatement(parser);
        SyntaxNodeArrayPush(&result->blockStmt.statements, statement);
    }
    if (result->blockStmt.leftBrace.kind != SyntaxKind_BadToken) {
        result->blockStmt.rightBrace = MatchAndAdvanceToken(parser, SyntaxKind_RightBraceToken);
    }
    return result;
}

static SyntaxNode* ParseCaseStatement(Parser* parser, SyntaxNode* switchExpression) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_CaseStatement, parser->tree);
    result->caseStmt.caseKeyword = MatchAndAdvanceToken(parser, SyntaxKind_CaseKeyword);
    if (parser->switchCaseLevel == 0) {
        ReportError(TokenGetLocation(result->caseStmt.caseKeyword), "Unexpected 'case' label keyword outside of switch statement");
    }
    result->caseStmt.literalExpression = ParseExpression(parser);
    switch (result->caseStmt.literalExpression->kind) {
        case SyntaxKind_IntegerLiteralExpression: // Fallthrough
        case SyntaxKind_StringLiteralExpression: // Fallthrough
        case SyntaxKind_CharacterLiteralExpression: // Fallthrough
        case SyntaxKind_EnumValueLiteralExpression: {
            break;
        }
        default: {
            ReportError(TokenGetLocation(result->caseStmt.caseKeyword), "Expected literal token in case label but got '%s' instead", "TODO - we need to get the string of an expression");
        }
    }
    result->caseStmt.colon = MatchAndAdvanceToken(parser, SyntaxKind_ColonToken);
    result->caseStmt.body = ParseBlockStatement(parser, true);
    return result;
}

static SyntaxNode* ParseDefaultStatement(Parser* parser, SyntaxNode* switchExpression) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_DefaultStatement, parser->tree);
    result->defaultStmt.defaultKeyword = MatchAndAdvanceToken(parser, SyntaxKind_DefaultKeyword);
    if (parser->switchCaseLevel == 0) {
        ReportError(TokenGetLocation(result->defaultStmt.defaultKeyword), "Unexpected 'default' case label keyword outside of switch statement");
    }
    result->defaultStmt.colon = MatchAndAdvanceToken(parser, SyntaxKind_ColonToken);
    result->defaultStmt.body = ParseBlockStatement(parser, true);
    return result;
}

static SyntaxNode* ParseSwitchStatement(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_SwitchStatement, parser->tree);
    result->switchStmt.switchKeyword = MatchAndAdvanceToken(parser, SyntaxKind_SwitchKeyword);
    result->switchStmt.leftParen = MatchAndAdvanceToken(parser, SyntaxKind_LeftParenToken);
    result->switchStmt.switchExpression = ParseExpression(parser);
    result->switchStmt.rightParen = MatchAndAdvanceToken(parser, SyntaxKind_RightParenToken);
    result->switchStmt.leftBrace = MatchAndAdvanceToken(parser, SyntaxKind_LeftBraceToken);
    parser->switchCaseLevel += 1;
    result->switchStmt.caseStatements = SyntaxNodeArrayCreate();
    while (parser->tokenCur.kind != SyntaxKind_EndOfFileToken) {
        if (parser->tokenCur.kind == SyntaxKind_RightBraceToken) {
            break;
        }
        if (parser->tokenCur.kind == SyntaxKind_CaseKeyword) {
            SyntaxNode* caseStatement = ParseCaseStatement(parser, result);
            SyntaxNodeArrayPush(&result->switchStmt.caseStatements, caseStatement);
        } else {
            SyntaxNode* defaultStatement = ParseDefaultStatement(parser, result);
            SyntaxNodeArrayPush(&result->switchStmt.caseStatements, defaultStatement);
        }
    }
    parser->switchCaseLevel -= 1;
    result->switchStmt.rightBrace = MatchAndAdvanceToken(parser, SyntaxKind_RightBraceToken);
    return result;
}

static SyntaxNode* ParseStatement(Parser* parser) {
    assert(parser->functionLevel > 0);
    switch (parser->tokenCur.kind) {
        case SyntaxKind_LeftBraceToken: {
            return ParseBlockStatement(parser, false);
        }
        case SyntaxKind_IfKeyword: {
            return ParseIfStatement(parser);
        }
        case SyntaxKind_DoKeyword: {
            return ParseDoWhileStatement(parser);
        }
        case SyntaxKind_WhileKeyword: {
            return ParseWhileStatement(parser);
        }
        case SyntaxKind_ForKeyword: {
            return ParseForStatement(parser);
        }
        case SyntaxKind_ReturnKeyword: {
            return ParseReturnStatement(parser);
        }
        case SyntaxKind_BreakKeyword: {
            return ParseBreakStatement(parser);
        }
        case SyntaxKind_ContinueKeyword: {
            return ParseContinueStatement(parser);
        }
        case SyntaxKind_SwitchKeyword: {
            return ParseSwitchStatement(parser);
        }
        case SyntaxKind_LetKeyword: // Fallthrough
        case SyntaxKind_LetLocalPersistKeyword: {
            return ParseVariableDefinitionStatement(parser, false, true, SyntaxKind_SemicolonToken);
        }
        default: {
            return ParseExpressionStatement(parser);
        }
    }
}

static SyntaxNode* ParseStructOrUnionDefinitionStatement(Parser* parser, SyntaxToken externKeyword) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_StructOrUnionDeclarationStatement, parser->tree);
    result->structOrUnionDeclarationStmt.externKeyword = externKeyword;
    if (parser->tokenCur.kind == SyntaxKind_StructKeyword) {
        result->structOrUnionDeclarationStmt.structOrUnionKeyword = MatchAndAdvanceToken(parser, SyntaxKind_StructKeyword);
    } else {
        result->structOrUnionDeclarationStmt.structOrUnionKeyword = MatchAndAdvanceToken(parser, SyntaxKind_UnionKeyword);
    }
    result->structOrUnionDeclarationStmt.identifier = MatchAndAdvanceToken(parser, SyntaxKind_IdentifierToken);
    if (parser->tokenCur.kind == SyntaxKind_SemicolonToken) {
        result->structOrUnionDeclarationStmt.semicolon = MatchAndAdvanceToken(parser, SyntaxKind_SemicolonToken);
        return result;
    } else {
        result->kind = SyntaxKind_StructOrUniontDefinitionStatement;
        result->structOrUnionDefinitionStmt.memberDeclarationStatements = SyntaxNodeArrayCreate();
        result->structOrUnionDefinitionStmt.leftBrace = MatchAndAdvanceToken(parser, SyntaxKind_LeftBraceToken);
        while (parser->tokenCur.kind != SyntaxKind_RightBraceToken) {
            SyntaxNode* memberDeclaration = ParseVariableDefinitionStatement(parser, true, false, SyntaxKind_SemicolonToken);
            SyntaxNodeArrayPush(&result->structOrUnionDefinitionStmt.memberDeclarationStatements, memberDeclaration);
        }
        result->structOrUnionDefinitionStmt.rightBrace = MatchAndAdvanceToken(parser, SyntaxKind_RightBraceToken);
        result->structOrUnionDefinitionStmt.semicolon = MatchAndAdvanceToken(parser, SyntaxKind_SemicolonToken);
        return result;
    }
}

static SyntaxNode* ParseEnumMemberClause(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_EnumMemberClauseSyntax, parser->tree);
    result->enumMember.identifier = MatchAndAdvanceToken(parser, SyntaxKind_IdentifierToken);
    if (parser->tokenCur.kind == SyntaxKind_EqualsToken) {
        result->enumMember.equals = MatchAndAdvanceToken(parser, SyntaxKind_EqualsToken);
        result->enumMember.integerLiteral = MatchAndAdvanceToken(parser, SyntaxKind_IntegerLiteralToken);
    } else {
        result->enumMember.equals = SyntaxTokenCreateEmpty(parser->tree);
        result->enumMember.integerLiteral = SyntaxTokenCreateEmpty(parser->tree);
    }
    if (parser->tokenCur.kind == SyntaxKind_CommaToken) {
        result->enumMember.comma = MatchAndAdvanceToken(parser, SyntaxKind_CommaToken);
    } else {
        result->enumMember.comma = SyntaxTokenCreateEmpty(parser->tree);
    }
    return result;
}

static SyntaxNode* ParseEnumDefinitionStatement(Parser* parser, SyntaxToken externKeyword) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_EnumDeclarationStatement, parser->tree);
    result->enumDeclarationStmt.externKeyword = externKeyword;
    result->enumDeclarationStmt.enumKeyword = MatchAndAdvanceToken(parser, SyntaxKind_EnumKeyword);
    result->enumDeclarationStmt.classKeyword = MatchAndAdvanceToken(parser, SyntaxKind_ClassKeyword);
    result->enumDeclarationStmt.identifier = MatchAndAdvanceToken(parser, SyntaxKind_IdentifierToken);
    if (parser->tokenCur.kind == SyntaxKind_SemicolonToken) {
        result->enumDeclarationStmt.semicolon = MatchAndAdvanceToken(parser, SyntaxKind_SemicolonToken);
        return result;
    } else {
        result->kind = SyntaxKind_EnumDefinitionStatement;
        result->enumDefinitionStmt.memberClauses = SyntaxNodeArrayCreate();
        result->enumDefinitionStmt.leftBrace = MatchAndAdvanceToken(parser, SyntaxKind_LeftBraceToken);
        while (parser->tokenCur.kind != SyntaxKind_RightBraceToken) {
            SyntaxNode* memberClause = ParseEnumMemberClause(parser);
            SyntaxNodeArrayPush(&result->enumDefinitionStmt.memberClauses, memberClause);
            if (memberClause->enumMember.comma.kind != SyntaxKind_CommaToken) {
                break;
            }
        }
        result->enumDefinitionStmt.rightBrace = MatchAndAdvanceToken(parser, SyntaxKind_RightBraceToken);
        result->enumDefinitionStmt.semicolon = MatchAndAdvanceToken(parser, SyntaxKind_SemicolonToken);
        return result;
    }
}

static SyntaxNode* ParseFunctionDefinitionStatement(Parser* parser, SyntaxToken externKeyword) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_FunctionDeclarationStatement, parser->tree);
    result->functionDeclarationStmt.externKeyword = externKeyword;
    result->functionDeclarationStmt.funKeyword = MatchAndAdvanceToken(parser, SyntaxKind_FunKeyword);
    result->functionDeclarationStmt.returnType = ParseTypeExpression(parser);
    result->functionDeclarationStmt.identifier = MatchAndAdvanceToken(parser, SyntaxKind_IdentifierToken);
    result->functionDeclarationStmt.leftParen = MatchAndAdvanceToken(parser, SyntaxKind_LeftParenToken);
    result->functionDeclarationStmt.params = SyntaxNodeArrayCreate();
    while (parser->tokenCur.kind != SyntaxKind_RightParenToken) {
        if (parser->tokenCur.kind == SyntaxKind_DotDotDotToken) {
            SyntaxToken dotdot = MatchAndAdvanceToken(parser, SyntaxKind_DotDotDotToken);
            SyntaxNode* dotdotWrapper = WrapTokenInNode(parser, dotdot);
            SyntaxNodeArrayPush(&result->functionDeclarationStmt.params, dotdotWrapper);
            break;
        }
        SyntaxNode* parameter = ParseVariableDefinitionStatement(parser, true, false, SyntaxKind_BadToken);
        SyntaxNodeArrayPush(&result->functionDeclarationStmt.params, parameter);
        if (parser->tokenCur.kind == SyntaxKind_CommaToken) {
            parameter->variableDeclarationStmt.terminatorToken = MatchAndAdvanceToken(parser, SyntaxKind_CommaToken);
        } else {
            break;
        }
    }
    result->functionDeclarationStmt.rightParen = MatchAndAdvanceToken(parser, SyntaxKind_RightParenToken);
    if (parser->tokenCur.kind == SyntaxKind_SemicolonToken) {
        result->functionDeclarationStmt.semicolon = MatchAndAdvanceToken(parser, SyntaxKind_SemicolonToken);
        return result;
    } else {
        result->kind = SyntaxKind_FunctionDefinitionStatement;
        parser->functionLevel += 1;
        result->functionDefinitionStmt.body = ParseBlockStatement(parser, false);
        parser->functionLevel -= 1;
        return result;
    }
}

static SyntaxNode* ParseGlobalVariableDefinitionStatement(Parser* parser, SyntaxToken externKeyword) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_GlobalVariableDeclarationStatement, parser->tree);
    result->globalVariableStmt.externKeyword = externKeyword;
    result->globalVariableStmt.variableDeclarationStatement = ParseVariableDefinitionStatement(parser, false, true, SyntaxKind_SemicolonToken);
    return result;
}

static SyntaxNode* ParseGlobalDefinitionStatement(Parser* parser) {
    assert(parser->functionLevel == 0);
    SyntaxToken externKeyword = SyntaxTokenCreateEmpty(parser->tree);
    if (parser->tokenCur.kind == SyntaxKind_ExternKeyword) {
        externKeyword = AdvanceToken(parser);
    }
    switch (parser->tokenCur.kind) {
        case SyntaxKind_EnumKeyword: {
            return ParseEnumDefinitionStatement(parser, externKeyword);
        }
        case SyntaxKind_StructKeyword: // Fallthrough
        case SyntaxKind_UnionKeyword: {
            return ParseStructOrUnionDefinitionStatement(parser, externKeyword);
        }
        case SyntaxKind_FunKeyword: {
            return ParseFunctionDefinitionStatement(parser, externKeyword);
        }
        default: {
            return ParseGlobalVariableDefinitionStatement(parser, externKeyword);
        }
    }
}

static SyntaxNode* ParseImportDeclarationStatement(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_ImportDeclarationStatement, parser->tree);
    result->importStmt.importKeyword = MatchAndAdvanceToken(parser, SyntaxKind_ImportKeyword);
    result->importStmt.modulenameLiteral = MatchAndAdvanceToken(parser, SyntaxKind_StringLiteralToken);
    return result;
}

static SyntaxNode* ParseModuleStatement(Parser* parser) {
    switch (parser->tokenCur.kind) {
        case SyntaxKind_ExternKeyword: // Fallthrough
        case SyntaxKind_StructKeyword: // Fallthrough
        case SyntaxKind_UnionKeyword: // Fallthrough
        case SyntaxKind_EnumKeyword: // Fallthrough
        case SyntaxKind_FunKeyword: // Fallthrough
        case SyntaxKind_LetKeyword: {
            return ParseGlobalDefinitionStatement(parser);
        }
        case SyntaxKind_IncludeDirectiveKeyword: {
            return ParseImportDeclarationStatement(parser);
        }
        default: {
            ReportError(TokenGetLocation(parser->tokenCur), "Expected global module definition got unexpected token '%s' instead", TokenGetText(parser->tokenCur).cstr);
            exit(1);
        }
    }
}

static SyntaxTree* ParseModule(Parser* parser) {
    SyntaxNode* result = SyntaxNodeCreate(SyntaxKind_Module, parser->tree);
    parser->tree->moduleRoot = (ModuleStatementSyntax*)result;
    result->moduleStmt.globalStatements = SyntaxNodeArrayCreate();
    while (parser->tokenCur.kind != SyntaxKind_EndOfFileToken) {
        bool foundDirectives = false;
        do {
            foundDirectives = false;
            if (parser->tokenCur.kind == SyntaxKind_TypedefKeyword) {
                MatchAndAdvanceToken(parser, SyntaxKind_TypedefKeyword);
                while (parser->tokenCur.kind != SyntaxKind_SemicolonToken) {
                    AdvanceToken(parser);
                }
                MatchAndAdvanceToken(parser, SyntaxKind_SemicolonToken);
                foundDirectives = true;
            }
            if (parser->tokenCur.kind == SyntaxKind_IncludeDirectiveKeyword) {
                MatchAndAdvanceToken(parser, SyntaxKind_IncludeDirectiveKeyword);
                if (parser->tokenCur.kind == SyntaxKind_LessToken) {
                    MatchAndAdvanceToken(parser, SyntaxKind_LessToken);
                    AdvanceToken(parser);
                    MatchAndAdvanceToken(parser, SyntaxKind_DotToken);
                    AdvanceToken(parser);
                    MatchAndAdvanceToken(parser, SyntaxKind_GreaterToken);
                } else {
                    MatchAndAdvanceToken(parser, SyntaxKind_StringLiteralToken);
                }
                foundDirectives = true;
            }
            if (parser->tokenCur.kind == SyntaxKind_PragmaDirectiveKeyword) {
                MatchAndAdvanceToken(parser, SyntaxKind_PragmaDirectiveKeyword);
                MatchAndAdvanceToken(parser, SyntaxKind_IdentifierToken);
                foundDirectives = true;
            }
            if (parser->tokenCur.kind == SyntaxKind_IfDirectiveKeyword) {
                MatchAndAdvanceToken(parser, SyntaxKind_IfDirectiveKeyword);
                AdvanceToken(parser);
                foundDirectives = true;
            }
            if (parser->tokenCur.kind == SyntaxKind_EndIfDefinedDirectiveKeyword) {
                MatchAndAdvanceToken(parser, SyntaxKind_EndIfDefinedDirectiveKeyword);
                foundDirectives = true;
            }
            if (parser->tokenCur.kind == SyntaxKind_DefineDirectiveKeyword) {
                MatchAndAdvanceToken(parser, SyntaxKind_DefineDirectiveKeyword);
                if (parser->tokenCur.kind == SyntaxKind_LetKeyword) {
                    MatchAndAdvanceToken(parser, SyntaxKind_LetKeyword);
                } else {
                    if (parser->tokenCur.kind == SyntaxKind_AsKeyword) {
                        MatchAndAdvanceToken(parser, SyntaxKind_AsKeyword);
                    } else {
                        if (parser->tokenCur.kind == SyntaxKind_ByteKeyword) {
                            MatchAndAdvanceToken(parser, SyntaxKind_ByteKeyword);
                            MatchAndAdvanceToken(parser, SyntaxKind_CharKeyword);
                        } else {
                            if (parser->tokenCur.kind == SyntaxKind_LetLocalPersistKeyword) {
                                MatchAndAdvanceToken(parser, SyntaxKind_LetLocalPersistKeyword);
                                MatchAndAdvanceToken(parser, SyntaxKind_IdentifierToken);
                            } else {
                                MatchAndAdvanceToken(parser, SyntaxKind_FunKeyword);
                            }
                        }
                    }
                }
                foundDirectives = true;
            }
        } while (foundDirectives);
        SyntaxNode* statement = ParseModuleStatement(parser);
        SyntaxNodeArrayPush(&result->moduleStmt.globalStatements, statement);
    }
    if (parser->tokenCur.kind != SyntaxKind_EndOfFileToken) {
        ReportError(TokenGetLocation(parser->tokenCur), "Expected EOF token after parsing file, instead got '%s'", TokenKindToString(parser->tokenCur.kind).cstr);
    }
    return parser->tree;
}

struct Emitter; typedef struct Emitter Emitter; struct Emitter {
    FILE* outFile;
    int32 indentationLevel;
};

static Emitter EmitterCreate(String emitFilepath) {
    FILE* outFile = fopen(emitFilepath.cstr, "w");
    if (outFile == NULL) {
        fprintf(stderr, "Cannot open file for writing: '%s'", emitFilepath.cstr);
        exit(1);
    }
    Emitter result;
    result.outFile = outFile;
    result.indentationLevel = 0;
    return result;
}

static void EmitNewLine(Emitter* emitter) {
    fprintf(emitter->outFile, "\n");
    for (int32 index = 0; index < emitter->indentationLevel; index += 1) {
        fprintf(emitter->outFile, "    ");
    }
}

void EmitType(Emitter* emitter, Type type);

void EmitExpression(Emitter* emitter, ASTNode* node);

void EmitStatement(Emitter* emitter, ASTNode* node);

static void EmitCastExpression(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "(");
    EmitType(emitter, node->type);
    fprintf(emitter->outFile, ")");
    EmitExpression(emitter, node->left);
}

static void EmitSizeOfExpression(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "sizeof(");
    EmitType(emitter, node->left->type);
    fprintf(emitter->outFile, ")");
}

static void EmitParenthesizedExpression(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "(");
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, ")");
}

static void EmitUnaryExpression(Emitter* emitter, ASTNode* node) {
    if (node->kind == ASTNodeKind_Identity) {
        EmitExpression(emitter, node->left);
        return;
    }
    switch (node->kind) {
        case ASTNodeKind_Negation: {
            fprintf(emitter->outFile, "-");
            break;
        }
        case ASTNodeKind_LogicalNegation: {
            fprintf(emitter->outFile, "!");
            break;
        }
        case ASTNodeKind_BitwiseNegation: {
            fprintf(emitter->outFile, "~");
            break;
        }
        case ASTNodeKind_Address: {
            fprintf(emitter->outFile, "&");
            break;
        }
        case ASTNodeKind_Dereference: {
            fprintf(emitter->outFile, "*");
            break;
        }
        default: {
            fprintf(stdout, "Unexpected unary operation kind in emitter %d", node->kind);
            exit(1);
        }
    }
    EmitExpression(emitter, node->left);
}

static void EmitBinaryExpression(Emitter* emitter, ASTNode* node) {
    EmitExpression(emitter, node->left);
    SyntaxToken token;
    if (node->syntax == NULL) {
        token = node->token;
    } else {
        assert(node->syntax->kind == SyntaxKind_BinaryExpression);
        BinaryExpressionSyntax* syntax = (BinaryExpressionSyntax*)node->syntax;
        token = syntax->operatorToken;
    }
    fprintf(emitter->outFile, " %s ", TokenKindToString(token.kind).cstr);
    EmitExpression(emitter, node->right);
}

static void EmitTernaryConditionalExpression(Emitter* emitter, ASTNode* node) {
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, " ? ");
    EmitExpression(emitter, node->right);
    fprintf(emitter->outFile, " : ");
    EmitExpression(emitter, node->extra1);
}

static void EmitEnumLiteralSymbol(Emitter* emitter, Symbol* enumLiteral) {
    fprintf(emitter->outFile, "%s_%s", enumLiteral->type.name.cstr, enumLiteral->name.cstr);
}

static void EmitBoolLiteral(Emitter* emitter, ASTNode* node) {
    if (node->intvalue == 0) {
        fprintf(emitter->outFile, "false");
    } else {
        fprintf(emitter->outFile, "true");
    }
}

static void EmitEnumLiteral(Emitter* emitter, ASTNode* node) {
    EmitEnumLiteralSymbol(emitter, node->symbol);
}

static void EmitCharacterLiteral(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "'%s'", node->stringvalue.cstr);
}

static void EmitIntegerLiteral(Emitter* emitter, ASTNode* node) {
    SyntaxToken token;
    if (node->syntax == NULL) {
        token = node->token;
    } else {
        assert(node->syntax->kind == SyntaxKind_IntegerLiteralExpression);
        IntegerLiteralExpressionSyntax* syntax = (IntegerLiteralExpressionSyntax*)node->syntax;
        token = syntax->integerLiteral;
    }
    assert(token.kind == SyntaxKind_IntegerLiteralToken);
    if (token.intvalueIsHex) {
        fprintf(emitter->outFile, "%s", TokenGetText(token).cstr);
    } else {
        fprintf(emitter->outFile, "%lld", node->intvalue);
    }
}

static void EmitStringLiteral(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "\"%s\"", node->stringvalue.cstr);
}

static void EmitArrayLiteral(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "{ ");
    for (int32 index = 0; index < node->children.count; index += 1) {
        EmitExpression(emitter, node->children.nodes[index]);
        if (index != node->children.count - 1) {
            fprintf(emitter->outFile, ", ");
        }
    }
    fprintf(emitter->outFile, " }");
}

static void EmitNullLiteral(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "NULL");
}

static void EmitNameExpression(Emitter* emitter, ASTNode* node) {
    String name = node->symbol->name;
    fprintf(emitter->outFile, "%s", name.cstr);
}

static void EmitFunctionCallExpression(Emitter* emitter, ASTNode* node) {
    String funcName = node->symbol->name;
    fprintf(emitter->outFile, "%s(", funcName.cstr);
    for (int32 index = 0; index < node->children.count; index += 1) {
        EmitExpression(emitter, node->children.nodes[index]);
        if (index != node->children.count - 1) {
            fprintf(emitter->outFile, ", ");
        }
    }
    fprintf(emitter->outFile, ")");
}

static void EmitArrayIndexingExpression(Emitter* emitter, ASTNode* node) {
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, "[");
    EmitExpression(emitter, node->right);
    fprintf(emitter->outFile, "]");
}

static void EmitMemberAccessExpression(Emitter* emitter, ASTNode* node) {
    EmitExpression(emitter, node->left);
    if (IsPointerType(node->left->type)) {
        fprintf(emitter->outFile, "->");
    } else {
        fprintf(emitter->outFile, ".");
    }
    String memberName = node->symbol->name;
    fprintf(emitter->outFile, "%s", memberName.cstr);
}

static void EmitExpression(Emitter* emitter, ASTNode* node) {
    switch (node->kind) {
        case ASTNodeKind_CastExpression: {
            EmitCastExpression(emitter, node);
            break;
        }
        case ASTNodeKind_SizeOfExpression: {
            EmitSizeOfExpression(emitter, node);
            break;
        }
        case ASTNodeKind_ParenthesizedExpression: {
            EmitParenthesizedExpression(emitter, node);
            break;
        }
        case ASTNodeKind_Identity: // Fallthrough
        case ASTNodeKind_Negation: // Fallthrough
        case ASTNodeKind_LogicalNegation: // Fallthrough
        case ASTNodeKind_BitwiseNegation: // Fallthrough
        case ASTNodeKind_Address: // Fallthrough
        case ASTNodeKind_Dereference: {
            EmitUnaryExpression(emitter, node);
            break;
        }
        case ASTNodeKind_Assignment: // Fallthrough
        case ASTNodeKind_Add: // Fallthrough
        case ASTNodeKind_AddAssignment: // Fallthrough
        case ASTNodeKind_Subtract: // Fallthrough
        case ASTNodeKind_SubtractAssignment: // Fallthrough
        case ASTNodeKind_Multiply: // Fallthrough
        case ASTNodeKind_MultiplyAssignment: // Fallthrough
        case ASTNodeKind_Divide: // Fallthrough
        case ASTNodeKind_DivideAssignment: // Fallthrough
        case ASTNodeKind_Remainder: // Fallthrough
        case ASTNodeKind_RemainderAssignment: // Fallthrough
        case ASTNodeKind_Equals: // Fallthrough
        case ASTNodeKind_NotEquals: // Fallthrough
        case ASTNodeKind_Less: // Fallthrough
        case ASTNodeKind_LessEquals: // Fallthrough
        case ASTNodeKind_Greater: // Fallthrough
        case ASTNodeKind_GreaterEquals: // Fallthrough
        case ASTNodeKind_AddToPointer: // Fallthrough
        case ASTNodeKind_AddToPointerAssignment: // Fallthrough
        case ASTNodeKind_SubtractFromPointer: // Fallthrough
        case ASTNodeKind_SubtractFromPointerAssignment: // Fallthrough
        case ASTNodeKind_DistanceBetweenPointers: // Fallthrough
        case ASTNodeKind_BitshiftLeft: // Fallthrough
        case ASTNodeKind_BitshiftLeftAssignment: // Fallthrough
        case ASTNodeKind_BitshiftRight: // Fallthrough
        case ASTNodeKind_BitshiftRightAssignment: // Fallthrough
        case ASTNodeKind_BitwiseAnd: // Fallthrough
        case ASTNodeKind_BitwiseAndAssignment: // Fallthrough
        case ASTNodeKind_BitwiseOr: // Fallthrough
        case ASTNodeKind_BitwiseOrAssignment: // Fallthrough
        case ASTNodeKind_BitwiseXor: // Fallthrough
        case ASTNodeKind_BitwiseXorAssignment: // Fallthrough
        case ASTNodeKind_LogicalAnd: // Fallthrough
        case ASTNodeKind_LogicalOr: {
            EmitBinaryExpression(emitter, node);
            break;
        }
        case ASTNodeKind_TernaryConditionalExpression: {
            EmitTernaryConditionalExpression(emitter, node);
            break;
        }
        case ASTNodeKind_NameExpression: {
            EmitNameExpression(emitter, node);
            break;
        }
        case ASTNodeKind_BoolLiteral: {
            EmitBoolLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_CharacterLiteral: {
            EmitCharacterLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_IntegerLiteral: {
            EmitIntegerLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_StringLiteral: {
            EmitStringLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_EnumValueLiteral: {
            EmitEnumLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_ArrayLiteral: {
            EmitArrayLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_NullLiteral: {
            EmitNullLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_Arrayindexing: {
            EmitArrayIndexingExpression(emitter, node);
            break;
        }
        case ASTNodeKind_Memberaccess: {
            EmitMemberAccessExpression(emitter, node);
            break;
        }
        case ASTNodeKind_FunccallExpression: {
            EmitFunctionCallExpression(emitter, node);
            break;
        }
        default: {
            fprintf(stderr, "Unknown expression in emitter: %d\n", node->kind);
            exit(1);
        }
    }
}

static void EmitExpressionStatement(Emitter* emitter, ASTNode* node) {
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, ";");
}

static void EmitIfStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "if (");
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, ") ");
    EmitStatement(emitter, node->right);
    if (node->extra1 != NULL) {
        fprintf(emitter->outFile, " else ");
        EmitStatement(emitter, node->extra1);
    }
}

static void EmitDoWhileStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "do ");
    EmitStatement(emitter, node->right);
    fprintf(emitter->outFile, " while (");
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, ");");
}

static void EmitWhileStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "while (");
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, ") ");
    EmitStatement(emitter, node->right);
}

static void EmitForStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "for (");
    EmitStatement(emitter, node->left);
    fprintf(emitter->outFile, " ");
    EmitStatement(emitter, node->right);
    fprintf(emitter->outFile, " ");
    EmitExpression(emitter, node->extra1);
    fprintf(emitter->outFile, ") ");
    EmitStatement(emitter, node->extra2);
}

static void EmitReturnStatement(Emitter* emitter, ASTNode* node) {
    if (node->left == NULL) {
        fprintf(emitter->outFile, "return;");
    } else {
        fprintf(emitter->outFile, "return ");
        EmitExpression(emitter, node->left);
        fprintf(emitter->outFile, ";");
    }
}

static void EmitBreakStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "break;");
}

static void EmitContinueStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "continue;");
}

static void EmitCaseStatement(Emitter* emitter, ASTNode* node) {
    if (node->kind == ASTNodeKind_DefaultStatement) {
        fprintf(emitter->outFile, "default: ");
        if (node->left != NULL) {
            EmitStatement(emitter, node->left);
        } else {
            fprintf(emitter->outFile, "// Fallthrough");
        }
    } else {
        fprintf(emitter->outFile, "case ");
        EmitExpression(emitter, node->right);
        fprintf(emitter->outFile, ": ");
        if (node->left != NULL) {
            EmitStatement(emitter, node->left);
        } else {
            fprintf(emitter->outFile, "// Fallthrough");
        }
    }
}

static void EmitSwitchStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "switch (");
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, ") {");
    emitter->indentationLevel += 1;
    EmitNewLine(emitter);
    for (int32 index = 0; index < node->children.count; index += 1) {
        EmitCaseStatement(emitter, node->children.nodes[index]);
        if (index == node->children.count - 1) {
            emitter->indentationLevel -= 1;
        }
        EmitNewLine(emitter);
    }
    fprintf(emitter->outFile, "}");
}

static void EmitType(Emitter* emitter, Type type) {
    switch (type.kind) {
        case TypeKind_PrimitiveVoid: {
            fprintf(emitter->outFile, "void");
            break;
        }
        case TypeKind_PrimitiveBool: {
            fprintf(emitter->outFile, "bool");
            break;
        }
        case TypeKind_PrimitiveChar: {
            fprintf(emitter->outFile, "char");
            break;
        }
        case TypeKind_PrimitiveByte: {
            fprintf(emitter->outFile, "int8");
            break;
        }
        case TypeKind_PrimitiveShort: {
            fprintf(emitter->outFile, "int16");
            break;
        }
        case TypeKind_PrimitiveInt: {
            fprintf(emitter->outFile, "int32");
            break;
        }
        case TypeKind_PrimitiveLong: {
            fprintf(emitter->outFile, "int64");
            break;
        }
        case TypeKind_PrimitiveCString: {
            fprintf(emitter->outFile, "const char*");
            break;
        }
        case TypeKind_Struct: // Fallthrough
        case TypeKind_Union: // Fallthrough
        case TypeKind_Enum: {
            fprintf(emitter->outFile, "%s", type.name.cstr);
            break;
        }
        default: {
            assert(false && "Unexpected type in emitter");
        }
    }
    for (int32 index = 0; index < type.baseIndirectionLevel; index += 1) {
        fprintf(emitter->outFile, "*");
    }
}

static void EmitVariableDeclarationWithoutTerminator(Emitter* emitter, Symbol* varSymbol) {
    Type varType = varSymbol->type;
    EmitType(emitter, varType);
    String varName = varSymbol->name;
    fprintf(emitter->outFile, " %s", varName.cstr);
    if (varSymbol->type.isArray) {
        fprintf(emitter->outFile, "[%lld]", varSymbol->type.arrayElementCount);
    }
}

static void EmitVariableDeclarationStatement(Emitter* emitter, ASTNode* node) {
    if (node->symbol->scopeKind == SymbolScopeKind_Extern) {
        return;
    } else {
        if (node->symbol->scopeKind == SymbolScopeKind_LocalPersist) {
            fprintf(emitter->outFile, "static ");
        } else {
            if (node->symbol->scopeKind == SymbolScopeKind_Global) {
                fprintf(emitter->outFile, "static ");
            }
        }
    }
    EmitVariableDeclarationWithoutTerminator(emitter, node->symbol);
    if (node->left != NULL) {
        fprintf(emitter->outFile, " = ");
        EmitExpression(emitter, node->left);
    }
    fprintf(emitter->outFile, ";");
}

static void EmitBlockStatement(Emitter* emitter, ASTNode* node) {
    if (node->children.count == 0) {
        fprintf(emitter->outFile, "{}");
    } else {
        fprintf(emitter->outFile, "{");
        emitter->indentationLevel += 1;
        EmitNewLine(emitter);
        for (int32 index = 0; index < node->children.count; index += 1) {
            EmitStatement(emitter, node->children.nodes[index]);
            if (index == node->children.count - 1) {
                emitter->indentationLevel -= 1;
            }
            EmitNewLine(emitter);
        }
        fprintf(emitter->outFile, "}");
    }
}

static void EmitEnumDeclarationStatement(Emitter* emitter, ASTNode* node) {
    if (node->symbol->scopeKind == SymbolScopeKind_Extern) {
        return;
    }
    String enumName = node->symbol->name;
    fprintf(emitter->outFile, "enum %s; ", enumName.cstr);
    fprintf(emitter->outFile, "typedef enum %s %s;", enumName.cstr, enumName.cstr);
}

static void EmitEnumDefinitionStatement(Emitter* emitter, ASTNode* node) {
    if (node->symbol->scopeKind == SymbolScopeKind_Extern) {
        return;
    }
    EmitEnumDeclarationStatement(emitter, node);
    String enumName = node->symbol->name;
    fprintf(emitter->outFile, " enum %s ", enumName.cstr);
    fprintf(emitter->outFile, "{");
    emitter->indentationLevel += 1;
    EmitNewLine(emitter);
    int32 memberCount = node->symbol->membersSymbolTable->count;
    for (int32 index = 0; index < memberCount; index += 1) {
        Symbol* memberSymbol = node->symbol->membersSymbolTable->symbols[index];
        EmitEnumLiteralSymbol(emitter, memberSymbol);
        fprintf(emitter->outFile, " = %lld,", memberSymbol->enumValue);
        if (index == memberCount - 1) {
            emitter->indentationLevel -= 1;
        }
        EmitNewLine(emitter);
    }
    fprintf(emitter->outFile, "};");
}

static void EmitStructOrUnionDeclarationStatement(Emitter* emitter, ASTNode* node, bool isUnion) {
    if (node->symbol->scopeKind == SymbolScopeKind_Extern) {
        return;
    }
    String structName = node->symbol->name;
    fprintf(emitter->outFile, isUnion ? "union %s; " : "struct %s; ", structName.cstr);
    fprintf(emitter->outFile, isUnion ? "typedef union %s %s;" : "typedef struct %s %s;", structName.cstr, structName.cstr);
}

static void EmitStructOrUnionDefinitionStatement(Emitter* emitter, ASTNode* node, bool isUnion) {
    if (node->symbol->scopeKind == SymbolScopeKind_Extern) {
        return;
    }
    EmitStructOrUnionDeclarationStatement(emitter, node, isUnion);
    String structName = node->symbol->name;
    fprintf(emitter->outFile, isUnion ? " union %s" : " struct %s ", structName.cstr);
    fprintf(emitter->outFile, "{");
    emitter->indentationLevel += 1;
    EmitNewLine(emitter);
    int32 memberCount = node->symbol->membersSymbolTable->count;
    for (int32 index = 0; index < memberCount; index += 1) {
        EmitVariableDeclarationWithoutTerminator(emitter, node->symbol->membersSymbolTable->symbols[index]);
        fprintf(emitter->outFile, ";");
        if (index == memberCount - 1) {
            emitter->indentationLevel -= 1;
        }
        EmitNewLine(emitter);
    }
    fprintf(emitter->outFile, "};");
}

static void EmitFunctionDeclarationWithoutTerminator(Emitter* emitter, ASTNode* node) {
    Type returnType = node->symbol->type;
    EmitType(emitter, returnType);
    String funcName = node->symbol->name;
    fprintf(emitter->outFile, " %s(", funcName.cstr);
    for (int32 index = 0; index < node->symbol->membersSymbolTable->count; index += 1) {
        EmitVariableDeclarationWithoutTerminator(emitter, node->symbol->membersSymbolTable->symbols[index]);
        if (index != node->symbol->membersSymbolTable->count - 1) {
            fprintf(emitter->outFile, ", ");
        }
        if (node->symbol->isVariadric && index == node->symbol->membersSymbolTable->count - 1) {
            fprintf(emitter->outFile, ", ...");
        }
    }
    fprintf(emitter->outFile, ")");
}

static void EmitFunctionDeclarationStatement(Emitter* emitter, ASTNode* node) {
    if (node->symbol->scopeKind == SymbolScopeKind_Extern) {
        return;
    }
    EmitFunctionDeclarationWithoutTerminator(emitter, node);
    fprintf(emitter->outFile, ";");
}

static void EmitFunctionDefinitionStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "static ");
    EmitFunctionDeclarationWithoutTerminator(emitter, node);
    fprintf(emitter->outFile, " ");
    EmitBlockStatement(emitter, node->left);
}

static void EmitPreamble(Emitter* emitter) {
    fprintf(emitter->outFile, "//////////////////////////////////////////////////////////////////////\n");
    fprintf(emitter->outFile, "// This file was generated by piggi and should not be modified by hand\n");
    fprintf(emitter->outFile, "//////////////////////////////////////////////////////////////////////\n");
    EmitNewLine(emitter);
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "#include <stdio.h>");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "#include <stdarg.h>");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "#include <stdint.h>");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "#include <stdbool.h>");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "#include <stdlib.h>");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "#include <assert.h>");
    EmitNewLine(emitter);
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "typedef int8_t  int8;");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "typedef int16_t int16;");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "typedef int32_t int32;");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "typedef int64_t int64;");
    EmitNewLine(emitter);
    EmitNewLine(emitter);
}

static void EmitPostamble(Emitter* emitter) {
    fclose(emitter->outFile);
}

static void EmitStatement(Emitter* emitter, ASTNode* node) {
    switch (node->kind) {
        case ASTNodeKind_IfStatement: {
            EmitIfStatement(emitter, node);
            break;
        }
        case ASTNodeKind_DoWhileStatement: {
            EmitDoWhileStatement(emitter, node);
            break;
        }
        case ASTNodeKind_WhileStatement: {
            EmitWhileStatement(emitter, node);
            break;
        }
        case ASTNodeKind_ForStatement: {
            EmitForStatement(emitter, node);
            break;
        }
        case ASTNodeKind_ReturnStatement: {
            EmitReturnStatement(emitter, node);
            break;
        }
        case ASTNodeKind_BreakStatement: {
            EmitBreakStatement(emitter, node);
            break;
        }
        case ASTNodeKind_ContinueStatement: {
            EmitContinueStatement(emitter, node);
            break;
        }
        case ASTNodeKind_SwitchStatement: {
            EmitSwitchStatement(emitter, node);
            break;
        }
        case ASTNodeKind_EnumDeclarationStatement: {
            EmitEnumDeclarationStatement(emitter, node);
            break;
        }
        case ASTNodeKind_EnumDefinitionStatement: {
            EmitEnumDefinitionStatement(emitter, node);
            break;
        }
        case ASTNodeKind_UnionDeclarationStatement: {
            EmitStructOrUnionDeclarationStatement(emitter, node, true);
            break;
        }
        case ASTNodeKind_UnionDefinitionStatement: {
            EmitStructOrUnionDefinitionStatement(emitter, node, true);
            break;
        }
        case ASTNodeKind_StructDeclarationStatement: {
            EmitStructOrUnionDeclarationStatement(emitter, node, false);
            break;
        }
        case ASTNodeKind_StructDefinitionStatement: {
            EmitStructOrUnionDefinitionStatement(emitter, node, false);
            break;
        }
        case ASTNodeKind_FunctionDeclarationStatement: {
            EmitFunctionDeclarationStatement(emitter, node);
            break;
        }
        case ASTNodeKind_FunctionDefinitionStatement: {
            EmitFunctionDefinitionStatement(emitter, node);
            break;
        }
        case ASTNodeKind_VariableDeclarationStatement: // Fallthrough
        case ASTNodeKind_ArrayDeclarationStatement: {
            EmitVariableDeclarationStatement(emitter, node);
            break;
        }
        case ASTNodeKind_ExpressionStatement: {
            EmitExpressionStatement(emitter, node);
            break;
        }
        case ASTNodeKind_BlockStatement: {
            EmitBlockStatement(emitter, node);
            break;
        }
        default: {
            fprintf(stderr, "Unknown statement in emitter: %d\n", node->kind);
            exit(1);
        }
    }
}

static void EmitRoot(Emitter* emitter, ASTNode* node) {
    assert(node->kind == ASTNodeKind_Module);
    EmitPreamble(emitter);
    for (int32 index = 0; index < node->children.count; index += 1) {
        EmitStatement(emitter, node->children.nodes[index]);
        EmitNewLine(emitter);
        EmitNewLine(emitter);
    }
    EmitPostamble(emitter);
}

static SourceFile ReadFileToString(String filepath) {
    char* buffer = NULL;
    FILE* handle = fopen(filepath.cstr, "rb");
    if (handle == NULL) {
        fprintf(stderr, "Unable to open file '%s'\n", filepath.cstr);
        exit(1);
    }
    fseek(handle, 0, SEEK_END);
    int64 length = (int64)ftell(handle);
    fseek(handle, 0, SEEK_SET);
    buffer = (char*)malloc(length + 1);
    if (buffer) {
        fread(buffer, 1, length, handle);
    }
    buffer[length] = '\0';
    fclose(handle);
    SourceFile result;
    result.filepath = filepath;
    result.content.cstr = buffer;
    result.content.length = (int32)length;
    return result;
}

struct Preprocessor; typedef struct Preprocessor Preprocessor; struct Preprocessor {
    Source source;
    SourceFileArray seenFiles;
};

static Preprocessor PreprocessorCreate() {
    Preprocessor result;
    result.source = SourceCreateEmpty();
    result.seenFiles = SourceFileArrayCreate();
    return result;
}

static bool PreprocessorSeenFile(Preprocessor* preprocessor, String filepath) {
    for (int32 index = 0; index < preprocessor->seenFiles.count; index += 1) {
        if (StringEquals(preprocessor->seenFiles.files[index].filepath, filepath)) {
            return true;
        }
    }
    return false;
}

static void PreprocessorPreprocessFile(Preprocessor* preprocessor, String filepath) {
    if (PreprocessorSeenFile(preprocessor, filepath)) {
        return;
    }
    SourceFile sourceFile = ReadFileToString(filepath);
    SourceFileArrayPush(&preprocessor->seenFiles, sourceFile);
    Source dummy = SourceCreateEmpty();
    SourceFileArrayPush(&dummy.files, sourceFile);
    dummy.content = sourceFile.content;
    SyntaxTree tree;
    tree.moduleRoot = NULL;
    tree.source = dummy;
    Scanner scanner = ScannerCreate(&tree);
    String result = StringCreateEmpty();
    while (true) {
        SyntaxToken token = NextToken(&scanner);
        if (token.kind == SyntaxKind_EndOfFileToken) {
            break;
        }
        if (token.kind != SyntaxKind_IncludeDirectiveKeyword) {
            continue;
        }
        token = NextToken(&scanner);
        if (token.kind == SyntaxKind_LessToken) {
            token = NextToken(&scanner);
            token = NextToken(&scanner);
            assert(token.kind == SyntaxKind_DotToken);
            token = NextToken(&scanner);
            token = NextToken(&scanner);
            assert(token.kind == SyntaxKind_GreaterToken);
        } else {
            if (token.kind == SyntaxKind_StringLiteralToken) {
                PreprocessorPreprocessFile(preprocessor, token.stringValueWithoutQuotes);
            } else {
                ReportError(TokenGetLocation(token), "Expected filepath after '#include' directive in '%s'", filepath.cstr);
            }
        }
    }
    SourceFileArrayPush(&preprocessor->source.files, sourceFile);
    preprocessor->source.content = StringAppend(preprocessor->source.content, sourceFile.content);
}

static Source PreprocessFile(String filepath) {
    Preprocessor preprocessor = PreprocessorCreate();
    PreprocessorPreprocessFile(&preprocessor, filepath);
    return preprocessor.source;
}

struct Binder; typedef struct Binder Binder; struct Binder {
    SymbolTable* symbolTable;
    Source source;
    ModuleStatementSyntax* tree;
    int32 loopLevel;
    int32 switchCaseLevel;
    Symbol* currentFunctionSymbol;
};

static Binder BinderCreate(Source source, SymbolTable* symbolTable) {
    Binder result;
    result.symbolTable = symbolTable;
    result.source = source;
    result.loopLevel = 0;
    result.switchCaseLevel = 0;
    result.currentFunctionSymbol = NULL;
    return result;
}

ASTNode* BindStatement(Binder* binder, SyntaxNode* syntax);

ASTNode* BindExpression(Binder* binder, SyntaxNode* syntax);

ASTNode* BindVariableDefinitionStatement(Binder* binder, SyntaxNode* syntax, SymbolScopeKind symbolScopeKind);

static ASTNode* _WrapInBlockStatementIfNecessary(Binder* binder, ASTNode* node) {
    if (node->kind != ASTNodeKind_BlockStatement) {
        ASTNode* block = ASTNodeCreate2(ASTNodeKind_BlockStatement, binder->symbolTable, NULL);
        ASTNodeArrayPush(&block->children, node);
        node = block;
    }
    return node;
}

static ASTNode* _FlattenBlockStatementIfNecessary(Binder* binder, ASTNode* node) {
    if (node->kind == ASTNodeKind_BlockStatement) {
        if (node->children.count == 1 && node->children.nodes[0]->kind == ASTNodeKind_BlockStatement) {
            ASTNode* result = node->children.nodes[0];
            result->symbolTable->parent = node->symbolTable->parent;
            return _FlattenBlockStatementIfNecessary(binder, result);
        }
    }
    return node;
}

static Type BindType(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_TypeExpression);
    Type type = TypeCreateVoid();
    SyntaxToken primary = syntax->typeExpr.typeTokens.nodes[0]->token;
    switch (primary.kind) {
        case SyntaxKind_VoidKeyword: {
            type.kind = TypeKind_PrimitiveVoid;
            break;
        }
        case SyntaxKind_CharKeyword: {
            type.kind = TypeKind_PrimitiveChar;
            break;
        }
        case SyntaxKind_BoolKeyword: {
            type.kind = TypeKind_PrimitiveBool;
            break;
        }
        case SyntaxKind_ByteKeyword: {
            type.kind = TypeKind_PrimitiveByte;
            break;
        }
        case SyntaxKind_ShortKeyword: {
            type.kind = TypeKind_PrimitiveShort;
            break;
        }
        case SyntaxKind_IntKeyword: {
            type.kind = TypeKind_PrimitiveInt;
            break;
        }
        case SyntaxKind_LongKeyword: {
            type.kind = TypeKind_PrimitiveLong;
            break;
        }
        case SyntaxKind_CStringKeyword: {
            type.kind = TypeKind_PrimitiveCString;
            break;
        }
        case SyntaxKind_IdentifierToken: {
            String name = TokenGetText(primary);
            Symbol* symbol = GetSymbol(binder->symbolTable, name);
            if (symbol != NULL) {
                if (symbol->kind == SymbolKind_Struct) {
                    type.kind = TypeKind_Struct;
                    type.name = name;
                    break;
                } else {
                    if (symbol->kind == SymbolKind_Union) {
                        type.kind = TypeKind_Union;
                        type.name = name;
                        break;
                    } else {
                        if (symbol->kind == SymbolKind_Enum) {
                            type.kind = TypeKind_Enum;
                            type.name = name;
                            break;
                        }
                    }
                }
            }
        }
        default: {
            ReportError(TokenGetLocation(primary), "SyntaxToken '%s' is not a type", TokenGetText(primary).cstr);
        }
    }
    for (int32 index = 1; index < syntax->typeExpr.typeTokens.count; index += 1) {
        SyntaxToken token = *((SyntaxToken*)syntax->typeExpr.typeTokens.nodes[index]);
        assert(token.kind == SyntaxKind_StarToken);
        type = GetPointerTypeForBaseType(type);
    }
    if (type.kind == TypeKind_Struct) {
        Symbol* symbol = GetSymbol(binder->symbolTable, type.name);
        if (!symbol->alreadyDefined && type.baseIndirectionLevel == 0) {
            ReportError(TokenGetLocation(primary), "Usage of undefined but forward declared type '%s' is only allowed as pointer", type.name.cstr);
        }
    }
    return type;
}

static ASTNode* BindTypeExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_TypeExpression);
    Type type = BindType(binder, syntax);
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_TypeExpression, binder->symbolTable, syntax);
    result->type = type;
    return result;
}

static ASTNode* BindTypeCastExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_TypeCastExpression);
    ASTNode* expression = BindExpression(binder, syntax->typeCastExpr.expression);
    Type targetType = BindType(binder, syntax->typeCastExpr.targetTypeExpression);
    TypeConversionResult conversion = CanConvertTypeFromTo(expression->type, targetType);
    if (conversion == TypeConversionResult_NonConvertible) {
        ReportError(TokenGetLocation(syntax->typeCastExpr.asKeyword), "Cast from type '%s' to type '%s' is impossible", TypeGetText(expression->type).cstr, TypeGetText(targetType).cstr);
    }
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_CastExpression, binder->symbolTable, syntax);
    result->type = targetType;
    result->left = expression;
    return result;
}

static ASTNode* BindSizeOfExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_SizeOfExpression);
    ASTNode* typeExpr = BindTypeExpression(binder, syntax->sizeofExpr.typeExpression);
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_SizeOfExpression, binder->symbolTable, syntax);
    result->type = TypeCreatePrimitive(TypeKind_PrimitiveInt);
    result->left = typeExpr;
    result->isRValue = true;
    return result;
}

static ASTNode* BindNullLiteralExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_NullLiteralExpression);
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_NullLiteral, binder->symbolTable, syntax);
    result->isRValue = true;
    result->type = TypeCreate(TypeKind_PrimitiveNull, 1, StringCreateEmpty());
    return result;
}

static ASTNode* BindCharacterLiteralExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_CharacterLiteralExpression);
    SyntaxToken literal = syntax->characterLiteralExpr.characterLiteral;
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_CharacterLiteral, binder->symbolTable, syntax);
    result->isRValue = true;
    result->intvalue = literal.intvalue;
    result->stringvalue = literal.stringValueWithoutQuotes;
    result->type = TypeCreatePrimitive(TypeKind_PrimitiveChar);
    return result;
}

static ASTNode* BindStringLiteralExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_StringLiteralExpression);
    String stringValueWithoutQuotes = StringCreateEmpty();
    for (int32 index = 0; index < syntax->stringLiteralExpr.stringLiteralTokens.count; index += 1) {
        SyntaxToken next = syntax->stringLiteralExpr.stringLiteralTokens.nodes[index]->token;
        stringValueWithoutQuotes = StringAppend(stringValueWithoutQuotes, next.stringValueWithoutQuotes);
    }
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_StringLiteral, binder->symbolTable, syntax);
    result->isRValue = true;
    result->stringvalue = stringValueWithoutQuotes;
    result->type = TypeCreate(TypeKind_PrimitiveChar, 1, StringCreateEmpty());
    return result;
}

static ASTNode* BindBoolLiteralExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_BoolLiteralExpression);
    SyntaxToken literal = syntax->boolLiteralExpr.boolLiteral;
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_BoolLiteral, binder->symbolTable, syntax);
    result->isRValue = true;
    result->intvalue = literal.kind == SyntaxKind_TrueKeyword ? 1 : 0;
    result->type = TypeCreatePrimitive(TypeKind_PrimitiveBool);
    return result;
}

static ASTNode* BindIntegerLiteralExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_IntegerLiteralExpression);
    SyntaxToken literal = syntax->integerLiteralExpr.integerLiteral;
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_IntegerLiteral, binder->symbolTable, syntax);
    result->isRValue = true;
    result->intvalue = literal.intvalue;
    if (CHAR_MIN <= literal.intvalue && literal.intvalue <= CHAR_MAX) {
        result->type = TypeCreatePrimitive(TypeKind_PrimitiveByte);
    } else {
        if (SHRT_MIN <= literal.intvalue && literal.intvalue <= SHRT_MAX) {
            result->type = TypeCreatePrimitive(TypeKind_PrimitiveShort);
        } else {
            if (INT_MIN <= literal.intvalue && literal.intvalue <= INT_MAX) {
                result->type = TypeCreatePrimitive(TypeKind_PrimitiveInt);
            } else {
                result->type = TypeCreatePrimitive(TypeKind_PrimitiveLong);
            }
        }
    }
    return result;
}

static ASTNode* BindEnumValueLiteralExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_EnumValueLiteralExpression);
    SyntaxToken enumIdentifier = syntax->enumLiteralExpr.enumIdentifier;
    SyntaxToken valueIdentifier = syntax->enumLiteralExpr.valueIdentifier;
    String enumText = TokenGetText(enumIdentifier);
    Symbol* enumSymbol = GetSymbol(binder->symbolTable, enumText);
    if (enumSymbol == NULL) {
        ReportError(TokenGetLocation(enumIdentifier), "Undeclared identifier '%s'", enumText.cstr);
    }
    if (enumSymbol->kind != SymbolKind_Enum) {
        ReportError(TokenGetLocation(enumIdentifier), "Identifier '%s' is not an enum", enumText.cstr);
    }
    String valueText = TokenGetText(valueIdentifier);
    Symbol* valueSymbol = GetSymbol(enumSymbol->membersSymbolTable, valueText);
    if (valueSymbol == NULL) {
        ReportError(TokenGetLocation(enumIdentifier), "Identifier '%s' is not a member of enum '%s'", valueText.cstr, enumText.cstr);
    }
    assert(valueSymbol->kind == SymbolKind_Enumvalue);
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_EnumValueLiteral, binder->symbolTable, syntax);
    result->isRValue = true;
    result->symbol = valueSymbol;
    result->type = valueSymbol->type;
    return result;
}

static ASTNode* BindArrayLiteralExpression(Binder* binder, Symbol* arraySymbol, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_ArrayLiteralExpression);
    assert(arraySymbol->type.isArray);
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_ArrayLiteral, binder->symbolTable, syntax);
    Type arrayElemType = GetElementTypeForArrayType(arraySymbol->type);
    for (int32 index = 0; index < syntax->arrayLiteralExpr.elemsWithSeparators.count; index += 2) {
        SyntaxNode* expression = syntax->arrayLiteralExpr.elemsWithSeparators.nodes[index];
        ASTNode* boundExpression = BindExpression(binder, expression);
        TypeConversionResult conversion = CanConvertTypeFromTo(boundExpression->type, arrayElemType);
        if (conversion == TypeConversionResult_NonConvertible || conversion == TypeConversionResult_ExplicitlyConvertible) {
            ReportError(TokenGetLocation(expression->token), "Cannot convert type '%s' of element %d in array initializer to array type '%s'", TypeGetText(boundExpression->type).cstr, index / 2 + 1, TypeGetText(arrayElemType).cstr);
        }
        ASTNodeArrayPush(&result->children, boundExpression);
    }
    int32 elementCount = result->children.count;
    SyntaxToken leftBrace = syntax->arrayLiteralExpr.leftBrace;
    if (arraySymbol->type.arrayElementCount == -1) {
        arraySymbol->type.arrayElementCount = elementCount;
    }
    if (elementCount == 0) {
        ReportError(TokenGetLocation(leftBrace), "Element count cannot be zero in array initializer of array '%s'", arraySymbol->name.cstr);
    }
    if (arraySymbol->type.arrayElementCount != elementCount) {
        ReportError(TokenGetLocation(leftBrace), "Element count %d of array initializer does not match element count %d of array '%s'", elementCount, arraySymbol->type.arrayElementCount, arraySymbol->name.cstr);
    }
    result->isRValue = true;
    return result;
}

static ASTNode* BindNameExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_NameExpression);
    SyntaxToken identifier = syntax->nameExpr.identifier;
    String identifierText = TokenGetText(identifier);
    Symbol* symbol = GetSymbol(binder->symbolTable, identifierText);
    if (symbol == NULL) {
        ReportError(TokenGetLocation(identifier), "Undeclared identifier '%s'", identifierText.cstr);
    }
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_NameExpression, binder->symbolTable, syntax);
    result->symbol = symbol;
    result->type = symbol->type;
    return result;
}

static ASTNode* BindParenthesizedExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_ParenthesizedExpression);
    ASTNode* inner = BindExpression(binder, syntax->parenthesizedExpr.expression);
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_ParenthesizedExpression, binder->symbolTable, syntax);
    result->type = inner->type;
    result->left = inner;
    return result;
}

static ASTNode* BindFunctionCallExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_FuncCallExpression);
    ASTNode* left = BindExpression(binder, syntax->funcCallExpr.func);
    SyntaxToken leftParen = syntax->funcCallExpr.leftParen;
    Symbol* funcSymbol = left->symbol;
    if (funcSymbol == NULL) {
        ReportError(TokenGetLocation(leftParen), "Expression left of '%s' is not a known symbol", TokenGetText(leftParen));
    }
    if (funcSymbol->kind != SymbolKind_Function) {
        ReportError(TokenGetLocation(leftParen), "Identifier '%s' is not a callable function", funcSymbol->name.cstr);
    }
    ASTNodeArray argumentList = ASTNodeArrayCreate();
    for (int32 index = 0; index < syntax->funcCallExpr.argumentsWithSeparators.count; index += 2) {
        SyntaxNode* arg = syntax->funcCallExpr.argumentsWithSeparators.nodes[index];
        ASTNode* boundArg = BindExpression(binder, arg);
        ASTNodeArrayPush(&argumentList, boundArg);
    }
    if (funcSymbol->isVariadric) {
        if (argumentList.count < funcSymbol->membersSymbolTable->count) {
            ReportError(TokenGetLocation(leftParen), "Function '%s' expects at least %d arguments but %d arguments were provided", funcSymbol->name.cstr, funcSymbol->membersSymbolTable->count, argumentList.count);
        }
    } else {
        if (argumentList.count != funcSymbol->membersSymbolTable->count) {
            ReportError(TokenGetLocation(leftParen), "Function '%s' expects %d arguments but %d arguments were provided", funcSymbol->name.cstr, funcSymbol->membersSymbolTable->count, argumentList.count);
        }
    }
    for (int32 argumentIndex = 0; argumentIndex < funcSymbol->membersSymbolTable->count; argumentIndex += 1) {
        Type argumentType = argumentList.nodes[argumentIndex]->type;
        Type expectedType = funcSymbol->membersSymbolTable->symbols[argumentIndex]->type;
        TypeConversionResult conversion = CanConvertTypeFromTo(argumentType, expectedType);
        if (conversion == TypeConversionResult_NonConvertible) {
            ReportError(TokenGetLocation(leftParen), "Passed incompatible type '%s' for argument %d to function '%s' - expected type '%s'", TypeGetText(argumentType).cstr, argumentIndex + 1, funcSymbol->name.cstr, TypeGetText(expectedType).cstr);
        }
        if (conversion == TypeConversionResult_ExplicitlyConvertible) {
            ReportError(TokenGetLocation(leftParen), "Cannot implicitly convert type '%s' of argument %d  to expected type '%s' in function call of '%s'", TypeGetText(argumentType).cstr, argumentIndex + 1, TypeGetText(expectedType).cstr, funcSymbol->name.cstr);
        }
    }
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_FunccallExpression, binder->symbolTable, syntax);
    result->symbol = funcSymbol;
    result->type = funcSymbol->type;
    result->children = argumentList;
    return result;
}

static ASTNode* BindArrayIndexingExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_ArrayIndexExpression);
    SyntaxToken leftBracket = syntax->arrayIndexExpr.leftBracket;
    ASTNode* left = BindExpression(binder, syntax->arrayIndexExpr.arr);
    ASTNode* index = BindExpression(binder, syntax->arrayIndexExpr.indexExpression);
    if (!IsNumberType(index->type)) {
        ReportError(TokenGetLocation(leftBracket), "Array index after '%s' must be number type", TokenKindToString(leftBracket.kind).cstr);
    }
    if (left->symbol == NULL || TypeGetIndirectionLevel(left->symbol->type) == 0) {
        ReportError(TokenGetLocation(leftBracket), "Left hand side of array index operator '%s' is not a known array or pointer", TokenKindToString(leftBracket.kind).cstr);
    }
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_Arrayindexing, binder->symbolTable, syntax);
    result->type = left->symbol->type;
    if (result->type.isArray) {
        result->type.isArray = false;
    } else {
        result->type = GetBaseTypeForPointerType(result->type);
    }
    result->left = left;
    result->right = index;
    return result;
}

static ASTNode* BindMemberAccessExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_MemberAccessExpression);
    ASTNode* container = BindExpression(binder, syntax->memberAccessExpr.container);
    SyntaxToken accessorToken = syntax->memberAccessExpr.accessToken;
    if (container->type.kind != TypeKind_Struct && container->type.kind != TypeKind_Union) {
        ReportError(TokenGetLocation(accessorToken), "Attempt to access member of non union or struct identifier '%s'", container->symbol->name.cstr);
    }
    Symbol* containerSymbol = GetSymbol(binder->symbolTable, container->type.name);
    assert(containerSymbol != NULL);
    if (containerSymbol->kind != SymbolKind_Struct && containerSymbol->kind != SymbolKind_Union) {
        ReportError(TokenGetLocation(accessorToken), "Attempt to access member of non union or struct identifier '%s'", containerSymbol->name.cstr);
    }
    if (!containerSymbol->alreadyDefined) {
        ReportError(TokenGetLocation(accessorToken), "Attempt to access member of forward declared but undefined union or struct '%s'", containerSymbol->name.cstr);
    }
    bool isArrow = accessorToken.kind == SyntaxKind_ArrowToken;
    if (isArrow && TypeGetIndirectionLevel(container->type) == 0) {
        ReportError(TokenGetLocation(accessorToken), "Member access of '%s' with '->' is only allowed for pointer types", containerSymbol->name.cstr);
    }
    if (!isArrow && TypeGetIndirectionLevel(container->type) > 0) {
        ReportError(TokenGetLocation(accessorToken), "Member access of '%s' with '.' is only allowed for non-pointer types", containerSymbol->name.cstr);
    }
    SyntaxToken memberIdentifier = syntax->memberAccessExpr.memberIdentifier;
    String identifierText = TokenGetText(memberIdentifier);
    Symbol* memberSymbol = GetSymbol(containerSymbol->membersSymbolTable, identifierText);
    if (memberSymbol == NULL) {
        ReportError(TokenGetLocation(memberIdentifier), "Undeclared struct or union member '%s'", identifierText.cstr);
    }
    assert(memberSymbol->kind == SymbolKind_Member);
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_Memberaccess, binder->symbolTable, syntax);
    result->symbol = memberSymbol;
    result->type = memberSymbol->type;
    result->left = container;
    return result;
}

static ASTNode* BindUnaryExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_UnaryExpression);
    ASTNode* operand = BindExpression(binder, syntax->unaryExpr.operand);
    SyntaxToken operatorToken = syntax->unaryExpr.operatorToken;
    UnaryOperator op = GetUnaryOperationForToken(operatorToken, operand->type);
    if (op.operandMustBeLValue && operand->isRValue) {
        ReportError(TokenGetLocation(operatorToken), "Operand of operator '%s' must be an storage location", TokenKindToString(operatorToken.kind).cstr);
    }
    ASTNode* result = ASTNodeCreate2(op.operatorKind, binder->symbolTable, syntax);
    result->isRValue = op.resultIsRValue;
    result->type = op.resultType;
    result->left = operand;
    return result;
}

static ASTNode* BindBinaryExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_BinaryExpression);
    ASTNode* left = BindExpression(binder, syntax->binaryExpr.left);
    ASTNode* right = BindExpression(binder, syntax->binaryExpr.right);
    SyntaxToken operatorToken = syntax->binaryExpr.operatorToken;
    BinaryOperator op = GetBinaryOperationForToken(operatorToken, left->type, right->type);
    if (op.leftMustBeLValue && left->isRValue) {
        ReportError(TokenGetLocation(operatorToken), "Left argument of operator '%s' must be an storage location", TokenKindToString(operatorToken.kind).cstr);
    }
    if (op.rightMustBeLValue && right->isRValue) {
        ReportError(TokenGetLocation(operatorToken), "Right argument of operator '%s' must be a storage location", TokenKindToString(operatorToken.kind).cstr);
    }
    ASTNode* result = ASTNodeCreate2(op.operatorKind, binder->symbolTable, syntax);
    result->isRValue = op.resultIsRValue;
    result->type = op.resultType;
    result->left = left;
    result->right = right;
    return result;
}

static ASTNode* BindTernaryConditionalExpression(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_TernaryConditionalExpression);
    ASTNode* condition = BindExpression(binder, syntax->ternaryConditionalExpr.conditionExpression);
    ASTNode* thenExpression = BindExpression(binder, syntax->ternaryConditionalExpr.thenExpression);
    ASTNode* elseExpression = BindExpression(binder, syntax->ternaryConditionalExpr.elseExpression);
    Type type = GetTypeThatFitsBothTypes(thenExpression->type, elseExpression->type);
    if (IsVoidType(type)) {
        ReportError(TokenGetLocation(syntax->ternaryConditionalExpr.questionmark), "Incompatible expression types in ternary operator - then branch: '%s', else branch: '%s'", TypeGetText(thenExpression->type).cstr, TypeGetText(elseExpression->type).cstr);
    }
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_TernaryConditionalExpression, binder->symbolTable, syntax);
    result->left = condition;
    result->right = thenExpression;
    result->extra1 = elseExpression;
    result->type = type;
    result->isRValue = true;
    return result;
}

static ASTNode* BindExpression(Binder* binder, SyntaxNode* syntax) {
    ASTNode* result = NULL;
    switch (syntax->kind) {
        case SyntaxKind_UnaryExpression: {
            result = BindUnaryExpression(binder, syntax);
            break;
        }
        case SyntaxKind_BinaryExpression: {
            result = BindBinaryExpression(binder, syntax);
            break;
        }
        case SyntaxKind_FuncCallExpression: {
            result = BindFunctionCallExpression(binder, syntax);
            break;
        }
        case SyntaxKind_ArrayIndexExpression: {
            result = BindArrayIndexingExpression(binder, syntax);
            break;
        }
        case SyntaxKind_MemberAccessExpression: {
            result = BindMemberAccessExpression(binder, syntax);
            break;
        }
        case SyntaxKind_TypeCastExpression: {
            result = BindTypeCastExpression(binder, syntax);
            break;
        }
        case SyntaxKind_ParenthesizedExpression: {
            result = BindParenthesizedExpression(binder, syntax);
            break;
        }
        case SyntaxKind_TernaryConditionalExpression: {
            result = BindTernaryConditionalExpression(binder, syntax);
            break;
        }
        case SyntaxKind_SizeOfExpression: {
            result = BindSizeOfExpression(binder, syntax);
            break;
        }
        case SyntaxKind_NameExpression: {
            result = BindNameExpression(binder, syntax);
            break;
        }
        case SyntaxKind_TypeExpression: {
            result = BindTypeExpression(binder, syntax);
            break;
        }
        case SyntaxKind_NullLiteralExpression: {
            result = BindNullLiteralExpression(binder, syntax);
            break;
        }
        case SyntaxKind_IntegerLiteralExpression: {
            result = BindIntegerLiteralExpression(binder, syntax);
            break;
        }
        case SyntaxKind_CharacterLiteralExpression: {
            result = BindCharacterLiteralExpression(binder, syntax);
            break;
        }
        case SyntaxKind_BoolLiteralExpression: {
            result = BindBoolLiteralExpression(binder, syntax);
            break;
        }
        case SyntaxKind_StringLiteralExpression: {
            result = BindStringLiteralExpression(binder, syntax);
            break;
        }
        case SyntaxKind_EnumValueLiteralExpression: {
            result = BindEnumValueLiteralExpression(binder, syntax);
            break;
        }
        default: {
            assert(false && "Unexpected expression in binder");
        }
    }
    if (result->type.isArray) {
        result->isRValue = true;
    }
    return result;
}

static ASTNode* BindExpressionStatement(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_ExpressionStatement);
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_ExpressionStatement, binder->symbolTable, syntax);
    result->left = BindExpression(binder, syntax->expressionStmt.expression);
    return result;
}

static ASTNode* BindVariableDefinitionStatement(Binder* binder, SyntaxNode* syntax, SymbolScopeKind symbolScopeKind) {
    assert(syntax->kind == SyntaxKind_VariableDeclarationStatement);
    SyntaxToken identifier = syntax->variableDeclarationStmt.identifier;
    bool isLocalPersist = syntax->variableDeclarationStmt.letKeyword.kind == SyntaxKind_LetLocalPersistKeyword;
    if (isLocalPersist) {
        if (symbolScopeKind != SymbolScopeKind_Local) {
            ReportError(TokenGetLocation(identifier), "Cannot mark global variable '%s' as local persistent", TokenGetText(identifier).cstr);
        }
        symbolScopeKind = SymbolScopeKind_LocalPersist;
    }
    Type type = BindType(binder, syntax->variableDeclarationStmt.typeExpression);
    Symbol* varSymbol = AddSymbol(binder->symbolTable, TokenGetText(identifier), SymbolKind_Variable, symbolScopeKind, type);
    if (varSymbol == NULL) {
        ReportError(TokenGetLocation(identifier), "Symbol was '%s' already declared in current scope", TokenGetText(identifier).cstr);
    }
    if (IsVoidType(type)) {
        ReportError(TokenGetLocation(identifier), "'void' not allowed as variables '%s' storage type", TokenGetText(identifier).cstr);
    }
    if (syntax->variableDeclarationStmt.leftBracket.kind == SyntaxKind_LeftBracketToken) {
        int64 arrayElementCount = -1;
        bool arrayElementCountDefined = false;
        if (syntax->variableDeclarationStmt.arraySizeLiteral.kind == SyntaxKind_IntegerLiteralToken) {
            arrayElementCount = syntax->variableDeclarationStmt.arraySizeLiteral.intvalue;
            arrayElementCountDefined = true;
        }
        if (arrayElementCountDefined && arrayElementCount <= 0) {
            ReportError(TokenGetLocation(identifier), "Array size must be greater than zero for '%s'", TokenGetText(identifier).cstr);
        }
        varSymbol->type.isArray = true;
        varSymbol->type.arrayElementCount = arrayElementCount;
    }
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_VariableDeclarationStatement, binder->symbolTable, syntax);
    result->symbol = varSymbol;
    if (syntax->variableDeclarationStmt.initializerExpression != NULL) {
        ASTNode* boundInitializer = NULL;
        if (result->symbol->type.isArray) {
            boundInitializer = BindArrayLiteralExpression(binder, result->symbol, syntax->variableDeclarationStmt.initializerExpression);
        } else {
            boundInitializer = BindExpression(binder, syntax->variableDeclarationStmt.initializerExpression);
        }
        result->left = boundInitializer;
    }
    return result;
}

static ASTNode* BindIfStatement(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_IfStatement);
    assert(binder->currentFunctionSymbol != NULL);
    ASTNode* boundCondition = BindExpression(binder, syntax->ifStmt.condition);
    ASTNode* boundThenBranch = BindStatement(binder, syntax->ifStmt.thenBlock);
    boundThenBranch = _WrapInBlockStatementIfNecessary(binder, boundThenBranch);
    ASTNode* boundElseBranch = NULL;
    if (syntax->ifStmt.elseBlock != NULL) {
        boundElseBranch = BindStatement(binder, syntax->ifStmt.elseBlock);
        boundElseBranch = _WrapInBlockStatementIfNecessary(binder, boundElseBranch);
    }
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_IfStatement, binder->symbolTable, syntax);
    result->left = boundCondition;
    result->right = boundThenBranch;
    result->extra1 = boundElseBranch;
    return result;
}

static ASTNode* BindWhileStatement(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_WhileStatement);
    assert(binder->currentFunctionSymbol != NULL);
    ASTNode* boundCondition = BindExpression(binder, syntax->whileStmt.condition);
    binder->loopLevel += 1;
    ASTNode* boundBody = BindStatement(binder, syntax->whileStmt.body);
    boundBody = _WrapInBlockStatementIfNecessary(binder, boundBody);
    binder->loopLevel -= 1;
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_WhileStatement, binder->symbolTable, syntax);
    result->left = boundCondition;
    result->right = boundBody;
    return result;
}

static ASTNode* BindDoWhileStatement(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_DoWhileStatement);
    assert(binder->currentFunctionSymbol != NULL);
    binder->loopLevel += 1;
    ASTNode* boundBody = BindStatement(binder, syntax->doWhileStmt.body);
    boundBody = _WrapInBlockStatementIfNecessary(binder, boundBody);
    binder->loopLevel -= 1;
    ASTNode* boundCondition = BindExpression(binder, syntax->doWhileStmt.condition);
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_DoWhileStatement, binder->symbolTable, syntax);
    result->left = boundCondition;
    result->right = boundBody;
    return result;
}

static ASTNode* BindForStatement(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_ForStatement);
    assert(binder->currentFunctionSymbol != NULL);
    binder->symbolTable = SymbolTableCreate(binder->symbolTable);
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_ForStatement, binder->symbolTable, syntax);
    ASTNode* boundInitializer = NULL;
    if (syntax->forStmt.initializerStatement->kind == SyntaxKind_VariableDeclarationStatement) {
        boundInitializer = BindVariableDefinitionStatement(binder, syntax->forStmt.initializerStatement, SymbolScopeKind_Local);
    } else {
        boundInitializer = BindExpressionStatement(binder, syntax->forStmt.initializerStatement);
    }
    ASTNode* boundCondition = BindExpressionStatement(binder, syntax->forStmt.conditionStatement);
    ASTNode* boundIncrementExpr = BindExpression(binder, syntax->forStmt.incrementExpression);
    binder->loopLevel += 1;
    ASTNode* boundBody = BindStatement(binder, syntax->forStmt.body);
    boundBody = _WrapInBlockStatementIfNecessary(binder, boundBody);
    binder->loopLevel -= 1;
    binder->symbolTable = binder->symbolTable->parent;
    result->left = boundInitializer;
    result->right = boundCondition;
    result->extra1 = boundIncrementExpr;
    result->extra2 = boundBody;
    return result;
}

static ASTNode* BindReturnStatement(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_ReturnStatement);
    assert(binder->currentFunctionSymbol != NULL);
    if (binder->currentFunctionSymbol == NULL) {
        ReportError(TokenGetLocation(syntax->returnStmt.returnKeyword), "Invalid 'return' statement found outside of function definition");
    }
    Type functionReturnType = binder->currentFunctionSymbol->type;
    if (IsVoidType(functionReturnType) && syntax->returnStmt.returnExpression != NULL) {
        ReportError(TokenGetLocation(syntax->returnStmt.returnKeyword), "Invalid return expression in void function");
    }
    if (!IsVoidType(functionReturnType) && syntax->returnStmt.returnExpression == NULL) {
        ReportError(TokenGetLocation(syntax->returnStmt.returnKeyword), "Must return expression in non-void function");
    }
    ASTNode* boundExpression = NULL;
    if (syntax->returnStmt.returnExpression != NULL) {
        boundExpression = BindExpression(binder, syntax->returnStmt.returnExpression);
        TypeConversionResult conversion = CanConvertTypeFromTo(boundExpression->type, functionReturnType);
        if (conversion == TypeConversionResult_NonConvertible) {
            ReportError(TokenGetLocation(syntax->returnStmt.returnKeyword), "Incompatible types for return expression '%s'", TokenKindToString(syntax->returnStmt.returnKeyword.kind).cstr);
        }
        if (conversion == TypeConversionResult_ExplicitlyConvertible) {
            ReportError(TokenGetLocation(syntax->returnStmt.returnKeyword), "Types cannot be implicitly converted for return expression '%s'", TokenKindToString(syntax->returnStmt.returnKeyword.kind).cstr);
        }
    }
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_ReturnStatement, binder->symbolTable, syntax);
    result->left = boundExpression;
    return result;
}

static ASTNode* BindBreakStatement(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_BreakStatement);
    assert(binder->currentFunctionSymbol != NULL);
    if (binder->loopLevel == 0 && binder->switchCaseLevel == 0) {
        ReportError(TokenGetLocation(syntax->breakStmt.breakKeyword), "Invalid 'break' statement found outside of loop or switch-case definition");
    }
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_BreakStatement, binder->symbolTable, syntax);
    return result;
}

static ASTNode* BindContinueStatement(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_ContinueStatement);
    assert(binder->currentFunctionSymbol != NULL);
    if (binder->loopLevel == 0) {
        ReportError(TokenGetLocation(syntax->continueStmt.continueKeyword), "Invalid 'continue' statement found outside of loop definition");
    }
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_ContinueStatement, binder->symbolTable, syntax);
    return result;
}

static ASTNode* BindBlockStatement(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_BlockStatement);
    assert(binder->currentFunctionSymbol != NULL);
    binder->symbolTable = SymbolTableCreate(binder->symbolTable);
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_BlockStatement, binder->symbolTable, syntax);
    for (int32 index = 0; index < syntax->blockStmt.statements.count; index += 1) {
        SyntaxNode* statement = syntax->blockStmt.statements.nodes[index];
        ASTNode* boundStatement = BindStatement(binder, statement);
        ASTNodeArrayPush(&result->children, boundStatement);
    }
    binder->symbolTable = binder->symbolTable->parent;
    return _FlattenBlockStatementIfNecessary(binder, result);
}

static ASTNode* BindCaseStatement(Binder* binder, ASTNode* switchExpression, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_CaseStatement || syntax->kind == SyntaxKind_DefaultStatement);
    assert(binder->currentFunctionSymbol != NULL);
    assert(binder->switchCaseLevel != 0);
    bool isDefault = syntax->kind == SyntaxKind_DefaultStatement;
    ASTNode* caseExpression = NULL;
    if (syntax->kind == SyntaxKind_CaseStatement) {
        caseExpression = BindExpression(binder, syntax->caseStmt.literalExpression);
        if (caseExpression->kind != ASTNodeKind_IntegerLiteral && caseExpression->kind != ASTNodeKind_StringLiteral && caseExpression->kind != ASTNodeKind_CharacterLiteral && caseExpression->kind != ASTNodeKind_EnumValueLiteral) {
            ReportError(TokenGetLocation(caseExpression->token), "Expected literal in case label but got '%s'", TokenKindToString(caseExpression->token.kind).cstr);
        }
        TypeConversionResult conversion = CanConvertTypeFromTo(caseExpression->type, switchExpression->type);
        if (conversion != TypeConversionResult_Identical && conversion != TypeConversionResult_ImplictlyConvertible) {
            ReportError(TokenGetLocation(caseExpression->token), "Cannot convert type '%s' of case label literal '%s' to its switch expression type '%s'", TypeGetText(caseExpression->type).cstr, TokenGetText(caseExpression->token).cstr, TypeGetText(switchExpression->type).cstr);
        }
    }
    ASTNode* body = BindBlockStatement(binder, isDefault ? syntax->defaultStmt.body : syntax->caseStmt.body);
    if (body->children.count == 0) {
        body = NULL;
    }
    ASTNode* result = ASTNodeCreate2(isDefault ? ASTNodeKind_DefaultStatement : ASTNodeKind_CaseStatement, binder->symbolTable, syntax);
    result->left = body;
    result->right = caseExpression;
    return result;
}

static ASTNode* BindSwitchStatement(Binder* binder, SyntaxNode* syntax) {
    assert(syntax->kind == SyntaxKind_SwitchStatement);
    assert(binder->currentFunctionSymbol != NULL);
    ASTNode* switchExpression = BindExpression(binder, syntax->switchStmt.switchExpression);
    binder->switchCaseLevel += 1;
    int32 defaultStatementEncountered = false;
    ASTNodeArray caseStatements = ASTNodeArrayCreate();
    for (int32 index = 0; index < syntax->switchStmt.caseStatements.count; index += 1) {
        SyntaxNode* caseStatement = syntax->switchStmt.caseStatements.nodes[index];
        ASTNode* boundCaseStatement = BindCaseStatement(binder, switchExpression, caseStatement);
        if (defaultStatementEncountered) {
            ReportError(TokenGetLocation(caseStatement->caseStmt.caseKeyword), "Unexpected case statement after default statement was already defined");
        }
        if (caseStatement->kind == SyntaxKind_DefaultStatement) {
            defaultStatementEncountered = true;
        }
        ASTNodeArrayPush(&caseStatements, boundCaseStatement);
    }
    binder->switchCaseLevel -= 1;
    if (caseStatements.count == 0) {
        ReportError(TokenGetLocation(syntax->switchStmt.switchKeyword), "Empty switch statements are not allowed");
    }
    for (int32 index = 0; index < caseStatements.count; index += 1) {
        ASTNode* a = caseStatements.nodes[index];
        for (int32 inner = index + 1; inner < caseStatements.count; inner += 1) {
            ASTNode* b = caseStatements.nodes[inner];
            if (a->right && b->right && AreLiteralsEqual(a->right, b->right)) {
                ReportError(TokenGetLocation(b->token), "Duplicate switch case literal '%s'", TokenGetText(b->right->token).cstr);
            }
        }
    }
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_SwitchStatement, binder->symbolTable, syntax);
    result->left = switchExpression;
    result->children = caseStatements;
    return result;
}

static ASTNode* BindStatement(Binder* binder, SyntaxNode* syntax) {
    assert(binder->currentFunctionSymbol != NULL);
    switch (syntax->kind) {
        case SyntaxKind_BlockStatement: {
            return BindBlockStatement(binder, syntax);
        }
        case SyntaxKind_IfStatement: {
            return BindIfStatement(binder, syntax);
        }
        case SyntaxKind_DoWhileStatement: {
            return BindDoWhileStatement(binder, syntax);
        }
        case SyntaxKind_WhileStatement: {
            return BindWhileStatement(binder, syntax);
        }
        case SyntaxKind_ForStatement: {
            return BindForStatement(binder, syntax);
        }
        case SyntaxKind_ReturnStatement: {
            return BindReturnStatement(binder, syntax);
        }
        case SyntaxKind_BreakStatement: {
            return BindBreakStatement(binder, syntax);
        }
        case SyntaxKind_ContinueStatement: {
            return BindContinueStatement(binder, syntax);
        }
        case SyntaxKind_SwitchStatement: {
            return BindSwitchStatement(binder, syntax);
        }
        case SyntaxKind_VariableDeclarationStatement: {
            return BindVariableDefinitionStatement(binder, syntax, SymbolScopeKind_Local);
        }
        case SyntaxKind_ExpressionStatement: {
            return BindExpressionStatement(binder, syntax);
        }
        default: {
            assert(false && "Unexpected statement in binder");
        }
    }
    exit(1);
}

static ASTNode* BindGlobalVariableDefinitionStatement(Binder* binder, SyntaxNode* syntax) {
    assert(binder->currentFunctionSymbol == NULL);
    assert(syntax->kind == SyntaxKind_GlobalVariableDeclarationStatement);
    bool isExternal = syntax->globalVariableStmt.externKeyword.kind == SyntaxKind_ExternKeyword;
    SymbolScopeKind symbolScopeKind = isExternal ? SymbolScopeKind_Extern : SymbolScopeKind_Global;
    return BindVariableDefinitionStatement(binder, syntax->globalVariableStmt.variableDeclarationStatement, symbolScopeKind);
}

static ASTNode* BindStructOrUnionDefinitionStatement(Binder* binder, SyntaxNode* syntax) {
    assert(binder->currentFunctionSymbol == NULL);
    assert(syntax->kind == SyntaxKind_StructOrUnionDeclarationStatement || syntax->kind == SyntaxKind_StructOrUniontDefinitionStatement);
    bool isExternal = syntax->structOrUnionDeclarationStmt.externKeyword.kind == SyntaxKind_ExternKeyword;
    SymbolScopeKind symbolScopeKind = isExternal ? SymbolScopeKind_Extern : SymbolScopeKind_Global;
    bool isUnion = syntax->structOrUnionDeclarationStmt.structOrUnionKeyword.kind == SyntaxKind_UnionKeyword;
    SyntaxToken identifier = syntax->structOrUnionDeclarationStmt.identifier;
    String name = TokenGetText(identifier);
    Symbol* structSymbol = GetSymbol(binder->symbolTable, name);
    if (structSymbol != NULL) {
        if (isUnion && structSymbol->kind != SymbolKind_Union) {
            ReportError(TokenGetLocation(identifier), "Another symbol with the same name '%s' but different type was already declared in current scope", TokenGetText(identifier).cstr);
        }
        if (!isUnion && structSymbol->kind != SymbolKind_Struct) {
            ReportError(TokenGetLocation(identifier), "Another symbol with the same name '%s' but different type was already declared in current scope", TokenGetText(identifier).cstr);
        }
        if (structSymbol->scopeKind != symbolScopeKind) {
            ReportError(TokenGetLocation(identifier), "Struct or union '%s was previously declared but with different scope attribute", TokenGetText(identifier).cstr);
        }
    }
    if (structSymbol == NULL) {
        Type type = TypeCreate(isUnion ? TypeKind_Union : TypeKind_Struct, 0, name);
        structSymbol = AddSymbol(binder->symbolTable, name, isUnion ? SymbolKind_Union : SymbolKind_Struct, symbolScopeKind, type);
    }
    if (syntax->kind == SyntaxKind_StructOrUnionDeclarationStatement) {
        ASTNode* result = ASTNodeCreate2(isUnion ? ASTNodeKind_UnionDeclarationStatement : ASTNodeKind_StructDeclarationStatement, binder->symbolTable, syntax);
        result->symbol = structSymbol;
        return result;
    } else {
        structSymbol->membersSymbolTable = SymbolTableCreate(binder->symbolTable);
        binder->symbolTable = structSymbol->membersSymbolTable;
        for (int32 index = 0; index < syntax->structOrUnionDefinitionStmt.memberDeclarationStatements.count; index += 1) {
            SyntaxNode* memberDeclaration = syntax->structOrUnionDefinitionStmt.memberDeclarationStatements.nodes[index];
            ASTNode* memberNode = BindVariableDefinitionStatement(binder, memberDeclaration, SymbolScopeKind_Local);
            memberNode->symbol->kind = SymbolKind_Member;
        }
        binder->symbolTable = binder->symbolTable->parent;
        if (structSymbol->membersSymbolTable->count == 0) {
            ReportError(TokenGetLocation(identifier), "Struct or union '%s' needs at least one member", name.cstr);
        }
        if (structSymbol->alreadyDefined) {
            ReportError(TokenGetLocation(identifier), "Duplicate struct or union definition of '%s'", name.cstr);
        }
        structSymbol->alreadyDefined = true;
        ASTNode* result = ASTNodeCreate2(isUnion ? ASTNodeKind_UnionDefinitionStatement : ASTNodeKind_StructDefinitionStatement, binder->symbolTable, syntax);
        result->symbol = structSymbol;
        return result;
    }
}

static ASTNode* BindEnumDefinitionStatement(Binder* binder, SyntaxNode* syntax) {
    assert(binder->currentFunctionSymbol == NULL);
    assert(syntax->kind == SyntaxKind_EnumDeclarationStatement || syntax->kind == SyntaxKind_EnumDefinitionStatement);
    bool isExternal = syntax->enumDeclarationStmt.externKeyword.kind == SyntaxKind_ExternKeyword;
    SymbolScopeKind symbolScopeKind = isExternal ? SymbolScopeKind_Extern : SymbolScopeKind_Global;
    SyntaxToken identifier = syntax->enumDeclarationStmt.identifier;
    String name = TokenGetText(identifier);
    if (binder->currentFunctionSymbol != NULL) {
        ReportError(TokenGetLocation(identifier), "Unexpected enum declaration of '%s' while already parsing function", name.cstr);
    }
    Symbol* enumSymbol = GetSymbol(binder->symbolTable, name);
    if (enumSymbol != NULL) {
        if (enumSymbol->kind != SymbolKind_Enum) {
            ReportError(TokenGetLocation(identifier), "Another symbol with the same name '%s' but different type was already declared in current scope", TokenGetText(identifier).cstr);
        }
        if (enumSymbol->scopeKind != symbolScopeKind) {
            ReportError(TokenGetLocation(identifier), "Enum '%s was previously declared but with different scope attribute", TokenGetText(identifier).cstr);
        }
    }
    if (enumSymbol == NULL) {
        Type type = TypeCreate(TypeKind_Enum, 0, name);
        enumSymbol = AddSymbol(binder->symbolTable, name, SymbolKind_Enum, symbolScopeKind, type);
    }
    if (syntax->kind == SyntaxKind_EnumDeclarationStatement) {
        ASTNode* result = ASTNodeCreate2(ASTNodeKind_EnumDeclarationStatement, binder->symbolTable, syntax);
        result->symbol = enumSymbol;
        return result;
    } else {
        enumSymbol->membersSymbolTable = SymbolTableCreate(binder->symbolTable);
        binder->symbolTable = enumSymbol->membersSymbolTable;
        int64 valueCounter = 0;
        Type memberType = TypeCreate(TypeKind_Enum, 0, enumSymbol->name);
        for (int32 index = 0; index < syntax->enumDefinitionStmt.memberClauses.count; index += 1) {
            SyntaxNode* memberClause = syntax->enumDefinitionStmt.memberClauses.nodes[index];
            String valueName = TokenGetText(memberClause->enumMember.identifier);
            Symbol* valueSymbol = AddSymbol(binder->symbolTable, valueName, SymbolKind_Enumvalue, SymbolScopeKind_Global, memberType);
            if (valueSymbol == NULL) {
                ReportError(TokenGetLocation(identifier), "Symbol was '%s' already declared in current scope", TokenGetText(identifier).cstr);
            }
            if (memberClause->enumMember.integerLiteral.kind == SyntaxKind_IntegerLiteralToken) {
                SyntaxToken valueToken = memberClause->enumMember.integerLiteral;
                if (valueToken.intvalue < valueCounter) {
                    ReportError(TokenGetLocation(valueToken), "Assigned value of enum value literal '%s' must chosen such that all enum values of '%s' are unique - chosen value '%lld' would lead to duplicates", TokenGetText(memberClause->enumMember.identifier).cstr, enumSymbol->name.cstr, valueToken.intvalue);
                }
                valueCounter = valueToken.intvalue;
            }
            valueSymbol->kind = SymbolKind_Enumvalue;
            valueSymbol->enumValue = valueCounter;
            valueCounter += 1;
        }
        binder->symbolTable = binder->symbolTable->parent;
        if (enumSymbol->membersSymbolTable->count == 0) {
            ReportError(TokenGetLocation(identifier), "Enum '%s' needs at least one member", name.cstr);
        }
        if (enumSymbol->alreadyDefined) {
            ReportError(TokenGetLocation(identifier), "Duplicate enum definition of '%s'", name.cstr);
        }
        enumSymbol->alreadyDefined = true;
        ASTNode* result = ASTNodeCreate2(ASTNodeKind_EnumDefinitionStatement, binder->symbolTable, syntax);
        result->symbol = enumSymbol;
        return result;
    }
}

static ASTNode* BindFunctionDefinitionStatement(Binder* binder, SyntaxNode* syntax) {
    assert(binder->currentFunctionSymbol == NULL);
    assert(syntax->kind == SyntaxKind_FunctionDeclarationStatement || syntax->kind == SyntaxKind_FunctionDefinitionStatement);
    Type returnType = BindType(binder, syntax->functionDeclarationStmt.returnType);
    SyntaxToken identifier = syntax->functionDeclarationStmt.identifier;
    bool isExternal = syntax->functionDeclarationStmt.externKeyword.kind == SyntaxKind_ExternKeyword;
    SymbolScopeKind symbolScopeKind = isExternal ? SymbolScopeKind_Extern : SymbolScopeKind_Global;
    Symbol* functionSymbol = GetSymbol(binder->symbolTable, TokenGetText(identifier));
    if (functionSymbol != NULL) {
        if (functionSymbol->kind != SymbolKind_Function) {
            ReportError(TokenGetLocation(identifier), "Another symbol with the same name '%s' but different type was already declared in current scope", TokenGetText(identifier).cstr);
        }
        if (functionSymbol->scopeKind != symbolScopeKind) {
            ReportError(TokenGetLocation(identifier), "Function '%s was previously declared but with different scope attribute", TokenGetText(identifier).cstr);
        }
    }
    if (functionSymbol == NULL) {
        functionSymbol = AddSymbol(binder->symbolTable, TokenGetText(identifier), SymbolKind_Function, symbolScopeKind, returnType);
    }
    SymbolTable* functionParamsSymbolTable = SymbolTableCreate(binder->symbolTable);
    binder->symbolTable = functionParamsSymbolTable;
    bool isVariadric = false;
    for (int32 index = 0; index < syntax->functionDeclarationStmt.params.count; index += 1) {
        SyntaxNode* param = syntax->functionDeclarationStmt.params.nodes[index];
        if (param->kind == SyntaxKind_DotDotDotToken) {
            isVariadric = true;
            assert(index == syntax->functionDeclarationStmt.params.count - 1 && "'...' must be last param");
            break;
        }
        ASTNode* paramNode = BindVariableDefinitionStatement(binder, param, SymbolScopeKind_Local);
        paramNode->symbol->kind = SymbolKind_Parameter;
        if (param->variableDeclarationStmt.terminatorToken.kind != SyntaxKind_CommaToken) {
            assert(index == syntax->functionDeclarationStmt.params.count - 1 && "param omitting ',' must be last param");
            break;
        }
    }
    binder->symbolTable = binder->symbolTable->parent;
    if (functionSymbol->membersSymbolTable != NULL) {
        if (!TypesIdentical(returnType, functionSymbol->type)) {
            ReportError(TokenGetLocation(identifier), "Return type of function '%s' does not match return type of a previous declaration", TokenGetText(identifier).cstr);
        }
        if (functionSymbol->isVariadric != isVariadric) {
            ReportError(TokenGetLocation(identifier), "Vadriaticity of function '%s' does not match with a previous declaration", TokenGetText(identifier).cstr);
        }
        if (functionParamsSymbolTable->count != functionSymbol->membersSymbolTable->count) {
            ReportError(TokenGetLocation(syntax->functionDeclarationStmt.leftParen), "Function '%s' was previously declared with %d parameters wheras new declaration has %d parameters", functionSymbol->name.cstr, functionSymbol->membersSymbolTable->count, functionParamsSymbolTable->count);
        }
        for (int32 paramIndex = 0; paramIndex < functionParamsSymbolTable->count; paramIndex += 1) {
            Type paramType = functionParamsSymbolTable->symbols[paramIndex]->type;
            Type previosType = functionSymbol->membersSymbolTable->symbols[paramIndex]->type;
            if (!TypesIdentical(paramType, previosType)) {
                ReportError(TokenGetLocation(syntax->functionDeclarationStmt.leftParen), "Previous function '%s' parameter %d declared type differs from current declared type", functionSymbol->name.cstr, paramIndex + 1);
            }
        }
    }
    functionSymbol->membersSymbolTable = functionParamsSymbolTable;
    functionSymbol->isVariadric = isVariadric;
    ASTNode* body = NULL;
    if (syntax->kind == SyntaxKind_FunctionDefinitionStatement) {
        if (isExternal) {
            ReportError(TokenGetLocation(identifier), "Cannot define external function '%s'", TokenGetText(identifier).cstr);
        }
        if (functionSymbol->alreadyDefined) {
            ReportError(TokenGetLocation(identifier), "Duplicate function definition of '%s'", TokenGetText(identifier).cstr);
        }
        binder->symbolTable = functionSymbol->membersSymbolTable;
        binder->currentFunctionSymbol = functionSymbol;
        body = BindBlockStatement(binder, syntax->functionDefinitionStmt.body);
        functionSymbol->alreadyDefined = true;
        binder->currentFunctionSymbol = NULL;
        binder->symbolTable = binder->symbolTable->parent;
    }
    ASTNode* result = ASTNodeCreate2(syntax->kind == SyntaxKind_FunctionDeclarationStatement ? ASTNodeKind_FunctionDeclarationStatement : ASTNodeKind_FunctionDefinitionStatement, binder->symbolTable, syntax);
    result->symbol = functionSymbol;
    result->left = body;
    return result;
}

static ASTNode* BindModuleStatement(Binder* binder, SyntaxNode* syntax) {
    switch (syntax->kind) {
        case SyntaxKind_ImportDeclarationStatement: {
            return NULL;
        }
        case SyntaxKind_GlobalVariableDeclarationStatement: {
            return BindGlobalVariableDefinitionStatement(binder, syntax);
        }
        case SyntaxKind_EnumDeclarationStatement: // Fallthrough
        case SyntaxKind_EnumDefinitionStatement: {
            return BindEnumDefinitionStatement(binder, syntax);
        }
        case SyntaxKind_StructOrUnionDeclarationStatement: // Fallthrough
        case SyntaxKind_StructOrUniontDefinitionStatement: {
            return BindStructOrUnionDefinitionStatement(binder, syntax);
        }
        case SyntaxKind_FunctionDeclarationStatement: // Fallthrough
        case SyntaxKind_FunctionDefinitionStatement: {
            return BindFunctionDefinitionStatement(binder, syntax);
        }
        default: {
            assert(false && "Unexpected module statement in binder");
        }
    }
    return NULL;
}

static ASTNode* BindModule(Binder* binder, ModuleStatementSyntax* syntax) {
    assert(syntax->info.kind == SyntaxKind_Module);
    ASTNode* result = ASTNodeCreate2(ASTNodeKind_Module, binder->symbolTable, (SyntaxNode*)syntax);
    for (int32 index = 0; index < syntax->globalStatements.count; index += 1) {
        SyntaxNode* statement = syntax->globalStatements.nodes[index];
        ASTNode* boundStatement = BindModuleStatement(binder, statement);
        if (boundStatement != NULL) {
            ASTNodeArrayPush(&result->children, boundStatement);
        }
    }
    return result;
}

static void Compile(String inputFilepath, String outputFilepath) {
    Source source = PreprocessFile(inputFilepath);
    Parser parser = ParserCreate(source);
    SyntaxTree* syntaxTree = ParseModule(&parser);
    SymbolTable* symbolTable = SymbolTableCreate(NULL);
    Binder binder = BinderCreate(source, symbolTable);
    ASTNode* boundTree = BindModule(&binder, syntaxTree->moduleRoot);
    Emitter emitter = EmitterCreate(outputFilepath);
    EmitRoot(&emitter, boundTree);
}

static void main(int32 argc, char** argv) {
    if (argc == 1 || argc % 2 != 1) {
        fprintf(stderr, "Expects a multiple of two arguments: <inputfilepath> <outputfilepath>\n");
        exit(1);
    }
    int32 counter = 1;
    while (counter < argc) {
        Compile(StringCreateFromCStr(argv[counter]), StringCreateFromCStr(argv[counter + 1]));
        counter += 2;
    }
}

