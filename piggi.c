//////////////////////////////////////////////////////////////////////
// This file was generated by piggi and should not be modified by hand
//////////////////////////////////////////////////////////////////////


#include <stdio.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <assert.h>

typedef int8_t  int8;
typedef int16_t int16;
typedef int32_t int32;
typedef int64_t int64;



























































struct String; typedef struct String String; struct String {
    const char* cstr;
    int32 length;
};

static String StringCreateEmpty() {
    String result;
    result.cstr = NULL;
    result.length = 0;
    return result;
}

static String StringCreateFromCStr(const char* str) {
    int32 length = 0;
    if (str != NULL) {
        const char* pos = str;
        while (*pos != '\0') {
            length += 1;
            pos += 1;
        }
    }
    String result;
    result.cstr = str;
    result.length = length;
    return result;
}

static bool StringEquals(String a, String b) {
    if (a.length != b.length) {
        return false;
    }
    for (int32 index = 0; index < a.length; index += 1) {
        if (a.cstr[index] != b.cstr[index]) {
            return false;
        }
    }
    return true;
}

struct LineAndColumnNumber; typedef struct LineAndColumnNumber LineAndColumnNumber; struct LineAndColumnNumber {
    int32 lineNumber;
    int32 columnNumber;
};

static LineAndColumnNumber StringGetLineAndColumnNumberAtPos(String str, int32 pos) {
    int32 curPos = 0;
    int32 curLine = 1;
    int32 curColumn = 1;
    while (curPos < pos && curPos < str.length) {
        if (str.cstr[curPos] == '\n') {
            curColumn = 1;
            curLine += 1;
        }
        curPos += 1;
    }
    LineAndColumnNumber result;
    result.lineNumber = curLine;
    result.columnNumber = curColumn;
    return result;
}

static String StringGetSubstring(String str, int32 start, int32 end) {
    assert(start <= end);
    int32 length = end - start;
    if (length == 0) {
        return StringCreateEmpty();
    }
    char* buffer = (char*)malloc(length + 1);
    for (int32 index = 0; index < length; index += 1) {
        buffer[index] = str.cstr[start + index];
    }
    buffer[length] = '\0';
    String result;
    result.cstr = buffer;
    result.length = length;
    return result;
}

static String StringAppend(String base, String suffix) {
    int32 length = base.length + suffix.length;
    char* buffer = (char*)malloc(length + 1);
    int32 pos = 0;
    for (int32 sourceIndex = 0; sourceIndex < base.length; sourceIndex += 1) {
        buffer[pos] = base.cstr[sourceIndex];
        pos += 1;
    }
    for (int32 sourceIndex = 0; sourceIndex < suffix.length; sourceIndex += 1) {
        buffer[pos] = suffix.cstr[sourceIndex];
        pos += 1;
    }
    buffer[pos] = '\0';
    String result;
    result.length = length;
    result.cstr = buffer;
    return result;
}

static int32 FindCharPosInString(String str, char ch) {
    for (int32 pos = 0; pos < str.length; pos += 1) {
        if (str.cstr[pos] == ch) {
            return pos;
        }
    }
    return -1;
}

struct SourceFile; typedef struct SourceFile SourceFile; struct SourceFile {
    String filepath;
    String content;
};

struct SourceFileArray; typedef struct SourceFileArray SourceFileArray; struct SourceFileArray {
    SourceFile* files;
    int32 count;
    int32 capacity;
};

static SourceFileArray SourceFileArrayCreate() {
    SourceFileArray result;
    result.files = NULL;
    result.count = 0;
    result.capacity = 0;
    return result;
}

static void SourceFileArrayGrow(SourceFileArray* array, int32 newCapacity) {
    array->capacity = newCapacity;
    array->files = (SourceFile*)realloc(array->files, newCapacity * sizeof(SourceFile));
    assert(array->files != NULL);
}

static int32 SourceFileArrayPush(SourceFileArray* array, SourceFile file) {
    if (array->count == array->capacity) {
        int32 newCapacity = 2 * array->capacity;
        if (newCapacity == 0) {
            newCapacity = 64;
        }
        SourceFileArrayGrow(array, newCapacity);
    }
    int32 insertionIndex = array->count;
    array->files[insertionIndex] = file;
    array->count += 1;
    return insertionIndex;
}

struct Source; typedef struct Source Source; struct Source {
    SourceFileArray files;
    String content;
};

static Source SourceCreateEmpty() {
    Source result;
    result.files = SourceFileArrayCreate();
    result.content = StringCreateEmpty();
    return result;
}

static bool SourceContainsFile(Source source, String filepath) {
    for (int32 index = 0; index < source.files.count; index += 1) {
        if (StringEquals(source.files.files[index].filepath, filepath)) {
            return true;
        }
    }
    return false;
}

static String SourceGetSubstring(Source source, int32 start, int32 end) {
    return StringGetSubstring(source.content, start, end);
}

static char SourceGetCharAtIndex(Source source, int32 charPos) {
    return source.content.cstr[charPos];
}

struct SourceLocation; typedef struct SourceLocation SourceLocation; struct SourceLocation {
    Source source;
    int32 charPos;
    char ch;
    String filepath;
    LineAndColumnNumber fileLineColumn;
};

static SourceLocation SourceGetLocationForCharPos(Source source, int32 charPos) {
    SourceLocation result;
    result.source = source;
    result.charPos = charPos;
    result.ch = SourceGetCharAtIndex(source, charPos);
    result.filepath = StringCreateEmpty();
    result.fileLineColumn.lineNumber = -1;
    result.fileLineColumn.columnNumber = -1;
    int32 remainder = charPos;
    for (int32 fileIndex = 0; fileIndex < source.files.count; fileIndex += 1) {
        String filepath = source.files.files[fileIndex].filepath;
        String fileContent = source.files.files[fileIndex].content;
        int32 fileLength = fileContent.length;
        if (remainder < fileLength) {
            result.filepath = filepath;
            result.fileLineColumn = StringGetLineAndColumnNumberAtPos(fileContent, remainder);
            result.ch = fileContent.cstr[remainder];
            break;
        }
        remainder -= fileLength;
    }
    return result;
}

static void ReportLocation(SourceLocation location) {
    fprintf(stderr, "%s(%d)", location.filepath.cstr, location.fileLineColumn.lineNumber);
}

static void ReportError(SourceLocation location, char* format, ...) {
    ReportLocation(location);
    fprintf(stderr, ": Error - ", location.filepath.cstr, location.fileLineColumn.lineNumber);
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "\n");
    exit(1);
}

enum TokenKind; typedef enum TokenKind TokenKind; enum TokenKind {
    TokenKind_EndOfFile = 0,
    TokenKind_Plus = 1,
    TokenKind_PlusEquals = 2,
    TokenKind_Minus = 3,
    TokenKind_MinusEquals = 4,
    TokenKind_Star = 5,
    TokenKind_StarEquals = 6,
    TokenKind_Slash = 7,
    TokenKind_SlashEquals = 8,
    TokenKind_Percent = 9,
    TokenKind_PercentEquals = 10,
    TokenKind_Equals = 11,
    TokenKind_EqualsEquals = 12,
    TokenKind_Bang = 13,
    TokenKind_BangEquals = 14,
    TokenKind_Less = 15,
    TokenKind_LessEquals = 16,
    TokenKind_Greater = 17,
    TokenKind_GreaterEquals = 18,
    TokenKind_LessLess = 19,
    TokenKind_LessLessEquals = 20,
    TokenKind_GreaterGreater = 21,
    TokenKind_GreaterGreaterEquals = 22,
    TokenKind_Tilde = 23,
    TokenKind_Hat = 24,
    TokenKind_HatEquals = 25,
    TokenKind_Pipe = 26,
    TokenKind_PipeEquals = 27,
    TokenKind_PipePipe = 28,
    TokenKind_Ampersand = 29,
    TokenKind_AmpersandEquals = 30,
    TokenKind_AmpersandAmpersand = 31,
    TokenKind_Questionmark = 32,
    TokenKind_Colon = 33,
    TokenKind_ColonColon = 34,
    TokenKind_Arrow = 35,
    TokenKind_Dot = 36,
    TokenKind_DotDotDot = 37,
    TokenKind_Comma = 38,
    TokenKind_Semicolon = 39,
    TokenKind_LeftBrace = 40,
    TokenKind_RightBrace = 41,
    TokenKind_LeftParen = 42,
    TokenKind_RightParen = 43,
    TokenKind_LeftBracket = 44,
    TokenKind_RightBracket = 45,
    TokenKind_IntegerLiteral = 46,
    TokenKind_CharacterLiteral = 47,
    TokenKind_StringLiteral = 48,
    TokenKind_Void = 49,
    TokenKind_Char = 50,
    TokenKind_Byte = 51,
    TokenKind_Short = 52,
    TokenKind_Int = 53,
    TokenKind_Long = 54,
    TokenKind_Null = 55,
    TokenKind_CString = 56,
    TokenKind_Bool = 57,
    TokenKind_True = 58,
    TokenKind_False = 59,
    TokenKind_If = 60,
    TokenKind_Else = 61,
    TokenKind_Do = 62,
    TokenKind_While = 63,
    TokenKind_For = 64,
    TokenKind_Return = 65,
    TokenKind_Break = 66,
    TokenKind_Continue = 67,
    TokenKind_Switch = 68,
    TokenKind_Case = 69,
    TokenKind_Default = 70,
    TokenKind_As = 71,
    TokenKind_SizeOf = 72,
    TokenKind_Fun = 73,
    TokenKind_Let = 74,
    TokenKind_Struct = 75,
    TokenKind_Union = 76,
    TokenKind_Enum = 77,
    TokenKind_Class = 78,
    TokenKind_LocalPersist = 79,
    TokenKind_Extern = 80,
    TokenKind_IncludeDirective = 81,
    TokenKind_DefineDirective = 82,
    TokenKind_IfDirective = 83,
    TokenKind_EndIfDefinedDirective = 84,
    TokenKind_PragmaDirective = 85,
    TokenKind_Typedef = 86,
    TokenKind_Identifier = 87,
};

static String TokenKindToString(TokenKind kind) {
    switch (kind) {
        case TokenKind_EndOfFile: {
            return StringCreateFromCStr("eof");
        }
        case TokenKind_Plus: {
            return StringCreateFromCStr("+");
        }
        case TokenKind_PlusEquals: {
            return StringCreateFromCStr("+=");
        }
        case TokenKind_Minus: {
            return StringCreateFromCStr("-");
        }
        case TokenKind_MinusEquals: {
            return StringCreateFromCStr("-=");
        }
        case TokenKind_Star: {
            return StringCreateFromCStr("*");
        }
        case TokenKind_StarEquals: {
            return StringCreateFromCStr("*=");
        }
        case TokenKind_Slash: {
            return StringCreateFromCStr("/");
        }
        case TokenKind_SlashEquals: {
            return StringCreateFromCStr("/=");
        }
        case TokenKind_Percent: {
            return StringCreateFromCStr("%");
        }
        case TokenKind_PercentEquals: {
            return StringCreateFromCStr("%=");
        }
        case TokenKind_Equals: {
            return StringCreateFromCStr("=");
        }
        case TokenKind_EqualsEquals: {
            return StringCreateFromCStr("==");
        }
        case TokenKind_Bang: {
            return StringCreateFromCStr("!");
        }
        case TokenKind_BangEquals: {
            return StringCreateFromCStr("!=");
        }
        case TokenKind_Less: {
            return StringCreateFromCStr("<");
        }
        case TokenKind_LessEquals: {
            return StringCreateFromCStr("<=");
        }
        case TokenKind_Greater: {
            return StringCreateFromCStr(">");
        }
        case TokenKind_GreaterEquals: {
            return StringCreateFromCStr(">=");
        }
        case TokenKind_LessLess: {
            return StringCreateFromCStr("<<");
        }
        case TokenKind_LessLessEquals: {
            return StringCreateFromCStr("<<=");
        }
        case TokenKind_GreaterGreater: {
            return StringCreateFromCStr(">>");
        }
        case TokenKind_GreaterGreaterEquals: {
            return StringCreateFromCStr(">>=");
        }
        case TokenKind_Tilde: {
            return StringCreateFromCStr("~");
        }
        case TokenKind_Hat: {
            return StringCreateFromCStr("^");
        }
        case TokenKind_HatEquals: {
            return StringCreateFromCStr("^=");
        }
        case TokenKind_Pipe: {
            return StringCreateFromCStr("|");
        }
        case TokenKind_PipeEquals: {
            return StringCreateFromCStr("|=");
        }
        case TokenKind_PipePipe: {
            return StringCreateFromCStr("||");
        }
        case TokenKind_Ampersand: {
            return StringCreateFromCStr("&");
        }
        case TokenKind_AmpersandEquals: {
            return StringCreateFromCStr("&=");
        }
        case TokenKind_AmpersandAmpersand: {
            return StringCreateFromCStr("&&");
        }
        case TokenKind_Questionmark: {
            return StringCreateFromCStr("?");
        }
        case TokenKind_Colon: {
            return StringCreateFromCStr(":");
        }
        case TokenKind_ColonColon: {
            return StringCreateFromCStr("::");
        }
        case TokenKind_Arrow: {
            return StringCreateFromCStr("->");
        }
        case TokenKind_Dot: {
            return StringCreateFromCStr(".");
        }
        case TokenKind_DotDotDot: {
            return StringCreateFromCStr("...");
        }
        case TokenKind_Comma: {
            return StringCreateFromCStr(",");
        }
        case TokenKind_Semicolon: {
            return StringCreateFromCStr(";");
        }
        case TokenKind_LeftBrace: {
            return StringCreateFromCStr("{");
        }
        case TokenKind_RightBrace: {
            return StringCreateFromCStr("}");
        }
        case TokenKind_LeftParen: {
            return StringCreateFromCStr("(");
        }
        case TokenKind_RightParen: {
            return StringCreateFromCStr(")");
        }
        case TokenKind_LeftBracket: {
            return StringCreateFromCStr("[");
        }
        case TokenKind_RightBracket: {
            return StringCreateFromCStr("]");
        }
        case TokenKind_IntegerLiteral: {
            return StringCreateFromCStr("int-lit");
        }
        case TokenKind_CharacterLiteral: {
            return StringCreateFromCStr("chr-lit");
        }
        case TokenKind_StringLiteral: {
            return StringCreateFromCStr("str-lit");
        }
        case TokenKind_Char: {
            return StringCreateFromCStr("char");
        }
        case TokenKind_Byte: {
            return StringCreateFromCStr("byte");
        }
        case TokenKind_Short: {
            return StringCreateFromCStr("short");
        }
        case TokenKind_Int: {
            return StringCreateFromCStr("int");
        }
        case TokenKind_Long: {
            return StringCreateFromCStr("longint");
        }
        case TokenKind_Void: {
            return StringCreateFromCStr("void");
        }
        case TokenKind_Null: {
            return StringCreateFromCStr("nullptr");
        }
        case TokenKind_CString: {
            return StringCreateFromCStr("cstring");
        }
        case TokenKind_Bool: {
            return StringCreateFromCStr("bool");
        }
        case TokenKind_True: {
            return StringCreateFromCStr("true");
        }
        case TokenKind_False: {
            return StringCreateFromCStr("false");
        }
        case TokenKind_If: {
            return StringCreateFromCStr("if");
        }
        case TokenKind_Else: {
            return StringCreateFromCStr("else");
        }
        case TokenKind_Do: {
            return StringCreateFromCStr("do");
        }
        case TokenKind_While: {
            return StringCreateFromCStr("while");
        }
        case TokenKind_For: {
            return StringCreateFromCStr("for");
        }
        case TokenKind_Return: {
            return StringCreateFromCStr("return");
        }
        case TokenKind_Break: {
            return StringCreateFromCStr("break");
        }
        case TokenKind_Continue: {
            return StringCreateFromCStr("continue");
        }
        case TokenKind_Switch: {
            return StringCreateFromCStr("switch");
        }
        case TokenKind_Case: {
            return StringCreateFromCStr("case");
        }
        case TokenKind_Default: {
            return StringCreateFromCStr("default");
        }
        case TokenKind_As: {
            return StringCreateFromCStr("as");
        }
        case TokenKind_SizeOf: {
            return StringCreateFromCStr("sizeof");
        }
        case TokenKind_Let: {
            return StringCreateFromCStr("let");
        }
        case TokenKind_Fun: {
            return StringCreateFromCStr("fun");
        }
        case TokenKind_Struct: {
            return StringCreateFromCStr("struct");
        }
        case TokenKind_Union: {
            return StringCreateFromCStr("union");
        }
        case TokenKind_Enum: {
            return StringCreateFromCStr("enum");
        }
        case TokenKind_Class: {
            return StringCreateFromCStr("class");
        }
        case TokenKind_LocalPersist: {
            return StringCreateFromCStr("localpersist");
        }
        case TokenKind_Extern: {
            return StringCreateFromCStr("extern");
        }
        case TokenKind_IncludeDirective: {
            return StringCreateFromCStr("#include");
        }
        case TokenKind_DefineDirective: {
            return StringCreateFromCStr("#define");
        }
        case TokenKind_IfDirective: {
            return StringCreateFromCStr("#if");
        }
        case TokenKind_EndIfDefinedDirective: {
            return StringCreateFromCStr("#endif");
        }
        case TokenKind_PragmaDirective: {
            return StringCreateFromCStr("#pragma");
        }
        case TokenKind_Typedef: {
            return StringCreateFromCStr("typedef");
        }
        case TokenKind_Identifier: {
            return StringCreateFromCStr("identifier");
        }
        default: {
            fprintf(stderr, "Unrecognized token in `TokenKindToString`: %d", kind);
            exit(1);
        }
    }
}

static TokenKind GetKeywordForIdentifier(String identifier) {
    if (StringEquals(identifier, TokenKindToString(TokenKind_Char))) {
        return TokenKind_Char;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Byte))) {
        return TokenKind_Byte;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Short))) {
        return TokenKind_Short;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Int))) {
        return TokenKind_Int;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Long))) {
        return TokenKind_Long;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Void))) {
        return TokenKind_Void;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Null))) {
        return TokenKind_Null;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_CString))) {
        return TokenKind_CString;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Bool))) {
        return TokenKind_Bool;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_True))) {
        return TokenKind_True;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_False))) {
        return TokenKind_False;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_If))) {
        return TokenKind_If;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Else))) {
        return TokenKind_Else;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Do))) {
        return TokenKind_Do;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_While))) {
        return TokenKind_While;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_For))) {
        return TokenKind_For;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Return))) {
        return TokenKind_Return;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Break))) {
        return TokenKind_Break;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Continue))) {
        return TokenKind_Continue;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Switch))) {
        return TokenKind_Switch;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Case))) {
        return TokenKind_Case;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Default))) {
        return TokenKind_Default;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Fun))) {
        return TokenKind_Fun;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Let))) {
        return TokenKind_Let;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Struct))) {
        return TokenKind_Struct;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Union))) {
        return TokenKind_Union;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Enum))) {
        return TokenKind_Enum;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Class))) {
        return TokenKind_Class;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_As))) {
        return TokenKind_As;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_SizeOf))) {
        return TokenKind_SizeOf;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_LocalPersist))) {
        return TokenKind_LocalPersist;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Extern))) {
        return TokenKind_Extern;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_IncludeDirective))) {
        return TokenKind_IncludeDirective;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_DefineDirective))) {
        return TokenKind_DefineDirective;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_IfDirective))) {
        return TokenKind_IfDirective;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_EndIfDefinedDirective))) {
        return TokenKind_EndIfDefinedDirective;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_PragmaDirective))) {
        return TokenKind_PragmaDirective;
    }
    if (StringEquals(identifier, TokenKindToString(TokenKind_Typedef))) {
        return TokenKind_Typedef;
    }
    return TokenKind_EndOfFile;
}

struct Token; typedef struct Token Token; struct Token {
    TokenKind kind;
    int64 intvalue;
    bool intvalueIsHex;
    String stringValue;
    Source source;
    int32 sourceStart;
    int32 sourceEnd;
    String sourceString;
};

static Token TokenCreateEmpty(Source source) {
    Token result;
    result.kind = TokenKind_EndOfFile;
    result.intvalue = 0;
    result.intvalueIsHex = false;
    result.stringValue = StringCreateEmpty();
    result.source = source;
    result.sourceStart = 0;
    result.sourceEnd = 0;
    result.sourceString = StringCreateEmpty();
    return result;
}

static String TokenGetText(Token token) {
    return SourceGetSubstring(token.source, token.sourceStart, token.sourceEnd);
}

static SourceLocation TokenGetLocation(Token token) {
    return SourceGetLocationForCharPos(token.source, token.sourceStart);
}

enum TypeKind; typedef enum TypeKind TypeKind; enum TypeKind {
    TypeKind_PrimitiveNull = 0,
    TypeKind_PrimitiveVoid = 1,
    TypeKind_PrimitiveBool = 2,
    TypeKind_PrimitiveChar = 3,
    TypeKind_PrimitiveByte = 4,
    TypeKind_PrimitiveShort = 5,
    TypeKind_PrimitiveInt = 6,
    TypeKind_PrimitiveLong = 7,
    TypeKind_PrimitiveCString = 8,
    TypeKind_Struct = 9,
    TypeKind_Union = 10,
    TypeKind_Enum = 11,
};

struct Type; typedef struct Type Type; struct Type {
    TypeKind kind;
    int32 baseIndirectionLevel;
    String name;
    bool isArray;
    int64 arrayElementCount;
};

static Type TypeCreate(TypeKind kind, int32 baseIndirectionLevel, String name) {
    Type result;
    result.kind = kind;
    result.baseIndirectionLevel = baseIndirectionLevel;
    result.name = name;
    result.isArray = false;
    result.arrayElementCount = -1;
    return result;
}

static int32 TypeGetIndirectionLevel(Type type) {
    return type.baseIndirectionLevel + (int32)type.isArray + (int32)(type.kind == TypeKind_PrimitiveCString);
}

static Type GetElementTypeForArrayType(Type type) {
    assert(type.isArray);
    type.isArray = false;
    return type;
}

static String TypeGetText(Type type) {
    char* buffer = (char*)malloc(128);
    int32 bufferpos = 0;
    switch (type.kind) {
        case TypeKind_PrimitiveNull: {
            bufferpos = snprintf(buffer, 128, "void");
            assert(!type.isArray);
            assert(type.baseIndirectionLevel == 1);
            break;
        }
        case TypeKind_PrimitiveVoid: {
            bufferpos = snprintf(buffer, 128, "void");
            break;
        }
        case TypeKind_PrimitiveBool: {
            bufferpos = snprintf(buffer, 128, "bool");
            break;
        }
        case TypeKind_PrimitiveChar: {
            bufferpos = snprintf(buffer, 128, "char");
            break;
        }
        case TypeKind_PrimitiveByte: {
            bufferpos = snprintf(buffer, 128, "byte");
            break;
        }
        case TypeKind_PrimitiveShort: {
            bufferpos = snprintf(buffer, 128, "short");
            break;
        }
        case TypeKind_PrimitiveInt: {
            bufferpos = snprintf(buffer, 128, "int");
            break;
        }
        case TypeKind_PrimitiveLong: {
            bufferpos = snprintf(buffer, 128, "long");
            break;
        }
        case TypeKind_PrimitiveCString: {
            bufferpos = snprintf(buffer, 128, "cstring");
            break;
        }
        case TypeKind_Struct: // Fallthrough
        case TypeKind_Union: // Fallthrough
        case TypeKind_Enum: {
            bufferpos = snprintf(buffer, 128, "%s", type.name.cstr);
            break;
        }
        default: {
            assert(false && "unknown kind");
        }
    }
    for (int32 index = 0; index < type.baseIndirectionLevel; index += 1) {
        buffer[bufferpos] = '*';
        bufferpos += 1;
    }
    if (type.isArray) {
        buffer[bufferpos] = '[';
        bufferpos += 1;
        buffer[bufferpos] = ']';
        bufferpos += 1;
    }
    buffer[bufferpos] = '\0';
    String result;
    result.cstr = buffer;
    result.length = bufferpos;
    return result;
}

static Type TypeCreatePrimitive(TypeKind kind) {
    assert(kind != TypeKind_Struct);
    return TypeCreate(kind, 0, StringCreateEmpty());
}

static Type TypeCreateVoid() {
    return TypeCreatePrimitive(TypeKind_PrimitiveVoid);
}

static bool IsNull(Type type) {
    return type.kind == TypeKind_PrimitiveNull;
}

static bool IsVoidType(Type type) {
    return type.kind == TypeKind_PrimitiveVoid && TypeGetIndirectionLevel(type) == 0;
}

static bool IsVoidPointer(Type type) {
    return type.kind == TypeKind_PrimitiveVoid && type.baseIndirectionLevel == 1 && !type.isArray;
}

static bool IsCharType(Type type) {
    if (TypeGetIndirectionLevel(type) > 0) {
        return false;
    }
    return type.kind == TypeKind_PrimitiveChar;
}

static bool IsNumberType(Type type) {
    if (TypeGetIndirectionLevel(type) > 0) {
        return false;
    }
    switch (type.kind) {
        case TypeKind_PrimitiveBool: // Fallthrough
        case TypeKind_PrimitiveByte: // Fallthrough
        case TypeKind_PrimitiveShort: // Fallthrough
        case TypeKind_PrimitiveInt: // Fallthrough
        case TypeKind_PrimitiveLong: {
            return true;
        }
        default: {
            return false;
        }
    }
}

static bool IsPointerType(Type type) {
    return type.kind == TypeKind_PrimitiveCString || (type.baseIndirectionLevel > 0 && !type.isArray);
}

static bool TypesIdentical(Type a, Type b) {
    if (a.kind != b.kind) {
        return false;
    }
    if (TypeGetIndirectionLevel(a) != TypeGetIndirectionLevel(b)) {
        return false;
    }
    return StringEquals(a.name, b.name);
}

enum TypeConversionResult; typedef enum TypeConversionResult TypeConversionResult; enum TypeConversionResult {
    TypeConversionResult_NonConvertible = 0,
    TypeConversionResult_Identical = 1,
    TypeConversionResult_ImplictlyConvertible = 2,
    TypeConversionResult_ExplicitlyConvertible = 3,
};

static TypeConversionResult CanConvertTypeFromTo(Type from, Type to) {
    if (IsVoidType(from) || IsVoidType(to)) {
        return TypeConversionResult_NonConvertible;
    }
    if (TypesIdentical(from, to)) {
        return TypeConversionResult_Identical;
    }
    if (TypeGetIndirectionLevel(from) == 0 && TypeGetIndirectionLevel(to) == 0) {
        if (IsNumberType(from) && IsNumberType(to)) {
            if (from.kind <= to.kind) {
                return TypeConversionResult_ImplictlyConvertible;
            } else {
                return TypeConversionResult_ExplicitlyConvertible;
            }
        }
        if (from.kind == TypeKind_PrimitiveChar && IsNumberType(to)) {
            return TypeConversionResult_ExplicitlyConvertible;
        }
        if (IsNumberType(from) && to.kind == TypeKind_PrimitiveChar) {
            return TypeConversionResult_ExplicitlyConvertible;
        }
        if (from.kind == TypeKind_Enum && IsNumberType(to)) {
            return TypeConversionResult_ExplicitlyConvertible;
        }
        if (IsNumberType(from) && to.kind == TypeKind_Enum) {
            return TypeConversionResult_ExplicitlyConvertible;
        }
    }
    if (IsPointerType(from) && IsVoidPointer(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (IsVoidPointer(from) && IsPointerType(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (from.baseIndirectionLevel == 1 && to.baseIndirectionLevel == 1) {
        if (from.kind == TypeKind_PrimitiveVoid || to.kind == TypeKind_PrimitiveVoid) {
            return TypeConversionResult_ImplictlyConvertible;
        } else {
            if (IsNull(from) || IsNull(to)) {
                return TypeConversionResult_ImplictlyConvertible;
            } else {
                return TypeConversionResult_ExplicitlyConvertible;
            }
        }
    }
    if (IsPointerType(from) && IsNull(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (IsNull(from) && IsPointerType(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (IsNull(from) && to.kind == TypeKind_PrimitiveCString) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (from.kind == TypeKind_PrimitiveCString && IsNull(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (from.kind == to.kind && from.isArray && !to.isArray && TypeGetIndirectionLevel(from) == TypeGetIndirectionLevel(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    if (from.kind == TypeKind_PrimitiveChar && to.kind == TypeKind_PrimitiveCString && TypeGetIndirectionLevel(from) == TypeGetIndirectionLevel(to)) {
        return TypeConversionResult_ImplictlyConvertible;
    }
    return TypeConversionResult_NonConvertible;
}

static Type GetPointerTypeForBaseType(Type type) {
    assert(type.kind != TypeKind_PrimitiveNull);
    Type result = type;
    result.baseIndirectionLevel += 1;
    return result;
}

static Type GetBaseTypeForPointerType(Type type) {
    assert(type.baseIndirectionLevel > 0 || type.kind == TypeKind_PrimitiveCString);
    Type result = type;
    if (result.baseIndirectionLevel > 0) {
        result.baseIndirectionLevel -= 1;
    } else {
        if (type.kind == TypeKind_PrimitiveCString) {
            result.kind = TypeKind_PrimitiveChar;
        }
    }
    return result;
}

static Type GetTypeThatFitsBothTypes(Type a, Type b) {
    TypeConversionResult conversion = CanConvertTypeFromTo(a, b);
    if (TypesIdentical(a, b)) {
        return a;
    }
    if (a.baseIndirectionLevel == 0 && b.baseIndirectionLevel == 0) {
        if (IsNumberType(a) && IsNumberType(b)) {
            if (a.kind <= b.kind) {
                return b;
            } else {
                return a;
            }
        }
    }
    if (IsPointerType(a) && IsNull(b)) {
        return a;
    }
    if (IsPointerType(b) && IsNull(a)) {
        return b;
    }
    return TypeCreateVoid();
}

enum ASTNodeKind; typedef enum ASTNodeKind ASTNodeKind; enum ASTNodeKind {
    ASTNodeKind_Identity = 0,
    ASTNodeKind_Negation = 1,
    ASTNodeKind_LogicalNegation = 2,
    ASTNodeKind_BitwiseNegation = 3,
    ASTNodeKind_Dereference = 4,
    ASTNodeKind_Address = 5,
    ASTNodeKind_Assignment = 6,
    ASTNodeKind_Add = 7,
    ASTNodeKind_AddAssignment = 8,
    ASTNodeKind_Subtract = 9,
    ASTNodeKind_SubtractAssignment = 10,
    ASTNodeKind_Multiply = 11,
    ASTNodeKind_MultiplyAssignment = 12,
    ASTNodeKind_Divide = 13,
    ASTNodeKind_DivideAssignment = 14,
    ASTNodeKind_Remainder = 15,
    ASTNodeKind_RemainderAssignment = 16,
    ASTNodeKind_BitwiseXor = 17,
    ASTNodeKind_BitwiseXorAssignment = 18,
    ASTNodeKind_BitwiseAnd = 19,
    ASTNodeKind_BitwiseAndAssignment = 20,
    ASTNodeKind_BitwiseOr = 21,
    ASTNodeKind_BitwiseOrAssignment = 22,
    ASTNodeKind_BitshiftLeft = 23,
    ASTNodeKind_BitshiftLeftAssignment = 24,
    ASTNodeKind_BitshiftRight = 25,
    ASTNodeKind_BitshiftRightAssignment = 26,
    ASTNodeKind_LogicalAnd = 27,
    ASTNodeKind_LogicalOr = 28,
    ASTNodeKind_AddToPointer = 29,
    ASTNodeKind_AddToPointerAssignment = 30,
    ASTNodeKind_SubtractFromPointer = 31,
    ASTNodeKind_SubtractFromPointerAssignment = 32,
    ASTNodeKind_DistanceBetweenPointers = 33,
    ASTNodeKind_Equals = 34,
    ASTNodeKind_NotEquals = 35,
    ASTNodeKind_Less = 36,
    ASTNodeKind_LessEquals = 37,
    ASTNodeKind_Greater = 38,
    ASTNodeKind_GreaterEquals = 39,
    ASTNodeKind_FunccallExpression = 40,
    ASTNodeKind_Arrayindexing = 41,
    ASTNodeKind_Memberaccess = 42,
    ASTNodeKind_CastExpression = 43,
    ASTNodeKind_ParenthesizedExpression = 44,
    ASTNodeKind_TernaryConditionalExpression = 45,
    ASTNodeKind_SizeOfExpression = 46,
    ASTNodeKind_TypeExpression = 47,
    ASTNodeKind_NullLiteral = 48,
    ASTNodeKind_IntegerLiteral = 49,
    ASTNodeKind_CharacterLiteral = 50,
    ASTNodeKind_BoolLiteral = 51,
    ASTNodeKind_StringLiteral = 52,
    ASTNodeKind_EnumValueLiteral = 53,
    ASTNodeKind_ArrayLiteral = 54,
    ASTNodeKind_Identifier = 55,
    ASTNodeKind_CompoundStatement = 56,
    ASTNodeKind_ExpressionStatement = 57,
    ASTNodeKind_IfStatement = 58,
    ASTNodeKind_DoWhileStatement = 59,
    ASTNodeKind_WhileStatement = 60,
    ASTNodeKind_ForStatement = 61,
    ASTNodeKind_ReturnStatement = 62,
    ASTNodeKind_BreakStatement = 63,
    ASTNodeKind_ContinueStatement = 64,
    ASTNodeKind_SwitchStatement = 65,
    ASTNodeKind_CaseStatement = 66,
    ASTNodeKind_DefaultStatement = 67,
    ASTNodeKind_EnumDeclarationStatement = 68,
    ASTNodeKind_EnumDefinitionStatement = 69,
    ASTNodeKind_StructDeclarationStatement = 70,
    ASTNodeKind_StructDefinitionStatement = 71,
    ASTNodeKind_UnionDeclarationStatement = 72,
    ASTNodeKind_UnionDefinitionStatement = 73,
    ASTNodeKind_FunctionDeclarationStatement = 74,
    ASTNodeKind_FunctionDefinitionStatement = 75,
    ASTNodeKind_VariableDeclarationStatement = 76,
    ASTNodeKind_ArrayDeclarationStatement = 77,
    ASTNodeKind_Root = 78,
};

struct ASTNode; typedef struct ASTNode ASTNode;

struct ASTNodeArray; typedef struct ASTNodeArray ASTNodeArray; struct ASTNodeArray {
    ASTNode** nodes;
    int32 count;
    int32 capacity;
};

static ASTNodeArray ASTNodeArrayCreate() {
    ASTNodeArray result;
    result.nodes = NULL;
    result.count = 0;
    result.capacity = 0;
    return result;
}

static void ASTNodeArrayGrow(ASTNodeArray* array, int32 newCapacity) {
    array->capacity = newCapacity;
    array->nodes = (ASTNode**)realloc(array->nodes, newCapacity * sizeof(ASTNode*));
    if (array->nodes == NULL) {
        fprintf(stderr, "Unable to malloc new AST array buffer");
        exit(1);
    }
}

static int32 ASTNodeArrayPush(ASTNodeArray* array, ASTNode* node) {
    if (array->count == array->capacity) {
        int32 newCapacity = 2 * array->capacity;
        if (newCapacity == 0) {
            newCapacity = 64;
        }
        ASTNodeArrayGrow(array, newCapacity);
    }
    int32 insertionIndex = array->count;
    array->nodes[insertionIndex] = node;
    array->count += 1;
    return insertionIndex;
}

struct Symbol; typedef struct Symbol Symbol;

struct SymbolTable; typedef struct SymbolTable SymbolTable;

struct ASTNode; typedef struct ASTNode ASTNode; struct ASTNode {
    ASTNodeKind kind;
    Type type;
    SymbolTable* symbolTable;
    Token token;
    ASTNode* left;
    ASTNode* right;
    ASTNode* extra1;
    ASTNode* extra2;
    bool isRValue;
    int64 intvalue;
    String stringvalue;
    Symbol* symbol;
    ASTNodeArray children;
};

static ASTNode* ASTNodeCreate(ASTNodeKind kind, SymbolTable* symbolTable, Token token) {
    ASTNode* node = (ASTNode*)malloc(sizeof(ASTNode));
    if (node == NULL) {
        fprintf(stderr, "Unable to malloc new AST Node");
        exit(1);
    }
    node->kind = kind;
    node->type = TypeCreateVoid();
    node->symbolTable = symbolTable;
    node->token = token;
    node->left = NULL;
    node->right = NULL;
    node->extra1 = NULL;
    node->extra2 = NULL;
    node->isRValue = false;
    node->intvalue = 0;
    node->symbol = NULL;
    node->children = ASTNodeArrayCreate();
    return node;
}

enum SymbolKind; typedef enum SymbolKind SymbolKind; enum SymbolKind {
    SymbolKind_Function = 0,
    SymbolKind_Struct = 1,
    SymbolKind_Union = 2,
    SymbolKind_Enum = 3,
    SymbolKind_Variable = 4,
    SymbolKind_Parameter = 5,
    SymbolKind_Member = 6,
    SymbolKind_Enumvalue = 7,
};

enum SymbolScopeKind; typedef enum SymbolScopeKind SymbolScopeKind; enum SymbolScopeKind {
    SymbolScopeKind_Extern = 0,
    SymbolScopeKind_Global = 1,
    SymbolScopeKind_Local = 2,
    SymbolScopeKind_LocalPersist = 3,
};

struct SymbolTable; typedef struct SymbolTable SymbolTable;

struct Symbol; typedef struct Symbol Symbol; struct Symbol {
    String name;
    SymbolKind kind;
    SymbolScopeKind scopeKind;
    Type type;
    bool isVariadric;
    SymbolTable* membersSymbolTable;
    bool alreadyDefined;
    int64 enumValue;
};

static Symbol* SymbolCreate(String name, SymbolKind kind, SymbolScopeKind scopeKind, Type type) {
    Symbol* newSymbol = (Symbol*)malloc(sizeof(Symbol));
    newSymbol->name = name;
    newSymbol->kind = kind;
    newSymbol->scopeKind = scopeKind;
    newSymbol->type = type;
    newSymbol->isVariadric = false;
    newSymbol->membersSymbolTable = NULL;
    newSymbol->alreadyDefined = false;
    newSymbol->enumValue = 0;
    return newSymbol;
}

struct SymbolTable; typedef struct SymbolTable SymbolTable; struct SymbolTable {
    SymbolTable* parent;
    Symbol** symbols;
    int32 count;
    int32 capacity;
};

static SymbolTable* SymbolTableCreate(SymbolTable* parent) {
    SymbolTable* result = (SymbolTable*)malloc(sizeof(SymbolTable));
    result->parent = parent;
    result->symbols = NULL;
    result->count = 0;
    result->capacity = 0;
    return result;
}

static void SymbolTableGrow(SymbolTable* table, int32 newCapacity) {
    table->capacity = newCapacity;
    table->symbols = (Symbol**)realloc(table->symbols, newCapacity * sizeof(Symbol*));
    if (table->symbols == NULL) {
        fprintf(stderr, "Unable to malloc new AST array buffer");
        exit(1);
    }
}

static int32 SymbolTablePush(SymbolTable* table, Symbol* symbol) {
    if (table->count == table->capacity) {
        int32 newCapacity = 2 * table->capacity;
        if (newCapacity == 0) {
            newCapacity = 64;
        }
        SymbolTableGrow(table, newCapacity);
    }
    int32 insertionIndex = table->count;
    table->symbols[insertionIndex] = symbol;
    table->count += 1;
    return insertionIndex;
}

static Symbol* GetSymbolFromLocalScope(SymbolTable* table, String name) {
    for (int32 index = 0; index < table->count; index += 1) {
        if (StringEquals(name, table->symbols[index]->name)) {
            return table->symbols[index];
        }
    }
    return NULL;
}

static Symbol* GetSymbol(SymbolTable* table, String name) {
    Symbol* result = GetSymbolFromLocalScope(table, name);
    if (result != NULL) {
        return result;
    }
    if (table->parent != NULL) {
        return GetSymbol(table->parent, name);
    }
    return NULL;
}

static Symbol* AddSymbol(SymbolTable* table, String name, SymbolKind kind, SymbolScopeKind scopeKind, Type type) {
    Symbol* existingLocal = GetSymbolFromLocalScope(table, name);
    if (existingLocal != NULL) {
        return NULL;
    }
    Symbol* existing = GetSymbol(table, name);
    if (existing != NULL) {
        if (existing->kind == SymbolKind_Parameter) {
            return NULL;
        }
    }
    Symbol* newSymbol = SymbolCreate(name, kind, scopeKind, type);
    SymbolTablePush(table, newSymbol);
    return newSymbol;
}

static bool IsWhiteSpace(char ch) {
    return (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n' || ch == '\f');
}

static bool IsDigit(char ch) {
    return '0' <= ch && ch <= '9';
}

static char ToLower(char ch) {
    if ('A' <= ch && ch <= 'Z') {
        return ch + ('a' - 'A');
    } else {
        return ch;
    }
}

static char ToUpper(char ch) {
    if ('a' <= ch && ch <= 'z') {
        return ch - ('a' - 'A');
    } else {
        return ch;
    }
}

static bool IsAlpha(char ch) {
    return ToLower(ch) != ToUpper(ch);
}

struct Scanner; typedef struct Scanner Scanner; struct Scanner {
    Source source;
    int32 start;
    int32 pos;
    Token token;
    char debugCurChar;
    char debugNextChar;
};

static Scanner ScannerCreate(Source source) {
    Scanner result;
    result.source = source;
    result.start = 0;
    result.pos = 0;
    result.token = TokenCreateEmpty(source);
    result.debugCurChar = '\0';
    result.debugNextChar = '\0';
    return result;
}

static char PeekChar(Scanner* scanner, int32 offset) {
    int32 index = scanner->pos + offset;
    return SourceGetCharAtIndex(scanner->source, index);
}

static char CurrentChar(Scanner* scanner) {
    return PeekChar(scanner, 0);
}

static char Lookahead(Scanner* scanner) {
    return PeekChar(scanner, 1);
}

static char AdvanceChar(Scanner* scanner) {
    char result = CurrentChar(scanner);
    scanner->pos += 1;
    scanner->debugCurChar = CurrentChar(scanner);
    scanner->debugNextChar = Lookahead(scanner);
    return result;
}

static void SkipWhitespaceTrivia(Scanner* scanner) {
    while (IsWhiteSpace(CurrentChar(scanner))) {
        AdvanceChar(scanner);
    }
}

static void SkipSingleLineComment(Scanner* scanner) {
    while (CurrentChar(scanner) != '\0') {
        char ch = AdvanceChar(scanner);
        if (ch == '\n') {
            break;
        }
    }
}

static void SkipMultiLineComment(Scanner* scanner) {
    SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->pos);
    while (true) {
        if (CurrentChar(scanner) == '\0') {
            ReportError(location, "Unterminated multiline comment");
        }
        if ((CurrentChar(scanner) == '*') && (Lookahead(scanner) == '/')) {
            AdvanceChar(scanner);
            AdvanceChar(scanner);
            return;
        }
        AdvanceChar(scanner);
    }
}

static void SkipTrivia(Scanner* scanner) {
    while (true) {
        if (IsWhiteSpace(CurrentChar(scanner))) {
            SkipWhitespaceTrivia(scanner);
        } else {
            if ((CurrentChar(scanner) == '/') && (Lookahead(scanner) == '/')) {
                SkipSingleLineComment(scanner);
            } else {
                if ((CurrentChar(scanner) == '/') && (Lookahead(scanner) == '*')) {
                    SkipMultiLineComment(scanner);
                } else {
                    break;
                }
            }
        }
    }
}

static int64 ReadPositiveIntegerLiteralWithRadix(Scanner* scanner, int32 radix) {
    if (FindCharPosInString(StringCreateFromCStr("0123456789ABCDEF"), ToUpper(CurrentChar(scanner))) == -1) {
        SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->pos);
        ReportError(location, "Unexpected character in integer literal '%c'", CurrentChar(scanner));
    }
    int64 result = 0;
    int32 digit;
    while (true) {
        digit = FindCharPosInString(StringCreateFromCStr("0123456789ABCDEF"), ToUpper(CurrentChar(scanner)));
        if (digit == -1) {
            break;
        }
        if (digit >= radix) {
            SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->pos);
            ReportError(location, "Invalid digit in integer literal '%c'", CurrentChar(scanner));
        }
        result = result * radix + digit;
        AdvanceChar(scanner);
    }
    return result;
}

static Token ReadIntegerLiteral(Scanner* scanner) {
    bool isNegative = false;
    if (CurrentChar(scanner) == '-') {
        isNegative = true;
        AdvanceChar(scanner);
    }
    int32 radix = 10;
    if (CurrentChar(scanner) == '0' && Lookahead(scanner) == 'x') {
        radix = 16;
        AdvanceChar(scanner);
        AdvanceChar(scanner);
    }
    int64 intvalue = ReadPositiveIntegerLiteralWithRadix(scanner, radix);
    Token result = TokenCreateEmpty(scanner->source);
    result.kind = TokenKind_IntegerLiteral;
    result.intvalueIsHex = radix == 16;
    result.intvalue = isNegative ? -intvalue : intvalue;
    return result;
}

static char ReadCharWithEscapeSequence(Scanner* scanner) {
    char ch = AdvanceChar(scanner);
    if (ch == '\\') {
        char escape = AdvanceChar(scanner);
        switch (escape) {
            case 'a': {
                return '\a';
            }
            case 'b': {
                return '\b';
            }
            case 'f': {
                return '\f';
            }
            case 'n': {
                return '\n';
            }
            case 'r': {
                return '\r';
            }
            case 't': {
                return '\t';
            }
            case 'v': {
                return '\v';
            }
            case '\\': {
                return '\\';
            }
            case '"': {
                return '"';
            }
            case '\'': {
                return '\'';
            }
            case '0': {
                return '0';
            }
            case 'x': {
                int64 number = ReadPositiveIntegerLiteralWithRadix(scanner, 16);
                if (number > UCHAR_MAX) {
                    SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->pos);
                    ReportError(location, "Hexadecimal character literal cannot be bigger than '\\xFF'");
                }
                return (char)number;
            }
            default: {
                SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->pos);
                ReportError(location, "Unknown escape sequence '\\%c'", escape);
            }
        }
    }
    return ch;
}

static Token ReadCharacterLiteral(Scanner* scanner) {
    char openingQuote = AdvanceChar(scanner);
    int32 start = scanner->pos;
    char ch = ReadCharWithEscapeSequence(scanner);
    int32 end = scanner->pos;
    char closingQuote = AdvanceChar(scanner);
    if (closingQuote != '\'') {
        SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->start);
        ReportError(location, "Expected closing quote \"'\" character after character literal but got '%c'", closingQuote);
    }
    Token result = TokenCreateEmpty(scanner->source);
    result.kind = TokenKind_CharacterLiteral;
    result.stringValue = SourceGetSubstring(scanner->source, start, end);
    result.intvalue = (int64)ch;
    return result;
}

static Token ReadStringLiteral(Scanner* scanner) {
    char openingQuote = AdvanceChar(scanner);
    int32 start = scanner->pos;
    while (CurrentChar(scanner) != '\0' && CurrentChar(scanner) != '\n') {
        char ch = CurrentChar(scanner);
        if (ch == '\\' && Lookahead(scanner) == '"') {
            AdvanceChar(scanner);
            AdvanceChar(scanner);
            continue;
        }
        if (ch == '"') {
            break;
        }
        AdvanceChar(scanner);
    }
    int32 end = scanner->pos;
    char closingQuote = AdvanceChar(scanner);
    if (closingQuote != '\"') {
        SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->start);
        ReportError(location, "Unterminated string literal");
    }
    Token result = TokenCreateEmpty(scanner->source);
    result.kind = TokenKind_StringLiteral;
    result.stringValue = SourceGetSubstring(scanner->source, start, end);
    return result;
}

static void ReadPreprocessorDirective(Scanner* scanner) {
    assert(CurrentChar(scanner) == '#');
    AdvanceChar(scanner);
    while (IsAlpha(CurrentChar(scanner)) || (CurrentChar(scanner) == '_')) {
        AdvanceChar(scanner);
    }
}

static void ReadIdentifier(Scanner* scanner) {
    while (IsAlpha(CurrentChar(scanner)) || IsDigit(CurrentChar(scanner)) || (CurrentChar(scanner) == '_')) {
        AdvanceChar(scanner);
    }
}

static void ReadToken(Scanner* scanner) {
    scanner->start = scanner->pos;
    scanner->token = TokenCreateEmpty(scanner->source);
    char ch = CurrentChar(scanner);
    switch (ch) {
        case '\0': {
            scanner->token.kind = TokenKind_EndOfFile;
            break;
        }
        case '+': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = TokenKind_PlusEquals;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = TokenKind_Plus;
                AdvanceChar(scanner);
            }
            break;
        }
        case '-': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = TokenKind_MinusEquals;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                if (Lookahead(scanner) == '>') {
                    scanner->token.kind = TokenKind_Arrow;
                    AdvanceChar(scanner);
                    AdvanceChar(scanner);
                } else {
                    if (IsDigit(Lookahead(scanner))) {
                        scanner->token = ReadIntegerLiteral(scanner);
                    } else {
                        scanner->token.kind = TokenKind_Minus;
                        AdvanceChar(scanner);
                    }
                }
            }
            break;
        }
        case '*': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = TokenKind_StarEquals;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = TokenKind_Star;
                AdvanceChar(scanner);
            }
            break;
        }
        case '/': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = TokenKind_SlashEquals;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = TokenKind_Slash;
                AdvanceChar(scanner);
            }
            break;
        }
        case '%': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = TokenKind_PercentEquals;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = TokenKind_Percent;
                AdvanceChar(scanner);
            }
            break;
        }
        case '.': {
            if (PeekChar(scanner, 1) == '.' && PeekChar(scanner, 2)) {
                scanner->token.kind = TokenKind_DotDotDot;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = TokenKind_Dot;
                AdvanceChar(scanner);
            }
            break;
        }
        case ',': {
            scanner->token.kind = TokenKind_Comma;
            AdvanceChar(scanner);
            break;
        }
        case '?': {
            scanner->token.kind = TokenKind_Questionmark;
            AdvanceChar(scanner);
            break;
        }
        case ':': {
            if (Lookahead(scanner) == ':') {
                scanner->token.kind = TokenKind_ColonColon;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = TokenKind_Colon;
                AdvanceChar(scanner);
            }
            break;
        }
        case ';': {
            scanner->token.kind = TokenKind_Semicolon;
            AdvanceChar(scanner);
            break;
        }
        case '~': {
            scanner->token.kind = TokenKind_Tilde;
            AdvanceChar(scanner);
            break;
        }
        case '^': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = TokenKind_HatEquals;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = TokenKind_Hat;
                AdvanceChar(scanner);
            }
            break;
        }
        case '&': {
            if (Lookahead(scanner) == '&') {
                scanner->token.kind = TokenKind_AmpersandAmpersand;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                if (Lookahead(scanner) == '=') {
                    scanner->token.kind = TokenKind_AmpersandEquals;
                    AdvanceChar(scanner);
                    AdvanceChar(scanner);
                } else {
                    scanner->token.kind = TokenKind_Ampersand;
                    AdvanceChar(scanner);
                }
            }
            break;
        }
        case '|': {
            if (Lookahead(scanner) == '|') {
                scanner->token.kind = TokenKind_PipePipe;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                if (Lookahead(scanner) == '=') {
                    scanner->token.kind = TokenKind_PipeEquals;
                    AdvanceChar(scanner);
                    AdvanceChar(scanner);
                } else {
                    scanner->token.kind = TokenKind_Pipe;
                    AdvanceChar(scanner);
                }
            }
            break;
        }
        case '{': {
            scanner->token.kind = TokenKind_LeftBrace;
            AdvanceChar(scanner);
            break;
        }
        case '}': {
            scanner->token.kind = TokenKind_RightBrace;
            AdvanceChar(scanner);
            break;
        }
        case '(': {
            scanner->token.kind = TokenKind_LeftParen;
            AdvanceChar(scanner);
            break;
        }
        case ')': {
            scanner->token.kind = TokenKind_RightParen;
            AdvanceChar(scanner);
            break;
        }
        case '[': {
            scanner->token.kind = TokenKind_LeftBracket;
            AdvanceChar(scanner);
            break;
        }
        case ']': {
            scanner->token.kind = TokenKind_RightBracket;
            AdvanceChar(scanner);
            break;
        }
        case '=': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = TokenKind_EqualsEquals;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                scanner->token.kind = TokenKind_Equals;
                AdvanceChar(scanner);
            }
            break;
        }
        case '!': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = TokenKind_BangEquals;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                AdvanceChar(scanner);
                scanner->token.kind = TokenKind_Bang;
            }
            break;
        }
        case '<': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = TokenKind_LessEquals;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                if (Lookahead(scanner) == '<') {
                    scanner->token.kind = TokenKind_LessLess;
                    AdvanceChar(scanner);
                    AdvanceChar(scanner);
                    if (CurrentChar(scanner) == '=') {
                        scanner->token.kind = TokenKind_LessLessEquals;
                        AdvanceChar(scanner);
                    }
                } else {
                    scanner->token.kind = TokenKind_Less;
                    AdvanceChar(scanner);
                }
            }
            break;
        }
        case '>': {
            if (Lookahead(scanner) == '=') {
                scanner->token.kind = TokenKind_GreaterEquals;
                AdvanceChar(scanner);
                AdvanceChar(scanner);
            } else {
                if (Lookahead(scanner) == '>') {
                    scanner->token.kind = TokenKind_GreaterGreater;
                    AdvanceChar(scanner);
                    AdvanceChar(scanner);
                    if (CurrentChar(scanner) == '=') {
                        scanner->token.kind = TokenKind_GreaterGreaterEquals;
                        AdvanceChar(scanner);
                    }
                } else {
                    scanner->token.kind = TokenKind_Greater;
                    AdvanceChar(scanner);
                }
            }
            break;
        }
        default: {
            if (IsDigit(ch)) {
                scanner->token = ReadIntegerLiteral(scanner);
                break;
            } else {
                if (IsAlpha(ch) || (ch == '_')) {
                    ReadIdentifier(scanner);
                    String identifier = SourceGetSubstring(scanner->source, scanner->start, scanner->pos);
                    TokenKind keywordKind = GetKeywordForIdentifier(identifier);
                    if (keywordKind != TokenKind_EndOfFile) {
                        scanner->token.kind = keywordKind;
                    } else {
                        scanner->token.kind = TokenKind_Identifier;
                    }
                    break;
                } else {
                    if (ch == '#') {
                        ReadPreprocessorDirective(scanner);
                        String identifier = SourceGetSubstring(scanner->source, scanner->start, scanner->pos);
                        TokenKind keywordKind = GetKeywordForIdentifier(identifier);
                        if (keywordKind != TokenKind_EndOfFile) {
                            scanner->token.kind = keywordKind;
                            break;
                        }
                    } else {
                        if (ch == '\'') {
                            scanner->token = ReadCharacterLiteral(scanner);
                            break;
                        } else {
                            if (ch == '"') {
                                scanner->token = ReadStringLiteral(scanner);
                                break;
                            }
                        }
                    }
                }
            }
            SourceLocation location = SourceGetLocationForCharPos(scanner->source, scanner->start);
            ReportError(location, "Unexpected character '%c'", ch);
        }
    }
    scanner->token.sourceStart = scanner->start;
    scanner->token.sourceEnd = scanner->pos;
    scanner->token.sourceString = SourceGetSubstring(scanner->source, scanner->start, scanner->pos);
    if (0) {
        fprintf(stdout, "Token %s", TokenKindToString(scanner->token.kind).cstr);
        if (scanner->token.kind == TokenKind_IntegerLiteral) {
            fprintf(stdout, ", value '%lld'", scanner->token.intvalue);
        }
        if (scanner->token.kind == TokenKind_CharacterLiteral) {
            fprintf(stdout, ", value '%s'", scanner->token.stringValue.cstr);
        }
        if (scanner->token.kind == TokenKind_StringLiteral) {
            fprintf(stdout, ", value '%s'", scanner->token.stringValue.cstr);
        }
        if (scanner->token.kind == TokenKind_Identifier) {
            fprintf(stdout, ", name '%s'", TokenGetText(scanner->token).cstr);
        }
        fprintf(stdout, "\n");
    }
}

static Token NextToken(Scanner* scanner) {
    SkipTrivia(scanner);
    ReadToken(scanner);
    return scanner->token;
}

static int32 GetUnaryOperatorPrecedence(TokenKind kind) {
    switch (kind) {
        case TokenKind_Plus: // Fallthrough
        case TokenKind_Minus: // Fallthrough
        case TokenKind_Bang: // Fallthrough
        case TokenKind_Tilde: // Fallthrough
        case TokenKind_Star: // Fallthrough
        case TokenKind_Ampersand: {
            return 13;
        }
        default: {
            return 0;
        }
    }
}

static bool IsBinaryOperatorRightAssociative(TokenKind kind) {
    switch (kind) {
        case TokenKind_Equals: // Fallthrough
        case TokenKind_PlusEquals: // Fallthrough
        case TokenKind_MinusEquals: // Fallthrough
        case TokenKind_StarEquals: // Fallthrough
        case TokenKind_SlashEquals: // Fallthrough
        case TokenKind_PercentEquals: // Fallthrough
        case TokenKind_HatEquals: // Fallthrough
        case TokenKind_AmpersandEquals: // Fallthrough
        case TokenKind_PipeEquals: // Fallthrough
        case TokenKind_LessLessEquals: // Fallthrough
        case TokenKind_GreaterGreaterEquals: {
            return true;
        }
        default: {
            return false;
        }
    }
}

static int32 GetBinaryOperatorPrecedence(TokenKind kind) {
    switch (kind) {
        case TokenKind_Star: // Fallthrough
        case TokenKind_Slash: // Fallthrough
        case TokenKind_Percent: {
            return 12;
        }
        case TokenKind_Plus: // Fallthrough
        case TokenKind_Minus: {
            return 11;
        }
        case TokenKind_LessLess: // Fallthrough
        case TokenKind_GreaterGreater: {
            return 10;
        }
        case TokenKind_Less: // Fallthrough
        case TokenKind_LessEquals: // Fallthrough
        case TokenKind_Greater: // Fallthrough
        case TokenKind_GreaterEquals: {
            return 9;
        }
        case TokenKind_EqualsEquals: // Fallthrough
        case TokenKind_BangEquals: {
            return 8;
        }
        case TokenKind_Ampersand: {
            return 7;
        }
        case TokenKind_Hat: {
            return 6;
        }
        case TokenKind_Pipe: {
            return 5;
        }
        case TokenKind_AmpersandAmpersand: {
            return 4;
        }
        case TokenKind_PipePipe: {
            return 3;
        }
        default: {
            return 0;
        }
    }
}

struct UnaryOperator; typedef struct UnaryOperator UnaryOperator; struct UnaryOperator {
    TokenKind tokenKind;
    ASTNodeKind operatorKind;
    Type operandType;
    Type resultType;
    bool resultIsRValue;
    bool operandMustBeLValue;
};

static UnaryOperator GetUnaryOperationForToken(Token token, Type operandType) {
    UnaryOperator result;
    result.tokenKind = token.kind;
    result.operandType = operandType;
    result.resultType = operandType;
    result.resultIsRValue = true;
    result.operandMustBeLValue = false;
    if (IsPointerType(operandType) || operandType.kind == TypeKind_PrimitiveCString) {
        if (token.kind == TokenKind_Star) {
            result.operatorKind = ASTNodeKind_Dereference;
            result.resultType = GetBaseTypeForPointerType(operandType);
            result.resultIsRValue = false;
            result.operandMustBeLValue = true;
            return result;
        }
    } else {
        if (IsNumberType(operandType)) {
            if (token.kind == TokenKind_Plus) {
                result.operatorKind = ASTNodeKind_Identity;
                return result;
            }
            if (token.kind == TokenKind_Minus) {
                result.operatorKind = ASTNodeKind_Negation;
                return result;
            }
            if (token.kind == TokenKind_Bang) {
                result.operatorKind = ASTNodeKind_LogicalNegation;
                return result;
            }
            if (token.kind == TokenKind_Tilde) {
                result.operatorKind = ASTNodeKind_BitwiseNegation;
                return result;
            }
        }
    }
    if (token.kind == TokenKind_Ampersand) {
        result.operatorKind = ASTNodeKind_Address;
        result.resultType = GetPointerTypeForBaseType(operandType);
        result.resultIsRValue = false;
        result.operandMustBeLValue = true;
        return result;
    }
    ReportError(TokenGetLocation(token), "No applicable unary operation for combination token '%s', type '%s'", TokenKindToString(token.kind).cstr, TypeGetText(operandType).cstr);
    exit(1);
}

struct BinaryOperator; typedef struct BinaryOperator BinaryOperator; struct BinaryOperator {
    TokenKind tokenKind;
    ASTNodeKind operatorKind;
    Type leftType;
    Type rightType;
    Type resultType;
    bool resultIsRValue;
    bool leftMustBeLValue;
    bool rightMustBeLValue;
};

static BinaryOperator GetBinaryOperationForToken(Token token, Type leftType, Type rightType) {
    BinaryOperator result;
    result.tokenKind = token.kind;
    result.leftType = leftType;
    result.rightType = rightType;
    result.resultType = leftType;
    result.resultIsRValue = true;
    result.leftMustBeLValue = false;
    result.rightMustBeLValue = false;
    if (token.kind == TokenKind_Equals) {
        TypeConversionResult conversion = CanConvertTypeFromTo(rightType, leftType);
        if (conversion == TypeConversionResult_NonConvertible) {
            ReportError(TokenGetLocation(token), "Incompatible types for assignment '%s' = '%s'", TypeGetText(leftType).cstr, TypeGetText(rightType).cstr);
        }
        if (conversion == TypeConversionResult_ExplicitlyConvertible) {
            ReportError(TokenGetLocation(token), "Cannot implicitly convert types for assignment '%s' = '%s'", TypeGetText(leftType).cstr, TypeGetText(rightType).cstr);
        }
        result.operatorKind = ASTNodeKind_Assignment;
        result.leftMustBeLValue = true;
        return result;
    }
    if ((token.kind == TokenKind_Plus) && IsPointerType(leftType) && IsNumberType(rightType)) {
        result.operatorKind = ASTNodeKind_AddToPointer;
        result.resultIsRValue = false;
        result.leftMustBeLValue = true;
        return result;
    }
    if ((token.kind == TokenKind_PlusEquals) && IsPointerType(leftType) && IsNumberType(rightType)) {
        result.operatorKind = ASTNodeKind_AddToPointerAssignment;
        result.resultIsRValue = false;
        result.leftMustBeLValue = true;
        return result;
    }
    if ((token.kind == TokenKind_Minus) && IsPointerType(leftType) && IsNumberType(rightType)) {
        result.operatorKind = ASTNodeKind_SubtractFromPointer;
        result.resultIsRValue = false;
        result.leftMustBeLValue = true;
        return result;
    }
    if ((token.kind == TokenKind_MinusEquals) && IsPointerType(leftType) && IsNumberType(rightType)) {
        result.operatorKind = ASTNodeKind_SubtractFromPointerAssignment;
        result.resultIsRValue = false;
        result.leftMustBeLValue = true;
        return result;
    }
    if ((token.kind == TokenKind_Minus) && IsPointerType(leftType) && IsPointerType(rightType) && leftType.baseIndirectionLevel == rightType.baseIndirectionLevel && (leftType.kind == rightType.kind)) {
        result.operatorKind = ASTNodeKind_DistanceBetweenPointers;
        result.leftMustBeLValue = true;
        result.rightMustBeLValue = true;
        result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveLong);
        return result;
    }
    if (token.kind == TokenKind_EqualsEquals) {
        TypeConversionResult conversion = CanConvertTypeFromTo(leftType, rightType);
        if (conversion == TypeConversionResult_ImplictlyConvertible || conversion == TypeConversionResult_Identical) {
            result.operatorKind = ASTNodeKind_Equals;
            result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
            return result;
        }
    }
    if (token.kind == TokenKind_BangEquals) {
        TypeConversionResult conversion = CanConvertTypeFromTo(leftType, rightType);
        if (conversion == TypeConversionResult_ImplictlyConvertible || conversion == TypeConversionResult_Identical) {
            result.operatorKind = ASTNodeKind_NotEquals;
            result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
            return result;
        }
    }
    if (leftType.kind == TypeKind_Enum && rightType.kind == TypeKind_Enum) {
        switch (token.kind) {
            case TokenKind_EqualsEquals: {
                result.operatorKind = ASTNodeKind_Equals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case TokenKind_BangEquals: {
                result.operatorKind = ASTNodeKind_NotEquals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case TokenKind_Less: {
                result.operatorKind = ASTNodeKind_Less;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case TokenKind_LessEquals: {
                result.operatorKind = ASTNodeKind_LessEquals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case TokenKind_Greater: {
                result.operatorKind = ASTNodeKind_Greater;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case TokenKind_GreaterEquals: {
                result.operatorKind = ASTNodeKind_GreaterEquals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
        }
    }
    if (token.kind == TokenKind_AmpersandAmpersand && !IsVoidType(leftType) && !IsVoidType(rightType)) {
        result.operatorKind = ASTNodeKind_LogicalAnd;
        return result;
    }
    if (token.kind == TokenKind_PipePipe && !IsVoidType(leftType) && !IsVoidType(rightType)) {
        result.operatorKind = ASTNodeKind_LogicalOr;
        return result;
    }
    if (IsNumberType(leftType) && IsNumberType(rightType) || IsCharType(leftType) && IsCharType(rightType)) {
        switch (token.kind) {
            case TokenKind_Plus: {
                result.operatorKind = ASTNodeKind_Add;
                return result;
            }
            case TokenKind_PlusEquals: {
                result.operatorKind = ASTNodeKind_AddAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case TokenKind_Minus: {
                result.operatorKind = ASTNodeKind_Subtract;
                return result;
            }
            case TokenKind_MinusEquals: {
                result.operatorKind = ASTNodeKind_SubtractAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case TokenKind_Star: {
                result.operatorKind = ASTNodeKind_Multiply;
                return result;
            }
            case TokenKind_StarEquals: {
                result.operatorKind = ASTNodeKind_MultiplyAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case TokenKind_Slash: {
                result.operatorKind = ASTNodeKind_Divide;
                return result;
            }
            case TokenKind_SlashEquals: {
                result.operatorKind = ASTNodeKind_DivideAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case TokenKind_Percent: {
                result.operatorKind = ASTNodeKind_Remainder;
                return result;
            }
            case TokenKind_PercentEquals: {
                result.operatorKind = ASTNodeKind_RemainderAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case TokenKind_LessLess: {
                result.operatorKind = ASTNodeKind_BitshiftLeft;
                return result;
            }
            case TokenKind_LessLessEquals: {
                result.operatorKind = ASTNodeKind_BitshiftLeftAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case TokenKind_GreaterGreater: {
                result.operatorKind = ASTNodeKind_BitshiftRight;
                return result;
            }
            case TokenKind_GreaterGreaterEquals: {
                result.operatorKind = ASTNodeKind_BitshiftRightAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case TokenKind_Hat: {
                result.operatorKind = ASTNodeKind_BitwiseXor;
                return result;
            }
            case TokenKind_HatEquals: {
                result.operatorKind = ASTNodeKind_BitwiseXorAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case TokenKind_Ampersand: {
                result.operatorKind = ASTNodeKind_BitwiseAnd;
                return result;
            }
            case TokenKind_AmpersandEquals: {
                result.operatorKind = ASTNodeKind_BitwiseAndAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case TokenKind_Pipe: {
                result.operatorKind = ASTNodeKind_BitwiseOr;
                return result;
            }
            case TokenKind_PipeEquals: {
                result.operatorKind = ASTNodeKind_BitwiseOrAssignment;
                result.resultIsRValue = false;
                result.leftMustBeLValue = true;
                return result;
            }
            case TokenKind_EqualsEquals: {
                result.operatorKind = ASTNodeKind_Equals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case TokenKind_BangEquals: {
                result.operatorKind = ASTNodeKind_NotEquals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case TokenKind_Less: {
                result.operatorKind = ASTNodeKind_Less;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case TokenKind_LessEquals: {
                result.operatorKind = ASTNodeKind_LessEquals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case TokenKind_Greater: {
                result.operatorKind = ASTNodeKind_Greater;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
            case TokenKind_GreaterEquals: {
                result.operatorKind = ASTNodeKind_GreaterEquals;
                result.resultType = TypeCreatePrimitive(TypeKind_PrimitiveBool);
                return result;
            }
        }
    }
    ReportError(TokenGetLocation(token), "No applicable binary operation for combination token '%s', left type '%s', right type '%s'", TokenKindToString(token.kind).cstr, TypeGetText(leftType).cstr, TypeGetText(rightType).cstr);
    exit(1);
}

static bool AreLiteralsEqual(ASTNode* a, ASTNode* b) {
    if (a->kind == ASTNodeKind_EnumValueLiteral) {
        assert(b->kind == ASTNodeKind_EnumValueLiteral);
        Symbol* aSym = a->symbol;
        Symbol* bSym = b->symbol;
        assert(a != NULL);
        assert(b != NULL);
        return StringEquals(aSym->name, bSym->name);
    } else {
        if (a->kind == ASTNodeKind_StringLiteral) {
            assert(b->kind == ASTNodeKind_StringLiteral);
            return StringEquals(a->stringvalue, b->stringvalue);
        } else {
            if (a->kind == ASTNodeKind_IntegerLiteral) {
                assert(b->kind == ASTNodeKind_IntegerLiteral);
                return a->intvalue == b->intvalue;
            } else {
                if (a->kind == ASTNodeKind_CharacterLiteral) {
                    assert(b->kind == ASTNodeKind_CharacterLiteral);
                    return a->intvalue == b->intvalue;
                } else {
                    assert(false && "Unexpected literal type");
                }
            }
        }
    }
    return false;
}

struct Parser; typedef struct Parser Parser; struct Parser {
    SymbolTable* symbolTable;
    Source source;
    Scanner scanner;
    Token tokenPrev;
    Token tokenCur;
    Token tokenNext;
    Token tokenNextAfter;
    int32 loopLevel;
    int32 switchCaseLevel;
    Symbol* currentFunctionSymbol;
};

static Parser ParserCreate(Source source, SymbolTable* symbolTable) {
    Parser result;
    result.symbolTable = symbolTable;
    result.source = source;
    result.scanner = ScannerCreate(source);
    result.tokenPrev = TokenCreateEmpty(source);
    result.tokenCur = NextToken(&result.scanner);
    result.tokenNext = NextToken(&result.scanner);
    result.tokenNextAfter = NextToken(&result.scanner);
    result.loopLevel = 0;
    result.switchCaseLevel = 0;
    result.currentFunctionSymbol = NULL;
    return result;
}

static Token AdvanceToken(Parser* parser) {
    Token result = parser->tokenCur;
    parser->tokenPrev = parser->tokenCur;
    parser->tokenCur = parser->tokenNext;
    parser->tokenNext = parser->tokenNextAfter;
    parser->tokenNextAfter = NextToken(&parser->scanner);
    return result;
}

static Token MatchAndAdvanceToken(Parser* parser, TokenKind kind) {
    if (kind == parser->tokenCur.kind) {
        return AdvanceToken(parser);
    }
    ReportError(TokenGetLocation(parser->tokenCur), "Expected token '%s' but got token '%s'", TokenKindToString(kind).cstr, TokenKindToString(parser->tokenCur.kind).cstr);
    exit(1);
}

ASTNode* ParseStatement(Parser* parser);

ASTNode* ParseExpression(Parser* parser);

ASTNode* ParseVariableDefinitionStatement(Parser* parser, bool isExternal);

Type ParseType(Parser* parser);

static ASTNode* WrapInCompoundStatementIfNecessary(Parser* parser, ASTNode* node) {
    if (node->kind != ASTNodeKind_CompoundStatement) {
        ASTNode* block = ASTNodeCreate(ASTNodeKind_CompoundStatement, parser->symbolTable, node->token);
        ASTNodeArrayPush(&block->children, node);
        node = block;
    }
    return node;
}

static ASTNode* FlattenCompoundStatementIfNecessary(Parser* parser, ASTNode* node) {
    if (node->kind == ASTNodeKind_CompoundStatement) {
        if (node->children.count == 1 && node->children.nodes[0]->kind == ASTNodeKind_CompoundStatement) {
            ASTNode* result = node->children.nodes[0];
            result->symbolTable->parent = node->symbolTable->parent;
            return FlattenCompoundStatementIfNecessary(parser, result);
        }
    }
    return node;
}

static ASTNode* ParseFunctionCallExpression(Parser* parser, ASTNode* left) {
    Token identifier = left->token;
    String identifierText = TokenGetText(identifier);
    Symbol* funcSymbol = GetSymbol(parser->symbolTable, identifierText);
    if (funcSymbol == NULL) {
        ReportError(TokenGetLocation(identifier), "Undeclared function '%s'", identifierText.cstr);
    }
    if (funcSymbol->kind != SymbolKind_Function) {
        ReportError(TokenGetLocation(identifier), "Identifier '%s' is not a callable function", identifierText.cstr);
    }
    Token leftParen = MatchAndAdvanceToken(parser, TokenKind_LeftParen);
    ASTNodeArray argumentList = ASTNodeArrayCreate();
    while (parser->tokenCur.kind != TokenKind_RightParen) {
        ASTNode* argument = ParseExpression(parser);
        ASTNodeArrayPush(&argumentList, argument);
        if (parser->tokenCur.kind == TokenKind_Comma) {
            MatchAndAdvanceToken(parser, TokenKind_Comma);
        } else {
            break;
        }
    }
    Token rightParen = MatchAndAdvanceToken(parser, TokenKind_RightParen);
    if (funcSymbol->isVariadric) {
        if (argumentList.count < funcSymbol->membersSymbolTable->count) {
            ReportError(TokenGetLocation(leftParen), "Function '%s' expects at least %d arguments but %d arguments were provided", funcSymbol->name.cstr, funcSymbol->membersSymbolTable->count, argumentList.count);
        }
    } else {
        if (argumentList.count != funcSymbol->membersSymbolTable->count) {
            ReportError(TokenGetLocation(leftParen), "Function '%s' expects %d arguments but %d arguments were provided", funcSymbol->name.cstr, funcSymbol->membersSymbolTable->count, argumentList.count);
        }
    }
    for (int32 argumentIndex = 0; argumentIndex < funcSymbol->membersSymbolTable->count; argumentIndex += 1) {
        Type argumentType = argumentList.nodes[argumentIndex]->type;
        Type expectedType = funcSymbol->membersSymbolTable->symbols[argumentIndex]->type;
        TypeConversionResult conversion = CanConvertTypeFromTo(argumentType, expectedType);
        if (conversion == TypeConversionResult_NonConvertible) {
            ReportError(TokenGetLocation(leftParen), "Passed incompatible type '%s' for argument %d to function '%s' - expected type '%s'", TypeGetText(argumentType).cstr, argumentIndex + 1, funcSymbol->name.cstr, TypeGetText(expectedType).cstr);
        }
        if (conversion == TypeConversionResult_ExplicitlyConvertible) {
            ReportError(TokenGetLocation(leftParen), "Cannot implicitly convert type '%s' of argument %d  to expected type '%s' in function call of '%s'", TypeGetText(argumentType).cstr, argumentIndex + 1, TypeGetText(expectedType).cstr, funcSymbol->name.cstr);
        }
    }
    ASTNode* result = ASTNodeCreate(ASTNodeKind_FunccallExpression, parser->symbolTable, identifier);
    result->symbol = funcSymbol;
    result->type = funcSymbol->type;
    result->children = argumentList;
    return result;
}

static ASTNode* ParseArrayIndexingExpression(Parser* parser, ASTNode* left) {
    Token leftBracket = MatchAndAdvanceToken(parser, TokenKind_LeftBracket);
    ASTNode* index = ParseExpression(parser);
    Token rightBracket = MatchAndAdvanceToken(parser, TokenKind_RightBracket);
    if (!IsNumberType(index->type)) {
        ReportError(TokenGetLocation(leftBracket), "Array index after '%s' must be number type", TokenKindToString(leftBracket.kind).cstr);
    }
    if (left->symbol == NULL || TypeGetIndirectionLevel(left->symbol->type) == 0) {
        ReportError(TokenGetLocation(leftBracket), "Left hand side of array index operator '%s' is not a known array or pointer", TokenKindToString(leftBracket.kind).cstr);
    }
    ASTNode* result = ASTNodeCreate(ASTNodeKind_Arrayindexing, parser->symbolTable, left->token);
    result->type = left->symbol->type;
    if (result->type.isArray) {
        result->type.isArray = false;
    } else {
        result->type = GetBaseTypeForPointerType(result->type);
    }
    result->left = left;
    result->right = index;
    return result;
}

static ASTNode* ParseMemberAccess(Parser* parser, ASTNode* left, bool isArrow) {
    Token accessorToken;
    if (isArrow) {
        accessorToken = MatchAndAdvanceToken(parser, TokenKind_Arrow);
    } else {
        accessorToken = MatchAndAdvanceToken(parser, TokenKind_Dot);
    }
    if (left->type.kind != TypeKind_Struct && left->type.kind != TypeKind_Union) {
        ReportError(TokenGetLocation(accessorToken), "Attempt to access member of non union or struct identifier '%s'", left->symbol->name.cstr);
    }
    Symbol* containerSymbol = GetSymbol(parser->symbolTable, left->type.name);
    assert(containerSymbol != NULL);
    if (containerSymbol->kind != SymbolKind_Struct && containerSymbol->kind != SymbolKind_Union) {
        ReportError(TokenGetLocation(accessorToken), "Attempt to access member of non union or struct identifier '%s'", containerSymbol->name.cstr);
    }
    if (!containerSymbol->alreadyDefined) {
        ReportError(TokenGetLocation(accessorToken), "Attempt to access member of forward declared but undefined union or struct '%s'", containerSymbol->name.cstr);
    }
    if (isArrow && TypeGetIndirectionLevel(left->type) == 0) {
        ReportError(TokenGetLocation(accessorToken), "Member access of '%s' with '->' is only allowed for pointer types", containerSymbol->name.cstr);
    }
    if (!isArrow && TypeGetIndirectionLevel(left->type) > 0) {
        ReportError(TokenGetLocation(accessorToken), "Member access of '%s' with '.' is only allowed for non-pointer types", containerSymbol->name.cstr);
    }
    Token memberIdentifier = MatchAndAdvanceToken(parser, TokenKind_Identifier);
    String identifierText = TokenGetText(memberIdentifier);
    Symbol* memberSymbol = GetSymbol(containerSymbol->membersSymbolTable, identifierText);
    if (memberSymbol == NULL) {
        ReportError(TokenGetLocation(memberIdentifier), "Undeclared struct or union member '%s'", identifierText.cstr);
    }
    assert(memberSymbol->kind == SymbolKind_Member);
    ASTNode* result = ASTNodeCreate(ASTNodeKind_Memberaccess, parser->symbolTable, accessorToken);
    result->symbol = memberSymbol;
    result->type = memberSymbol->type;
    result->left = left;
    return result;
}

static ASTNode* ParseEnumLiteralExpression(Parser* parser) {
    Token enumIdentifier = MatchAndAdvanceToken(parser, TokenKind_Identifier);
    Token coloncolon = MatchAndAdvanceToken(parser, TokenKind_ColonColon);
    Token valueIdentifier = MatchAndAdvanceToken(parser, TokenKind_Identifier);
    String enumText = TokenGetText(enumIdentifier);
    Symbol* enumSymbol = GetSymbol(parser->symbolTable, enumText);
    if (enumSymbol == NULL) {
        ReportError(TokenGetLocation(enumIdentifier), "Undeclared identifier '%s'", enumText.cstr);
    }
    if (enumSymbol->kind != SymbolKind_Enum) {
        ReportError(TokenGetLocation(enumIdentifier), "Identifier '%s' is not an enum", enumText.cstr);
    }
    String valueText = TokenGetText(valueIdentifier);
    Symbol* valueSymbol = GetSymbol(enumSymbol->membersSymbolTable, valueText);
    if (valueSymbol == NULL) {
        ReportError(TokenGetLocation(enumIdentifier), "Identifier '%s' is not a member of enum '%s'", valueText.cstr, enumText.cstr);
    }
    assert(valueSymbol->kind == SymbolKind_Enumvalue);
    ASTNode* result = ASTNodeCreate(ASTNodeKind_EnumValueLiteral, parser->symbolTable, valueIdentifier);
    result->symbol = valueSymbol;
    result->type = valueSymbol->type;
    return result;
}

static ASTNode* ParseTypeExpression(Parser* parser) {
    Token startToken = parser->tokenCur;
    Type type = ParseType(parser);
    ASTNode* result = ASTNodeCreate(ASTNodeKind_TypeExpression, parser->symbolTable, startToken);
    result->type = type;
    return result;
}

static ASTNode* ParsePrimaryExpression(Parser* parser) {
    switch (parser->tokenCur.kind) {
        case TokenKind_LeftParen: {
            Token leftParen = MatchAndAdvanceToken(parser, TokenKind_LeftParen);
            ASTNode* inner = ParseExpression(parser);
            Token rightParen = MatchAndAdvanceToken(parser, TokenKind_RightParen);
            ASTNode* result = ASTNodeCreate(ASTNodeKind_ParenthesizedExpression, parser->symbolTable, leftParen);
            result->type = inner->type;
            result->left = inner;
            return result;
        }
        case TokenKind_SizeOf: {
            Token sizeofKeyword = MatchAndAdvanceToken(parser, TokenKind_SizeOf);
            Token leftParen = MatchAndAdvanceToken(parser, TokenKind_LeftParen);
            ASTNode* typeExpr = ParseTypeExpression(parser);
            Token rightParen = MatchAndAdvanceToken(parser, TokenKind_RightParen);
            ASTNode* result = ASTNodeCreate(ASTNodeKind_SizeOfExpression, parser->symbolTable, sizeofKeyword);
            result->type = TypeCreatePrimitive(TypeKind_PrimitiveInt);
            result->left = typeExpr;
            result->isRValue = true;
            return result;
        }
        case TokenKind_Identifier: {
            if (parser->tokenNext.kind == TokenKind_ColonColon) {
                return ParseEnumLiteralExpression(parser);
            }
            Token identifier = MatchAndAdvanceToken(parser, TokenKind_Identifier);
            String identifierText = TokenGetText(identifier);
            Symbol* symbol = GetSymbol(parser->symbolTable, identifierText);
            if (symbol == NULL) {
                ReportError(TokenGetLocation(identifier), "Undeclared identifier '%s'", identifierText.cstr);
            }
            ASTNode* result = ASTNodeCreate(ASTNodeKind_Identifier, parser->symbolTable, identifier);
            result->symbol = symbol;
            result->type = symbol->type;
            return result;
        }
        case TokenKind_StringLiteral: {
            Token token = MatchAndAdvanceToken(parser, TokenKind_StringLiteral);
            while (parser->tokenCur.kind == TokenKind_StringLiteral) {
                Token next = MatchAndAdvanceToken(parser, TokenKind_StringLiteral);
                token.sourceEnd = next.sourceEnd;
                token.sourceString = TokenGetText(token);
                token.stringValue = StringAppend(token.stringValue, next.stringValue);
            }
            ASTNode* result = ASTNodeCreate(ASTNodeKind_StringLiteral, parser->symbolTable, token);
            result->isRValue = true;
            result->stringvalue = token.stringValue;
            result->type = TypeCreate(TypeKind_PrimitiveChar, 1, StringCreateEmpty());
            return result;
        }
        case TokenKind_Null: {
            Token token = MatchAndAdvanceToken(parser, TokenKind_Null);
            ASTNode* result = ASTNodeCreate(ASTNodeKind_NullLiteral, parser->symbolTable, token);
            result->isRValue = true;
            result->type = TypeCreate(TypeKind_PrimitiveNull, 1, StringCreateEmpty());
            return result;
        }
        case TokenKind_CharacterLiteral: {
            Token token = MatchAndAdvanceToken(parser, TokenKind_CharacterLiteral);
            ASTNode* result = ASTNodeCreate(ASTNodeKind_CharacterLiteral, parser->symbolTable, token);
            result->isRValue = true;
            result->intvalue = token.intvalue;
            result->stringvalue = token.stringValue;
            result->type = TypeCreatePrimitive(TypeKind_PrimitiveChar);
            return result;
        }
        case TokenKind_True: {
            Token token = MatchAndAdvanceToken(parser, TokenKind_True);
            ASTNode* result = ASTNodeCreate(ASTNodeKind_BoolLiteral, parser->symbolTable, token);
            result->isRValue = true;
            result->intvalue = 1;
            result->type = TypeCreatePrimitive(TypeKind_PrimitiveBool);
            return result;
        }
        case TokenKind_False: {
            Token token = MatchAndAdvanceToken(parser, TokenKind_False);
            ASTNode* result = ASTNodeCreate(ASTNodeKind_BoolLiteral, parser->symbolTable, token);
            result->isRValue = true;
            result->intvalue = 0;
            result->type = TypeCreatePrimitive(TypeKind_PrimitiveBool);
            return result;
        }
        case TokenKind_IntegerLiteral: // Fallthrough
        default: {
            Token token = MatchAndAdvanceToken(parser, TokenKind_IntegerLiteral);
            ASTNode* result = ASTNodeCreate(ASTNodeKind_IntegerLiteral, parser->symbolTable, token);
            result->isRValue = true;
            result->intvalue = token.intvalue;
            if (CHAR_MIN <= token.intvalue && token.intvalue <= CHAR_MAX) {
                result->type = TypeCreatePrimitive(TypeKind_PrimitiveByte);
            } else {
                if (SHRT_MIN <= token.intvalue && token.intvalue <= SHRT_MAX) {
                    result->type = TypeCreatePrimitive(TypeKind_PrimitiveShort);
                } else {
                    if (INT_MIN <= token.intvalue && token.intvalue <= INT_MAX) {
                        result->type = TypeCreatePrimitive(TypeKind_PrimitiveInt);
                    } else {
                        result->type = TypeCreatePrimitive(TypeKind_PrimitiveLong);
                    }
                }
            }
            return result;
        }
    }
}

static ASTNode* ParseArrayLiteralExpression(Parser* parser, Symbol* arraySymbol) {
    assert(arraySymbol->type.isArray);
    Token leftBrace = MatchAndAdvanceToken(parser, TokenKind_LeftBrace);
    ASTNode* result = ASTNodeCreate(ASTNodeKind_ArrayLiteral, parser->symbolTable, leftBrace);
    int32 elementCount = 0;
    while (parser->tokenCur.kind != TokenKind_RightBrace) {
        ASTNode* expression = ParseExpression(parser);
        elementCount += 1;
        Type arrayElemType = GetElementTypeForArrayType(arraySymbol->type);
        TypeConversionResult conversion = CanConvertTypeFromTo(expression->type, arrayElemType);
        if (conversion == TypeConversionResult_NonConvertible || conversion == TypeConversionResult_ExplicitlyConvertible) {
            ReportError(TokenGetLocation(expression->token), "Cannot convert type '%s' of element %d in array initializer to array type '%s'", TypeGetText(expression->type).cstr, elementCount, TypeGetText(arrayElemType).cstr);
        }
        ASTNodeArrayPush(&result->children, expression);
        if (parser->tokenCur.kind == TokenKind_RightBrace) {
            break;
        } else {
            MatchAndAdvanceToken(parser, TokenKind_Comma);
        }
    }
    Token rightBrace = MatchAndAdvanceToken(parser, TokenKind_RightBrace);
    if (arraySymbol->type.arrayElementCount == -1) {
        arraySymbol->type.arrayElementCount = elementCount;
    }
    if (elementCount == 0) {
        ReportError(TokenGetLocation(leftBrace), "Element count cannot be zero in array initializer of array '%s'", arraySymbol->name.cstr);
    }
    if (arraySymbol->type.arrayElementCount != elementCount) {
        ReportError(TokenGetLocation(leftBrace), "Element count %d of array initializer does not match element count %d of array '%s'", elementCount, arraySymbol->type.arrayElementCount, arraySymbol->name.cstr);
    }
    return result;
}

static ASTNode* ParsePostFixExpression(Parser* parser) {
    ASTNode* left = ParsePrimaryExpression(parser);
    bool foundPostfix = false;
    do {
        foundPostfix = false;
        if (parser->tokenCur.kind == TokenKind_LeftParen) {
            foundPostfix = true;
            left = ParseFunctionCallExpression(parser, left);
        }
        if (parser->tokenCur.kind == TokenKind_Dot) {
            foundPostfix = true;
            left = ParseMemberAccess(parser, left, false);
        }
        if (parser->tokenCur.kind == TokenKind_Arrow) {
            foundPostfix = true;
            left = ParseMemberAccess(parser, left, true);
        }
        if (parser->tokenCur.kind == TokenKind_LeftBracket) {
            foundPostfix = true;
            left = ParseArrayIndexingExpression(parser, left);
        }
    } while (foundPostfix);
    if (left->type.isArray) {
        left->isRValue = true;
    }
    return left;
}

ASTNode* ParseBinaryExpression(Parser* parser, int32 parentPrecedence);

ASTNode* ParseUnaryExpression(Parser* parser, int32 parentPrecedence);

static ASTNode* ParseCastExpression(Parser* parser) {
    if (parser->tokenCur.kind != TokenKind_LeftParen || parser->tokenNext.kind != TokenKind_As) {
        return ParsePostFixExpression(parser);
    }
    Token leftParen = MatchAndAdvanceToken(parser, TokenKind_LeftParen);
    Token asKeyword = MatchAndAdvanceToken(parser, TokenKind_As);
    Type targetType = ParseType(parser);
    Token rightParen = MatchAndAdvanceToken(parser, TokenKind_RightParen);
    ASTNode* expression = ParseUnaryExpression(parser, 0);
    TypeConversionResult conversion = CanConvertTypeFromTo(expression->type, targetType);
    if (conversion == TypeConversionResult_NonConvertible) {
        ReportError(TokenGetLocation(asKeyword), "Cast from type '%s' to type '%s' is impossible", TypeGetText(expression->type).cstr, TypeGetText(targetType).cstr);
    }
    ASTNode* result = ASTNodeCreate(ASTNodeKind_CastExpression, parser->symbolTable, asKeyword);
    result->type = targetType;
    result->left = expression;
    return result;
}

static ASTNode* ParseUnaryExpression(Parser* parser, int32 parentPrecedence) {
    ASTNode* left = NULL;
    int32 unaryOperatorPrecedence = GetUnaryOperatorPrecedence(parser->tokenCur.kind);
    if ((unaryOperatorPrecedence != 0) && (unaryOperatorPrecedence >= parentPrecedence)) {
        Token operatorToken = AdvanceToken(parser);
        ASTNode* operand = ParseBinaryExpression(parser, unaryOperatorPrecedence);
        UnaryOperator op = GetUnaryOperationForToken(operatorToken, operand->type);
        if (op.operandMustBeLValue && operand->isRValue) {
            ReportError(TokenGetLocation(operatorToken), "Operand of operator '%s' must be an storage location", TokenKindToString(operatorToken.kind).cstr);
        }
        ASTNode* result = ASTNodeCreate(op.operatorKind, parser->symbolTable, operatorToken);
        result->isRValue = op.resultIsRValue;
        result->type = op.resultType;
        result->left = operand;
        left = result;
    } else {
        left = ParseCastExpression(parser);
    }
    return left;
}

static ASTNode* ParseBinaryExpression(Parser* parser, int32 parentPrecedence) {
    ASTNode* left = ParseUnaryExpression(parser, parentPrecedence);
    while (true) {
        int32 precedence = GetBinaryOperatorPrecedence(parser->tokenCur.kind);
        if (precedence == 0 || precedence < parentPrecedence || precedence == parentPrecedence && !IsBinaryOperatorRightAssociative(parser->tokenCur.kind)) {
            break;
        }
        Token operatorToken = AdvanceToken(parser);
        ASTNode* right = ParseBinaryExpression(parser, precedence);
        BinaryOperator op = GetBinaryOperationForToken(operatorToken, left->type, right->type);
        if (op.leftMustBeLValue && left->isRValue) {
            ReportError(TokenGetLocation(operatorToken), "Left argument of operator '%s' must be an storage location", TokenKindToString(operatorToken.kind).cstr);
        }
        if (op.rightMustBeLValue && right->isRValue) {
            ReportError(TokenGetLocation(operatorToken), "Right argument of operator '%s' must be a storage location", TokenKindToString(operatorToken.kind).cstr);
        }
        ASTNode* result = ASTNodeCreate(op.operatorKind, parser->symbolTable, operatorToken);
        result->isRValue = op.resultIsRValue;
        result->type = op.resultType;
        result->left = left;
        result->right = right;
        left = result;
    }
    return left;
}

static ASTNode* ParseTernaryConditionExpression(Parser* parser) {
    ASTNode* condition = ParseBinaryExpression(parser, 0);
    if (parser->tokenCur.kind == TokenKind_Questionmark) {
        Token questionmark = MatchAndAdvanceToken(parser, TokenKind_Questionmark);
        ASTNode* thenExpression = ParseTernaryConditionExpression(parser);
        Token colon = MatchAndAdvanceToken(parser, TokenKind_Colon);
        ASTNode* elseExpression = ParseTernaryConditionExpression(parser);
        Type type = GetTypeThatFitsBothTypes(thenExpression->type, elseExpression->type);
        if (IsVoidType(type)) {
            ReportError(TokenGetLocation(questionmark), "Incompatible expression types in ternary operator - then branch: '%s', else branch: '%s'", TypeGetText(thenExpression->type).cstr, TypeGetText(elseExpression->type).cstr);
        }
        ASTNode* ternary = ASTNodeCreate(ASTNodeKind_TernaryConditionalExpression, parser->symbolTable, questionmark);
        ternary->left = condition;
        ternary->right = thenExpression;
        ternary->extra1 = elseExpression;
        ternary->type = type;
        ternary->isRValue = true;
        condition = ternary;
    }
    return condition;
}

static ASTNode* ParseAssignmentExpression(Parser* parser) {
    ASTNode* left = ParseTernaryConditionExpression(parser);
    switch (parser->tokenCur.kind) {
        case TokenKind_Equals: // Fallthrough
        case TokenKind_PlusEquals: // Fallthrough
        case TokenKind_MinusEquals: // Fallthrough
        case TokenKind_StarEquals: // Fallthrough
        case TokenKind_SlashEquals: // Fallthrough
        case TokenKind_PercentEquals: // Fallthrough
        case TokenKind_HatEquals: // Fallthrough
        case TokenKind_AmpersandEquals: // Fallthrough
        case TokenKind_PipeEquals: // Fallthrough
        case TokenKind_LessLessEquals: // Fallthrough
        case TokenKind_GreaterGreaterEquals: {
            Token assignmentToken = AdvanceToken(parser);
            ASTNode* right = ParseAssignmentExpression(parser);
            BinaryOperator op = GetBinaryOperationForToken(assignmentToken, left->type, right->type);
            if (left->isRValue) {
                ReportError(TokenGetLocation(assignmentToken), "Left argument of operator '%s' must be an storage location", TokenKindToString(assignmentToken.kind).cstr);
            }
            ASTNode* assignment = ASTNodeCreate(op.operatorKind, parser->symbolTable, assignmentToken);
            assignment->isRValue = op.resultIsRValue;
            assignment->type = op.resultType;
            assignment->left = left;
            assignment->right = right;
            left = assignment;
            break;
        }
        default: {
            break;
        }
    }
    return left;
}

static ASTNode* ParseExpression(Parser* parser) {
    return ParseAssignmentExpression(parser);
}

static ASTNode* ParseExpressionStatement(Parser* parser) {
    ASTNode* expression = ParseExpression(parser);
    Token semicolonToken = MatchAndAdvanceToken(parser, TokenKind_Semicolon);
    ASTNode* result = ASTNodeCreate(ASTNodeKind_ExpressionStatement, parser->symbolTable, expression->token);
    result->left = expression;
    return result;
}

static ASTNode* ParseIfStatement(Parser* parser) {
    Token ifKeyword = MatchAndAdvanceToken(parser, TokenKind_If);
    Token leftParen = MatchAndAdvanceToken(parser, TokenKind_LeftParen);
    ASTNode* condition = ParseExpression(parser);
    Token rightParen = MatchAndAdvanceToken(parser, TokenKind_RightParen);
    ASTNode* thenBranch = ParseStatement(parser);
    thenBranch = WrapInCompoundStatementIfNecessary(parser, thenBranch);
    ASTNode* elseBranch = NULL;
    if (parser->tokenCur.kind == TokenKind_Else) {
        Token elseKeyword = MatchAndAdvanceToken(parser, TokenKind_Else);
        elseBranch = ParseStatement(parser);
        elseBranch = WrapInCompoundStatementIfNecessary(parser, elseBranch);
    }
    ASTNode* result = ASTNodeCreate(ASTNodeKind_IfStatement, parser->symbolTable, ifKeyword);
    result->left = condition;
    result->right = thenBranch;
    result->extra1 = elseBranch;
    return result;
}

static ASTNode* ParseWhileStatement(Parser* parser) {
    Token whileKeyword = MatchAndAdvanceToken(parser, TokenKind_While);
    Token leftParen = MatchAndAdvanceToken(parser, TokenKind_LeftParen);
    ASTNode* condition = ParseExpression(parser);
    Token rightParen = MatchAndAdvanceToken(parser, TokenKind_RightParen);
    parser->loopLevel += 1;
    ASTNode* body = ParseStatement(parser);
    body = WrapInCompoundStatementIfNecessary(parser, body);
    parser->loopLevel -= 1;
    ASTNode* result = ASTNodeCreate(ASTNodeKind_WhileStatement, parser->symbolTable, whileKeyword);
    result->left = condition;
    result->right = body;
    return result;
}

static ASTNode* ParseDoWhileStatement(Parser* parser) {
    Token doKeyword = MatchAndAdvanceToken(parser, TokenKind_Do);
    parser->loopLevel += 1;
    ASTNode* body = ParseStatement(parser);
    body = WrapInCompoundStatementIfNecessary(parser, body);
    parser->loopLevel -= 1;
    Token whileKeyword = MatchAndAdvanceToken(parser, TokenKind_While);
    Token leftParen = MatchAndAdvanceToken(parser, TokenKind_LeftParen);
    ASTNode* condition = ParseExpression(parser);
    Token rightParen = MatchAndAdvanceToken(parser, TokenKind_RightParen);
    Token semicolon = MatchAndAdvanceToken(parser, TokenKind_Semicolon);
    ASTNode* result = ASTNodeCreate(ASTNodeKind_DoWhileStatement, parser->symbolTable, whileKeyword);
    result->left = condition;
    result->right = body;
    return result;
}

static ASTNode* ParseForStatement(Parser* parser) {
    Token forKeyword = MatchAndAdvanceToken(parser, TokenKind_For);
    parser->symbolTable = SymbolTableCreate(parser->symbolTable);
    ASTNode* result = ASTNodeCreate(ASTNodeKind_ForStatement, parser->symbolTable, forKeyword);
    Token leftParen = MatchAndAdvanceToken(parser, TokenKind_LeftParen);
    ASTNode* initializer = NULL;
    if (parser->tokenCur.kind == TokenKind_Let) {
        initializer = ParseVariableDefinitionStatement(parser, false);
    } else {
        initializer = ParseExpressionStatement(parser);
    }
    ASTNode* condition = ParseExpressionStatement(parser);
    ASTNode* iterator = ParseExpression(parser);
    Token rightParen = MatchAndAdvanceToken(parser, TokenKind_RightParen);
    parser->loopLevel += 1;
    ASTNode* body = ParseStatement(parser);
    body = WrapInCompoundStatementIfNecessary(parser, body);
    parser->loopLevel -= 1;
    parser->symbolTable = parser->symbolTable->parent;
    result->left = initializer;
    result->right = condition;
    result->extra1 = iterator;
    result->extra2 = body;
    return result;
}

static ASTNode* ParseReturnStatement(Parser* parser) {
    Token returnKeyword = MatchAndAdvanceToken(parser, TokenKind_Return);
    if (parser->currentFunctionSymbol == NULL) {
        ReportError(TokenGetLocation(returnKeyword), "Invalid 'return' statement found outside of function definition");
    }
    Type functionReturnType = parser->currentFunctionSymbol->type;
    if (IsVoidType(functionReturnType) && parser->tokenCur.kind != TokenKind_Semicolon) {
        ReportError(TokenGetLocation(returnKeyword), "Invalid return expression in void function");
    }
    if (!IsVoidType(functionReturnType) && parser->tokenCur.kind == TokenKind_Semicolon) {
        ReportError(TokenGetLocation(returnKeyword), "Must return expression in non-void function");
    }
    ASTNode* expression = NULL;
    if (parser->tokenCur.kind != TokenKind_Semicolon) {
        expression = ParseExpression(parser);
        TypeConversionResult conversion = CanConvertTypeFromTo(expression->type, functionReturnType);
        if (conversion == TypeConversionResult_NonConvertible) {
            ReportError(TokenGetLocation(returnKeyword), "Incompatible types for return expression '%s'", TokenKindToString(returnKeyword.kind).cstr);
        }
        if (conversion == TypeConversionResult_ExplicitlyConvertible) {
            ReportError(TokenGetLocation(returnKeyword), "Types cannot be implicitly converted for return expression '%s'", TokenKindToString(returnKeyword.kind).cstr);
        }
    }
    Token semicolonToken = MatchAndAdvanceToken(parser, TokenKind_Semicolon);
    ASTNode* result = ASTNodeCreate(ASTNodeKind_ReturnStatement, parser->symbolTable, returnKeyword);
    result->left = expression;
    return result;
}

static ASTNode* ParseBreakStatement(Parser* parser) {
    Token breakKeyword = MatchAndAdvanceToken(parser, TokenKind_Break);
    if (parser->loopLevel == 0 && parser->switchCaseLevel == 0) {
        ReportError(TokenGetLocation(breakKeyword), "Invalid 'break' statement found outside of loop or switch-case definition");
    }
    Token semicolonToken = MatchAndAdvanceToken(parser, TokenKind_Semicolon);
    ASTNode* result = ASTNodeCreate(ASTNodeKind_BreakStatement, parser->symbolTable, breakKeyword);
    return result;
}

static ASTNode* ParseContinueStatement(Parser* parser) {
    Token continueKeyword = MatchAndAdvanceToken(parser, TokenKind_Continue);
    if (parser->loopLevel == 0) {
        ReportError(TokenGetLocation(continueKeyword), "Invalid 'continue' statement found outside of loop definition");
    }
    Token semicolonToken = MatchAndAdvanceToken(parser, TokenKind_Semicolon);
    ASTNode* result = ASTNodeCreate(ASTNodeKind_ContinueStatement, parser->symbolTable, continueKeyword);
    return result;
}

static Type ParseType(Parser* parser) {
    Type type = TypeCreateVoid();
    Token startToken = parser->tokenCur;
    switch (parser->tokenCur.kind) {
        case TokenKind_Void: {
            type.kind = TypeKind_PrimitiveVoid;
            break;
        }
        case TokenKind_Char: {
            type.kind = TypeKind_PrimitiveChar;
            break;
        }
        case TokenKind_Bool: {
            type.kind = TypeKind_PrimitiveBool;
            break;
        }
        case TokenKind_Byte: {
            type.kind = TypeKind_PrimitiveByte;
            break;
        }
        case TokenKind_Short: {
            type.kind = TypeKind_PrimitiveShort;
            break;
        }
        case TokenKind_Int: {
            type.kind = TypeKind_PrimitiveInt;
            break;
        }
        case TokenKind_Long: {
            type.kind = TypeKind_PrimitiveLong;
            break;
        }
        case TokenKind_CString: {
            type.kind = TypeKind_PrimitiveCString;
            break;
        }
        case TokenKind_Identifier: {
            String name = TokenGetText(parser->tokenCur);
            Symbol* symbol = GetSymbol(parser->symbolTable, name);
            if (symbol != NULL) {
                if (symbol->kind == SymbolKind_Struct) {
                    type.kind = TypeKind_Struct;
                    type.name = name;
                    break;
                } else {
                    if (symbol->kind == SymbolKind_Union) {
                        type.kind = TypeKind_Union;
                        type.name = name;
                        break;
                    } else {
                        if (symbol->kind == SymbolKind_Enum) {
                            type.kind = TypeKind_Enum;
                            type.name = name;
                            break;
                        }
                    }
                }
            }
        }
        default: {
            ReportError(TokenGetLocation(parser->tokenCur), "Token '%s' is not a type", TokenGetText(parser->tokenCur).cstr);
        }
    }
    AdvanceToken(parser);
    while (parser->tokenCur.kind == TokenKind_Star) {
        AdvanceToken(parser);
        type = GetPointerTypeForBaseType(type);
    }
    if (type.kind == TypeKind_Struct) {
        Symbol* symbol = GetSymbol(parser->symbolTable, type.name);
        if (!symbol->alreadyDefined && type.baseIndirectionLevel == 0) {
            ReportError(TokenGetLocation(startToken), "Usage of undefined but forward declared type '%s' is only allowed as pointer", type.name.cstr);
        }
    }
    return type;
}

static ASTNode* ParseCompoundStatement(Parser* parser, bool inSwitch) {
    bool startsWithBrace = false;
    Token leftBrace = parser->tokenCur;
    if (parser->tokenCur.kind == TokenKind_LeftBrace || !inSwitch) {
        leftBrace = MatchAndAdvanceToken(parser, TokenKind_LeftBrace);
        startsWithBrace = true;
    }
    parser->symbolTable = SymbolTableCreate(parser->symbolTable);
    ASTNode* result = ASTNodeCreate(ASTNodeKind_CompoundStatement, parser->symbolTable, leftBrace);
    while (parser->tokenCur.kind != TokenKind_RightBrace) {
        if (inSwitch && parser->tokenCur.kind == TokenKind_Case) {
            break;
        }
        if (inSwitch && parser->tokenCur.kind == TokenKind_Default) {
            break;
        }
        ASTNode* statement = ParseStatement(parser);
        ASTNodeArrayPush(&result->children, statement);
    }
    parser->symbolTable = parser->symbolTable->parent;
    if (startsWithBrace) {
        Token rightBrace = MatchAndAdvanceToken(parser, TokenKind_RightBrace);
    }
    return FlattenCompoundStatementIfNecessary(parser, result);
}

static ASTNode* ParseVariableDeclarationWithoutTerminator(Parser* parser, Type type, Token identifier, SymbolScopeKind symbolScopeKind) {
    Symbol* varSymbol = AddSymbol(parser->symbolTable, TokenGetText(identifier), SymbolKind_Variable, symbolScopeKind, type);
    if (varSymbol == NULL) {
        ReportError(TokenGetLocation(identifier), "Symbol was '%s' already declared in current scope", TokenGetText(identifier).cstr);
    }
    if (IsVoidType(type)) {
        ReportError(TokenGetLocation(identifier), "'void' not allowed as variables '%s' storage type", TokenGetText(identifier).cstr);
    }
    if (parser->tokenCur.kind == TokenKind_LeftBracket) {
        int64 arrayElementCount = -1;
        Token leftBracket = MatchAndAdvanceToken(parser, TokenKind_LeftBracket);
        if (parser->tokenCur.kind == TokenKind_IntegerLiteral) {
            Token intLiteral = MatchAndAdvanceToken(parser, TokenKind_IntegerLiteral);
            arrayElementCount = intLiteral.intvalue;
        }
        Token rightBracket = MatchAndAdvanceToken(parser, TokenKind_RightBracket);
        if (arrayElementCount == 0) {
            ReportError(TokenGetLocation(identifier), "Array size cannot be zero for '%s'", TokenGetText(identifier).cstr);
        }
        varSymbol->type.isArray = true;
        varSymbol->type.arrayElementCount = arrayElementCount;
    }
    ASTNode* result = ASTNodeCreate(ASTNodeKind_VariableDeclarationStatement, parser->symbolTable, identifier);
    result->symbol = varSymbol;
    return result;
}

static ASTNode* ParseUnionOrStructDefinitionStatement(Parser* parser, bool isExternal) {
    SymbolScopeKind symbolScopeKind = isExternal ? SymbolScopeKind_Extern : SymbolScopeKind_Global;
    Token structKeyword;
    if (parser->tokenCur.kind == TokenKind_Struct) {
        structKeyword = MatchAndAdvanceToken(parser, TokenKind_Struct);
    } else {
        structKeyword = MatchAndAdvanceToken(parser, TokenKind_Union);
    }
    bool isUnion = structKeyword.kind == TokenKind_Union;
    Token identifier = MatchAndAdvanceToken(parser, TokenKind_Identifier);
    String name = TokenGetText(identifier);
    if (parser->currentFunctionSymbol != NULL) {
        ReportError(TokenGetLocation(identifier), "Unexpected struct or union declaration of '%s' while already parsing function", name.cstr);
    }
    Symbol* structSymbol = GetSymbol(parser->symbolTable, name);
    if (structSymbol != NULL) {
        if (isUnion && structSymbol->kind != SymbolKind_Union) {
            ReportError(TokenGetLocation(identifier), "Another symbol with the same name '%s' but different type was already declared in current scope", TokenGetText(identifier).cstr);
        }
        if (!isUnion && structSymbol->kind != SymbolKind_Struct) {
            ReportError(TokenGetLocation(identifier), "Another symbol with the same name '%s' but different type was already declared in current scope", TokenGetText(identifier).cstr);
        }
        if (structSymbol->scopeKind != symbolScopeKind) {
            ReportError(TokenGetLocation(identifier), "Struct or union '%s was previously declared but with different scope attribute", TokenGetText(identifier).cstr);
        }
    }
    if (structSymbol == NULL) {
        Type type = TypeCreate(isUnion ? TypeKind_Union : TypeKind_Struct, 0, name);
        structSymbol = AddSymbol(parser->symbolTable, name, isUnion ? SymbolKind_Union : SymbolKind_Struct, symbolScopeKind, type);
    }
    if (parser->tokenCur.kind == TokenKind_Semicolon) {
        MatchAndAdvanceToken(parser, TokenKind_Semicolon);
        ASTNode* result = ASTNodeCreate(isUnion ? ASTNodeKind_UnionDeclarationStatement : ASTNodeKind_StructDeclarationStatement, parser->symbolTable, identifier);
        result->symbol = structSymbol;
        return result;
    } else {
        structSymbol->membersSymbolTable = SymbolTableCreate(parser->symbolTable);
        parser->symbolTable = structSymbol->membersSymbolTable;
        Token leftBrace = MatchAndAdvanceToken(parser, TokenKind_LeftBrace);
        while (parser->tokenCur.kind != TokenKind_RightBrace) {
            Type memberType = ParseType(parser);
            Token memberIdent = MatchAndAdvanceToken(parser, TokenKind_Identifier);
            ASTNode* memberNode = ParseVariableDeclarationWithoutTerminator(parser, memberType, memberIdent, SymbolScopeKind_Local);
            memberNode->symbol->kind = SymbolKind_Member;
            MatchAndAdvanceToken(parser, TokenKind_Semicolon);
        }
        Token rightBrace = MatchAndAdvanceToken(parser, TokenKind_RightBrace);
        parser->symbolTable = parser->symbolTable->parent;
        if (structSymbol->membersSymbolTable->count == 0) {
            ReportError(TokenGetLocation(identifier), "Struct or union '%s' needs at least one member", name.cstr);
        }
        MatchAndAdvanceToken(parser, TokenKind_Semicolon);
        if (structSymbol->alreadyDefined) {
            ReportError(TokenGetLocation(identifier), "Duplicate struct or union definition of '%s'", name.cstr);
        }
        structSymbol->alreadyDefined = true;
        ASTNode* result = ASTNodeCreate(isUnion ? ASTNodeKind_UnionDefinitionStatement : ASTNodeKind_StructDefinitionStatement, parser->symbolTable, identifier);
        result->symbol = structSymbol;
        return result;
    }
}

static ASTNode* ParseEnumDefinitionStatement(Parser* parser, bool isExternal) {
    SymbolScopeKind symbolScopeKind = isExternal ? SymbolScopeKind_Extern : SymbolScopeKind_Global;
    Token enumKeyword = MatchAndAdvanceToken(parser, TokenKind_Enum);
    Token classKeyword = MatchAndAdvanceToken(parser, TokenKind_Class);
    Token identifier = MatchAndAdvanceToken(parser, TokenKind_Identifier);
    String name = TokenGetText(identifier);
    if (parser->currentFunctionSymbol != NULL) {
        ReportError(TokenGetLocation(identifier), "Unexpected enum declaration of '%s' while already parsing function", name.cstr);
    }
    Symbol* enumSymbol = GetSymbol(parser->symbolTable, name);
    if (enumSymbol != NULL) {
        if (enumSymbol->kind != SymbolKind_Enum) {
            ReportError(TokenGetLocation(identifier), "Another symbol with the same name '%s' but different type was already declared in current scope", TokenGetText(identifier).cstr);
        }
        if (enumSymbol->scopeKind != symbolScopeKind) {
            ReportError(TokenGetLocation(identifier), "Enum '%s was previously declared but with different scope attribute", TokenGetText(identifier).cstr);
        }
    }
    if (enumSymbol == NULL) {
        Type type = TypeCreate(TypeKind_Enum, 0, name);
        enumSymbol = AddSymbol(parser->symbolTable, name, SymbolKind_Enum, symbolScopeKind, type);
    }
    if (parser->tokenCur.kind == TokenKind_Semicolon) {
        MatchAndAdvanceToken(parser, TokenKind_Semicolon);
        ASTNode* result = ASTNodeCreate(ASTNodeKind_EnumDeclarationStatement, parser->symbolTable, identifier);
        result->symbol = enumSymbol;
        return result;
    } else {
        enumSymbol->membersSymbolTable = SymbolTableCreate(parser->symbolTable);
        parser->symbolTable = enumSymbol->membersSymbolTable;
        int64 valueCounter = 0;
        Token leftBrace = MatchAndAdvanceToken(parser, TokenKind_LeftBrace);
        while (parser->tokenCur.kind != TokenKind_RightBrace) {
            Type memberType = TypeCreate(TypeKind_Enum, 0, enumSymbol->name);
            Token memberIdent = MatchAndAdvanceToken(parser, TokenKind_Identifier);
            ASTNode* memberNode = ParseVariableDeclarationWithoutTerminator(parser, memberType, memberIdent, SymbolScopeKind_Local);
            if (parser->tokenCur.kind == TokenKind_Equals) {
                Token equalsToken = MatchAndAdvanceToken(parser, TokenKind_Equals);
                Token valueToken = MatchAndAdvanceToken(parser, TokenKind_IntegerLiteral);
                if (valueToken.intvalue < valueCounter) {
                    ReportError(TokenGetLocation(identifier), "Assigned value of enum value literal '%s' must chosen such that all enum values of '%s' are unique - chosen value '%lld' would lead to duplicates", TokenGetText(memberIdent).cstr, enumSymbol->name.cstr, valueToken.intvalue);
                }
                valueCounter = valueToken.intvalue;
            }
            memberNode->symbol->kind = SymbolKind_Enumvalue;
            memberNode->symbol->enumValue = valueCounter;
            if (parser->tokenCur.kind == TokenKind_RightBrace) {
                break;
            }
            MatchAndAdvanceToken(parser, TokenKind_Comma);
            valueCounter += 1;
        }
        Token rightBrace = MatchAndAdvanceToken(parser, TokenKind_RightBrace);
        parser->symbolTable = parser->symbolTable->parent;
        if (enumSymbol->membersSymbolTable->count == 0) {
            ReportError(TokenGetLocation(identifier), "Enum '%s' needs at least one member", name.cstr);
        }
        MatchAndAdvanceToken(parser, TokenKind_Semicolon);
        if (enumSymbol->alreadyDefined) {
            ReportError(TokenGetLocation(identifier), "Duplicate enum definition of '%s'", name.cstr);
        }
        enumSymbol->alreadyDefined = true;
        ASTNode* result = ASTNodeCreate(ASTNodeKind_EnumDefinitionStatement, parser->symbolTable, identifier);
        result->symbol = enumSymbol;
        return result;
    }
}

static Symbol* ParseFunctionDeclarationStatementWithoutTerminator(Parser* parser, Type returnType, Token identifier, bool isExternal) {
    if (parser->currentFunctionSymbol != NULL) {
        ReportError(TokenGetLocation(identifier), "Unexpected function declaration of '%s' while already parsing function", TokenGetText(identifier).cstr);
    }
    SymbolScopeKind symbolScopeKind = isExternal ? SymbolScopeKind_Extern : SymbolScopeKind_Global;
    Symbol* functionSymbol = GetSymbol(parser->symbolTable, TokenGetText(identifier));
    if (functionSymbol != NULL) {
        if (functionSymbol->kind != SymbolKind_Function) {
            ReportError(TokenGetLocation(identifier), "Another symbol with the same name '%s' but different type was already declared in current scope", TokenGetText(identifier).cstr);
        }
        if (functionSymbol->scopeKind != symbolScopeKind) {
            ReportError(TokenGetLocation(identifier), "Function '%s was previously declared but with different scope attribute", TokenGetText(identifier).cstr);
        }
    }
    if (functionSymbol == NULL) {
        functionSymbol = AddSymbol(parser->symbolTable, TokenGetText(identifier), SymbolKind_Function, symbolScopeKind, returnType);
    }
    SymbolTable* functionParamsSymbolTable = SymbolTableCreate(parser->symbolTable);
    parser->symbolTable = functionParamsSymbolTable;
    bool isVariadric = false;
    Token leftParen = MatchAndAdvanceToken(parser, TokenKind_LeftParen);
    while (parser->tokenCur.kind != TokenKind_RightParen) {
        if (parser->tokenCur.kind == TokenKind_DotDotDot) {
            MatchAndAdvanceToken(parser, TokenKind_DotDotDot);
            isVariadric = true;
            break;
        }
        Type paramType = ParseType(parser);
        Token paramIdent = MatchAndAdvanceToken(parser, TokenKind_Identifier);
        ASTNode* paramNode = ParseVariableDeclarationWithoutTerminator(parser, paramType, paramIdent, SymbolScopeKind_Local);
        paramNode->symbol->kind = SymbolKind_Parameter;
        if (parser->tokenCur.kind == TokenKind_Comma) {
            MatchAndAdvanceToken(parser, TokenKind_Comma);
        } else {
            break;
        }
    }
    Token rightParen = MatchAndAdvanceToken(parser, TokenKind_RightParen);
    parser->symbolTable = parser->symbolTable->parent;
    if (functionSymbol->membersSymbolTable != NULL) {
        if (!TypesIdentical(returnType, functionSymbol->type)) {
            ReportError(TokenGetLocation(identifier), "Return type of function '%s' does not match return type of a previous declaration", TokenGetText(identifier).cstr);
        }
        if (functionSymbol->isVariadric != isVariadric) {
            ReportError(TokenGetLocation(identifier), "Vadriaticity of function '%s' does not match with a previous declaration", TokenGetText(identifier).cstr);
        }
        if (functionParamsSymbolTable->count != functionSymbol->membersSymbolTable->count) {
            ReportError(TokenGetLocation(leftParen), "Function '%s' was previously declared with %d parameters wheras new declaration has %d parameters", functionSymbol->name.cstr, functionSymbol->membersSymbolTable->count, functionParamsSymbolTable->count);
        }
        for (int32 paramIndex = 0; paramIndex < functionParamsSymbolTable->count; paramIndex += 1) {
            Type paramType = functionParamsSymbolTable->symbols[paramIndex]->type;
            Type previosType = functionSymbol->membersSymbolTable->symbols[paramIndex]->type;
            if (!TypesIdentical(paramType, previosType)) {
                ReportError(TokenGetLocation(leftParen), "Previous function '%s' parameter %d declared type differs from current declared type", functionSymbol->name.cstr, paramIndex + 1);
            }
        }
    }
    functionSymbol->membersSymbolTable = functionParamsSymbolTable;
    functionSymbol->isVariadric = isVariadric;
    return functionSymbol;
}

static ASTNode* ParseFunctionDefinitionStatement(Parser* parser, bool isExternal) {
    Token funKeyword = MatchAndAdvanceToken(parser, TokenKind_Fun);
    Type type = ParseType(parser);
    Token identifier = MatchAndAdvanceToken(parser, TokenKind_Identifier);
    Symbol* functionSymbol = ParseFunctionDeclarationStatementWithoutTerminator(parser, type, identifier, isExternal);
    ASTNode* body = NULL;
    if (parser->tokenCur.kind == TokenKind_Semicolon) {
        MatchAndAdvanceToken(parser, TokenKind_Semicolon);
    } else {
        if (isExternal) {
            ReportError(TokenGetLocation(identifier), "Cannot define external function '%s'", TokenGetText(identifier).cstr);
        }
        if (functionSymbol->alreadyDefined) {
            ReportError(TokenGetLocation(identifier), "Duplicate function definition of '%s'", TokenGetText(identifier).cstr);
        }
        parser->symbolTable = functionSymbol->membersSymbolTable;
        parser->currentFunctionSymbol = functionSymbol;
        body = ParseCompoundStatement(parser, false);
        functionSymbol->alreadyDefined = true;
        parser->currentFunctionSymbol = NULL;
        parser->symbolTable = parser->symbolTable->parent;
    }
    ASTNode* result = ASTNodeCreate(body == NULL ? ASTNodeKind_FunctionDeclarationStatement : ASTNodeKind_FunctionDefinitionStatement, parser->symbolTable, identifier);
    result->symbol = functionSymbol;
    result->left = body;
    return result;
}

static ASTNode* ParseVariableDefinitionStatement(Parser* parser, bool isExternal) {
    Token letKeyword = MatchAndAdvanceToken(parser, TokenKind_Let);
    bool isLocalPersist = false;
    if (parser->tokenCur.kind == TokenKind_LocalPersist) {
        Token localPersist = MatchAndAdvanceToken(parser, TokenKind_LocalPersist);
        isLocalPersist = true;
    }
    Type type = ParseType(parser);
    Token identifier = MatchAndAdvanceToken(parser, TokenKind_Identifier);
    SymbolScopeKind symbolScopeKind = parser->currentFunctionSymbol == NULL ? SymbolScopeKind_Global : SymbolScopeKind_Local;
    if (isLocalPersist) {
        if (symbolScopeKind != SymbolScopeKind_Local) {
            ReportError(TokenGetLocation(identifier), "Cannot mark global variable as localpersist '%s'", TokenGetText(identifier).cstr);
        }
        symbolScopeKind = SymbolScopeKind_LocalPersist;
    }
    if (isExternal) {
        if (symbolScopeKind != SymbolScopeKind_Global) {
            ReportError(TokenGetLocation(identifier), "Cannot mark local variable as external '%s'", TokenGetText(identifier).cstr);
        }
        symbolScopeKind = SymbolScopeKind_Extern;
    }
    ASTNode* result = ParseVariableDeclarationWithoutTerminator(parser, type, identifier, symbolScopeKind);
    if (parser->tokenCur.kind == TokenKind_Equals) {
        Token equalsToken = MatchAndAdvanceToken(parser, TokenKind_Equals);
        ASTNode* initializer = NULL;
        if (result->symbol->type.isArray) {
            initializer = ParseArrayLiteralExpression(parser, result->symbol);
        } else {
            initializer = ParseExpression(parser);
        }
        result->left = initializer;
    }
    Token semicolonToken = MatchAndAdvanceToken(parser, TokenKind_Semicolon);
    return result;
}

static ASTNode* ParseDefinitionStatement(Parser* parser) {
    bool isExternal = false;
    if (parser->tokenCur.kind == TokenKind_Extern) {
        isExternal = true;
        AdvanceToken(parser);
    }
    if (parser->tokenCur.kind == TokenKind_Enum) {
        return ParseEnumDefinitionStatement(parser, isExternal);
    } else {
        if (parser->tokenCur.kind == TokenKind_Struct || parser->tokenCur.kind == TokenKind_Union) {
            return ParseUnionOrStructDefinitionStatement(parser, isExternal);
        } else {
            if (parser->tokenCur.kind == TokenKind_Fun) {
                return ParseFunctionDefinitionStatement(parser, isExternal);
            } else {
                return ParseVariableDefinitionStatement(parser, isExternal);
            }
        }
    }
}

static ASTNode* ParseCaseStatement(Parser* parser, ASTNode* switchExpression) {
    Token caseLabel = TokenCreateEmpty(parser->source);
    ASTNode* caseExpression = NULL;
    if (parser->tokenCur.kind == TokenKind_Case) {
        caseLabel = MatchAndAdvanceToken(parser, TokenKind_Case);
        if (parser->switchCaseLevel == 0) {
            ReportError(TokenGetLocation(caseLabel), "Unexpected case label outside of switch statement");
        }
        caseExpression = ParseExpression(parser);
        if (caseExpression->kind != ASTNodeKind_IntegerLiteral && caseExpression->kind != ASTNodeKind_StringLiteral && caseExpression->kind != ASTNodeKind_CharacterLiteral && caseExpression->kind != ASTNodeKind_EnumValueLiteral) {
            ReportError(TokenGetLocation(caseExpression->token), "Expected literal in case label but got '%s'", TokenKindToString(caseExpression->token.kind).cstr);
        }
        TypeConversionResult conversion = CanConvertTypeFromTo(caseExpression->type, switchExpression->type);
        if (conversion != TypeConversionResult_Identical && conversion != TypeConversionResult_ImplictlyConvertible) {
            ReportError(TokenGetLocation(caseExpression->token), "Cannot convert type '%s' of case label literal '%s' to its switch expression type '%s'", TypeGetText(caseExpression->type).cstr, TokenGetText(caseExpression->token).cstr, TypeGetText(switchExpression->type).cstr);
        }
    } else {
        caseLabel = MatchAndAdvanceToken(parser, TokenKind_Default);
        if (parser->switchCaseLevel == 0) {
            ReportError(TokenGetLocation(caseLabel), "Unexpected default case label outside of switch statement");
        }
    }
    Token colonToken = MatchAndAdvanceToken(parser, TokenKind_Colon);
    ASTNode* body = ParseCompoundStatement(parser, true);
    if (body->children.count == 0) {
        body = NULL;
    }
    ASTNode* result = ASTNodeCreate(caseLabel.kind == TokenKind_Case ? ASTNodeKind_CaseStatement : ASTNodeKind_DefaultStatement, parser->symbolTable, caseLabel);
    result->left = body;
    result->right = caseExpression;
    return result;
}

static ASTNode* ParseSwitchStatement(Parser* parser) {
    Token switchKeyword = MatchAndAdvanceToken(parser, TokenKind_Switch);
    Token leftParen = MatchAndAdvanceToken(parser, TokenKind_LeftParen);
    ASTNode* switchExpression = ParseExpression(parser);
    Token rightParen = MatchAndAdvanceToken(parser, TokenKind_RightParen);
    parser->switchCaseLevel += 1;
    Token leftBrace = MatchAndAdvanceToken(parser, TokenKind_LeftBrace);
    int32 defaultTokenEncountered = false;
    ASTNodeArray caseStatements = ASTNodeArrayCreate();
    while (parser->tokenCur.kind != TokenKind_EndOfFile) {
        if (parser->tokenCur.kind == TokenKind_RightBrace) {
            break;
        }
        ASTNode* caseStatement = ParseCaseStatement(parser, switchExpression);
        if (defaultTokenEncountered) {
            ReportError(TokenGetLocation(caseStatement->token), "Unexpected case statement after default statement was already defined");
        }
        if (caseStatement->kind == ASTNodeKind_DefaultStatement) {
            defaultTokenEncountered = true;
        }
        ASTNodeArrayPush(&caseStatements, caseStatement);
    }
    Token rightBrace = MatchAndAdvanceToken(parser, TokenKind_RightBrace);
    parser->switchCaseLevel -= 1;
    if (caseStatements.count == 0) {
        ReportError(TokenGetLocation(switchKeyword), "Empty switch statements are not allowed");
    }
    for (int32 index = 0; index < caseStatements.count; index += 1) {
        ASTNode* a = caseStatements.nodes[index];
        for (int32 inner = index + 1; inner < caseStatements.count; inner += 1) {
            ASTNode* b = caseStatements.nodes[inner];
            if (a->right && b->right && AreLiteralsEqual(a->right, b->right)) {
                ReportError(TokenGetLocation(b->token), "Duplicate switch case literal '%s'", TokenGetText(b->right->token).cstr);
            }
        }
    }
    ASTNode* result = ASTNodeCreate(ASTNodeKind_SwitchStatement, parser->symbolTable, switchKeyword);
    result->left = switchExpression;
    result->children = caseStatements;
    return result;
}

static ASTNode* ParseStatement(Parser* parser) {
    switch (parser->tokenCur.kind) {
        case TokenKind_LeftBrace: {
            return ParseCompoundStatement(parser, false);
        }
        case TokenKind_If: {
            return ParseIfStatement(parser);
        }
        case TokenKind_Do: {
            return ParseDoWhileStatement(parser);
        }
        case TokenKind_While: {
            return ParseWhileStatement(parser);
        }
        case TokenKind_For: {
            return ParseForStatement(parser);
        }
        case TokenKind_Return: {
            return ParseReturnStatement(parser);
        }
        case TokenKind_Break: {
            return ParseBreakStatement(parser);
        }
        case TokenKind_Continue: {
            return ParseContinueStatement(parser);
        }
        case TokenKind_Switch: {
            return ParseSwitchStatement(parser);
        }
        case TokenKind_Extern: // Fallthrough
        case TokenKind_Struct: // Fallthrough
        case TokenKind_Union: // Fallthrough
        case TokenKind_Enum: // Fallthrough
        case TokenKind_Fun: // Fallthrough
        case TokenKind_Let: {
            return ParseDefinitionStatement(parser);
        }
        default: {
            return ParseExpressionStatement(parser);
        }
    }
}

static ASTNode* ParseGlobalStatements(Parser* parser) {
    Token root = TokenCreateEmpty(parser->source);
    ASTNode* result = ASTNodeCreate(ASTNodeKind_Root, parser->symbolTable, root);
    while (parser->tokenCur.kind != TokenKind_EndOfFile) {
        bool foundDirectives = true;
        while (foundDirectives) {
            foundDirectives = false;
            while (parser->tokenCur.kind == TokenKind_Typedef) {
                MatchAndAdvanceToken(parser, TokenKind_Typedef);
                while (parser->tokenCur.kind != TokenKind_Semicolon) {
                    AdvanceToken(parser);
                }
                MatchAndAdvanceToken(parser, TokenKind_Semicolon);
                foundDirectives = true;
            }
            while (parser->tokenCur.kind == TokenKind_IncludeDirective) {
                MatchAndAdvanceToken(parser, TokenKind_IncludeDirective);
                if (parser->tokenCur.kind == TokenKind_Less) {
                    MatchAndAdvanceToken(parser, TokenKind_Less);
                    AdvanceToken(parser);
                    MatchAndAdvanceToken(parser, TokenKind_Dot);
                    AdvanceToken(parser);
                    MatchAndAdvanceToken(parser, TokenKind_Greater);
                } else {
                    MatchAndAdvanceToken(parser, TokenKind_StringLiteral);
                }
                foundDirectives = true;
            }
            while (parser->tokenCur.kind == TokenKind_PragmaDirective) {
                MatchAndAdvanceToken(parser, TokenKind_PragmaDirective);
                MatchAndAdvanceToken(parser, TokenKind_Identifier);
                foundDirectives = true;
            }
            while (parser->tokenCur.kind == TokenKind_IfDirective) {
                MatchAndAdvanceToken(parser, TokenKind_IfDirective);
                AdvanceToken(parser);
                foundDirectives = true;
            }
            while (parser->tokenCur.kind == TokenKind_EndIfDefinedDirective) {
                MatchAndAdvanceToken(parser, TokenKind_EndIfDefinedDirective);
                foundDirectives = true;
            }
            while (parser->tokenCur.kind == TokenKind_DefineDirective) {
                MatchAndAdvanceToken(parser, TokenKind_DefineDirective);
                if (parser->tokenCur.kind == TokenKind_Let) {
                    MatchAndAdvanceToken(parser, TokenKind_Let);
                } else {
                    if (parser->tokenCur.kind == TokenKind_As) {
                        MatchAndAdvanceToken(parser, TokenKind_As);
                    } else {
                        if (parser->tokenCur.kind == TokenKind_Byte) {
                            MatchAndAdvanceToken(parser, TokenKind_Byte);
                            MatchAndAdvanceToken(parser, TokenKind_Char);
                        } else {
                            if (parser->tokenCur.kind == TokenKind_LocalPersist) {
                                MatchAndAdvanceToken(parser, TokenKind_LocalPersist);
                                MatchAndAdvanceToken(parser, TokenKind_Identifier);
                            } else {
                                MatchAndAdvanceToken(parser, TokenKind_Fun);
                            }
                        }
                    }
                }
                foundDirectives = true;
            }
        }
        ASTNode* statement = ParseDefinitionStatement(parser);
        ASTNodeArrayPush(&result->children, statement);
    }
    return result;
}

struct Emitter; typedef struct Emitter Emitter; struct Emitter {
    FILE* outFile;
    int32 indentationLevel;
};

static Emitter EmitterCreate(String emitFilepath) {
    FILE* outFile = fopen(emitFilepath.cstr, "w");
    if (outFile == NULL) {
        fprintf(stderr, "Cannot open file for writing: '%s'", emitFilepath.cstr);
        exit(1);
    }
    Emitter result;
    result.outFile = outFile;
    result.indentationLevel = 0;
    return result;
}

static void EmitNewLine(Emitter* emitter) {
    fprintf(emitter->outFile, "\n");
    for (int32 index = 0; index < emitter->indentationLevel; index += 1) {
        fprintf(emitter->outFile, "    ");
    }
}

void EmitType(Emitter* emitter, Type type);

void EmitExpression(Emitter* emitter, ASTNode* node);

void EmitStatement(Emitter* emitter, ASTNode* node);

static void EmitCastExpression(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "(");
    EmitType(emitter, node->type);
    fprintf(emitter->outFile, ")");
    EmitExpression(emitter, node->left);
}

static void EmitSizeOfExpression(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "sizeof(");
    EmitType(emitter, node->left->type);
    fprintf(emitter->outFile, ")");
}

static void EmitParenthesizedExpression(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "(");
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, ")");
}

static void EmitUnaryExpression(Emitter* emitter, ASTNode* node) {
    if (node->kind == ASTNodeKind_Identity) {
        EmitExpression(emitter, node->left);
        return;
    }
    switch (node->kind) {
        case ASTNodeKind_Negation: {
            fprintf(emitter->outFile, "-");
            break;
        }
        case ASTNodeKind_LogicalNegation: {
            fprintf(emitter->outFile, "!");
            break;
        }
        case ASTNodeKind_BitwiseNegation: {
            fprintf(emitter->outFile, "~");
            break;
        }
        case ASTNodeKind_Address: {
            fprintf(emitter->outFile, "&");
            break;
        }
        case ASTNodeKind_Dereference: {
            fprintf(emitter->outFile, "*");
            break;
        }
        default: {
            fprintf(stdout, "Unexpected unary operation kind in emitter %d", node->kind);
            exit(1);
        }
    }
    EmitExpression(emitter, node->left);
}

static void EmitBinaryExpression(Emitter* emitter, ASTNode* node) {
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, " %s ", TokenKindToString(node->token.kind).cstr);
    EmitExpression(emitter, node->right);
}

static void EmitTernaryConditionalExpression(Emitter* emitter, ASTNode* node) {
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, " ? ");
    EmitExpression(emitter, node->right);
    fprintf(emitter->outFile, " : ");
    EmitExpression(emitter, node->extra1);
}

static void EmitEnumLiteralSymbol(Emitter* emitter, Symbol* enumLiteral) {
    fprintf(emitter->outFile, "%s_%s", enumLiteral->type.name.cstr, enumLiteral->name.cstr);
}

static void EmitBoolLiteral(Emitter* emitter, ASTNode* node) {
    if (node->intvalue == 0) {
        fprintf(emitter->outFile, "false");
    } else {
        fprintf(emitter->outFile, "true");
    }
}

static void EmitEnumLiteral(Emitter* emitter, ASTNode* node) {
    EmitEnumLiteralSymbol(emitter, node->symbol);
}

static void EmitCharacterLiteral(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "'%s'", node->stringvalue.cstr);
}

static void EmitIntegerLiteral(Emitter* emitter, ASTNode* node) {
    assert(node->token.kind == TokenKind_IntegerLiteral);
    if (node->token.intvalueIsHex) {
        fprintf(emitter->outFile, "%s", TokenGetText(node->token).cstr);
    } else {
        fprintf(emitter->outFile, "%lld", node->intvalue);
    }
}

static void EmitStringLiteral(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "\"%s\"", node->stringvalue.cstr);
}

static void EmitArrayLiteral(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "{ ");
    for (int32 index = 0; index < node->children.count; index += 1) {
        EmitExpression(emitter, node->children.nodes[index]);
        if (index != node->children.count - 1) {
            fprintf(emitter->outFile, ", ");
        }
    }
    fprintf(emitter->outFile, " }");
}

static void EmitNullLiteral(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "NULL");
}

static void EmitIdentifier(Emitter* emitter, ASTNode* node) {
    String name = node->symbol->name;
    fprintf(emitter->outFile, "%s", name.cstr);
}

static void EmitFunctionCallExpression(Emitter* emitter, ASTNode* node) {
    String funcName = node->symbol->name;
    fprintf(emitter->outFile, "%s(", funcName.cstr);
    for (int32 index = 0; index < node->children.count; index += 1) {
        EmitExpression(emitter, node->children.nodes[index]);
        if (index != node->children.count - 1) {
            fprintf(emitter->outFile, ", ");
        }
    }
    fprintf(emitter->outFile, ")");
}

static void EmitArrayIndexingExpression(Emitter* emitter, ASTNode* node) {
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, "[");
    EmitExpression(emitter, node->right);
    fprintf(emitter->outFile, "]");
}

static void EmitMemberAccessExpression(Emitter* emitter, ASTNode* node) {
    EmitExpression(emitter, node->left);
    if (IsPointerType(node->left->type)) {
        fprintf(emitter->outFile, "->");
    } else {
        fprintf(emitter->outFile, ".");
    }
    String memberName = node->symbol->name;
    fprintf(emitter->outFile, "%s", memberName.cstr);
}

static void EmitExpression(Emitter* emitter, ASTNode* node) {
    switch (node->kind) {
        case ASTNodeKind_CastExpression: {
            EmitCastExpression(emitter, node);
            break;
        }
        case ASTNodeKind_SizeOfExpression: {
            EmitSizeOfExpression(emitter, node);
            break;
        }
        case ASTNodeKind_ParenthesizedExpression: {
            EmitParenthesizedExpression(emitter, node);
            break;
        }
        case ASTNodeKind_Identity: // Fallthrough
        case ASTNodeKind_Negation: // Fallthrough
        case ASTNodeKind_LogicalNegation: // Fallthrough
        case ASTNodeKind_BitwiseNegation: // Fallthrough
        case ASTNodeKind_Address: // Fallthrough
        case ASTNodeKind_Dereference: {
            EmitUnaryExpression(emitter, node);
            break;
        }
        case ASTNodeKind_Assignment: // Fallthrough
        case ASTNodeKind_Add: // Fallthrough
        case ASTNodeKind_AddAssignment: // Fallthrough
        case ASTNodeKind_Subtract: // Fallthrough
        case ASTNodeKind_SubtractAssignment: // Fallthrough
        case ASTNodeKind_Multiply: // Fallthrough
        case ASTNodeKind_MultiplyAssignment: // Fallthrough
        case ASTNodeKind_Divide: // Fallthrough
        case ASTNodeKind_DivideAssignment: // Fallthrough
        case ASTNodeKind_Remainder: // Fallthrough
        case ASTNodeKind_RemainderAssignment: // Fallthrough
        case ASTNodeKind_Equals: // Fallthrough
        case ASTNodeKind_NotEquals: // Fallthrough
        case ASTNodeKind_Less: // Fallthrough
        case ASTNodeKind_LessEquals: // Fallthrough
        case ASTNodeKind_Greater: // Fallthrough
        case ASTNodeKind_GreaterEquals: // Fallthrough
        case ASTNodeKind_AddToPointer: // Fallthrough
        case ASTNodeKind_AddToPointerAssignment: // Fallthrough
        case ASTNodeKind_SubtractFromPointer: // Fallthrough
        case ASTNodeKind_SubtractFromPointerAssignment: // Fallthrough
        case ASTNodeKind_DistanceBetweenPointers: // Fallthrough
        case ASTNodeKind_BitshiftLeft: // Fallthrough
        case ASTNodeKind_BitshiftLeftAssignment: // Fallthrough
        case ASTNodeKind_BitshiftRight: // Fallthrough
        case ASTNodeKind_BitshiftRightAssignment: // Fallthrough
        case ASTNodeKind_BitwiseAnd: // Fallthrough
        case ASTNodeKind_BitwiseAndAssignment: // Fallthrough
        case ASTNodeKind_BitwiseOr: // Fallthrough
        case ASTNodeKind_BitwiseOrAssignment: // Fallthrough
        case ASTNodeKind_BitwiseXor: // Fallthrough
        case ASTNodeKind_BitwiseXorAssignment: // Fallthrough
        case ASTNodeKind_LogicalAnd: // Fallthrough
        case ASTNodeKind_LogicalOr: {
            EmitBinaryExpression(emitter, node);
            break;
        }
        case ASTNodeKind_TernaryConditionalExpression: {
            EmitTernaryConditionalExpression(emitter, node);
            break;
        }
        case ASTNodeKind_Identifier: {
            EmitIdentifier(emitter, node);
            break;
        }
        case ASTNodeKind_BoolLiteral: {
            EmitBoolLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_CharacterLiteral: {
            EmitCharacterLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_IntegerLiteral: {
            EmitIntegerLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_StringLiteral: {
            EmitStringLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_EnumValueLiteral: {
            EmitEnumLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_ArrayLiteral: {
            EmitArrayLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_NullLiteral: {
            EmitNullLiteral(emitter, node);
            break;
        }
        case ASTNodeKind_Arrayindexing: {
            EmitArrayIndexingExpression(emitter, node);
            break;
        }
        case ASTNodeKind_Memberaccess: {
            EmitMemberAccessExpression(emitter, node);
            break;
        }
        case ASTNodeKind_FunccallExpression: {
            EmitFunctionCallExpression(emitter, node);
            break;
        }
        default: {
            fprintf(stderr, "Unknown expression in emitter: %d\n", node->kind);
            exit(1);
        }
    }
}

static void EmitExpressionStatement(Emitter* emitter, ASTNode* node) {
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, ";");
}

static void EmitIfStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "if (");
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, ") ");
    EmitStatement(emitter, node->right);
    if (node->extra1 != NULL) {
        fprintf(emitter->outFile, " else ");
        EmitStatement(emitter, node->extra1);
    }
}

static void EmitDoWhileStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "do ");
    EmitStatement(emitter, node->right);
    fprintf(emitter->outFile, " while (");
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, ");");
}

static void EmitWhileStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "while (");
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, ") ");
    EmitStatement(emitter, node->right);
}

static void EmitForStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "for (");
    EmitStatement(emitter, node->left);
    fprintf(emitter->outFile, " ");
    EmitStatement(emitter, node->right);
    fprintf(emitter->outFile, " ");
    EmitExpression(emitter, node->extra1);
    fprintf(emitter->outFile, ") ");
    EmitStatement(emitter, node->extra2);
}

static void EmitReturnStatement(Emitter* emitter, ASTNode* node) {
    if (node->left == NULL) {
        fprintf(emitter->outFile, "return;");
    } else {
        fprintf(emitter->outFile, "return ");
        EmitExpression(emitter, node->left);
        fprintf(emitter->outFile, ";");
    }
}

static void EmitBreakStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "break;");
}

static void EmitContinueStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "continue;");
}

static void EmitCaseStatement(Emitter* emitter, ASTNode* node) {
    if (node->kind == ASTNodeKind_DefaultStatement) {
        fprintf(emitter->outFile, "default: ");
        if (node->left != NULL) {
            EmitStatement(emitter, node->left);
        } else {
            fprintf(emitter->outFile, "// Fallthrough");
        }
    } else {
        fprintf(emitter->outFile, "case ");
        EmitExpression(emitter, node->right);
        fprintf(emitter->outFile, ": ");
        if (node->left != NULL) {
            EmitStatement(emitter, node->left);
        } else {
            fprintf(emitter->outFile, "// Fallthrough");
        }
    }
}

static void EmitSwitchStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "switch (");
    EmitExpression(emitter, node->left);
    fprintf(emitter->outFile, ") {");
    emitter->indentationLevel += 1;
    EmitNewLine(emitter);
    for (int32 index = 0; index < node->children.count; index += 1) {
        EmitCaseStatement(emitter, node->children.nodes[index]);
        if (index == node->children.count - 1) {
            emitter->indentationLevel -= 1;
        }
        EmitNewLine(emitter);
    }
    fprintf(emitter->outFile, "}");
}

static void EmitType(Emitter* emitter, Type type) {
    switch (type.kind) {
        case TypeKind_PrimitiveVoid: {
            fprintf(emitter->outFile, "void");
            break;
        }
        case TypeKind_PrimitiveBool: {
            fprintf(emitter->outFile, "bool");
            break;
        }
        case TypeKind_PrimitiveChar: {
            fprintf(emitter->outFile, "char");
            break;
        }
        case TypeKind_PrimitiveByte: {
            fprintf(emitter->outFile, "int8");
            break;
        }
        case TypeKind_PrimitiveShort: {
            fprintf(emitter->outFile, "int16");
            break;
        }
        case TypeKind_PrimitiveInt: {
            fprintf(emitter->outFile, "int32");
            break;
        }
        case TypeKind_PrimitiveLong: {
            fprintf(emitter->outFile, "int64");
            break;
        }
        case TypeKind_PrimitiveCString: {
            fprintf(emitter->outFile, "const char*");
            break;
        }
        case TypeKind_Struct: // Fallthrough
        case TypeKind_Union: // Fallthrough
        case TypeKind_Enum: {
            fprintf(emitter->outFile, "%s", type.name.cstr);
            break;
        }
        default: {
            assert(false && "Unexpected type in emitter");
        }
    }
    for (int32 index = 0; index < type.baseIndirectionLevel; index += 1) {
        fprintf(emitter->outFile, "*");
    }
}

static void EmitVariableDeclarationWithoutTerminator(Emitter* emitter, Symbol* varSymbol) {
    Type varType = varSymbol->type;
    EmitType(emitter, varType);
    String varName = varSymbol->name;
    fprintf(emitter->outFile, " %s", varName.cstr);
    if (varSymbol->type.isArray) {
        fprintf(emitter->outFile, "[%lld]", varSymbol->type.arrayElementCount);
    }
}

static void EmitVariableDeclarationStatement(Emitter* emitter, ASTNode* node) {
    if (node->symbol->scopeKind == SymbolScopeKind_Extern) {
        return;
    } else {
        if (node->symbol->scopeKind == SymbolScopeKind_LocalPersist) {
            fprintf(emitter->outFile, "static ");
        } else {
            if (node->symbol->scopeKind == SymbolScopeKind_Global) {
                fprintf(emitter->outFile, "static ");
            }
        }
    }
    EmitVariableDeclarationWithoutTerminator(emitter, node->symbol);
    if (node->left != NULL) {
        fprintf(emitter->outFile, " = ");
        EmitExpression(emitter, node->left);
    }
    fprintf(emitter->outFile, ";");
}

static void EmitCompoundStatement(Emitter* emitter, ASTNode* node) {
    if (node->children.count == 0) {
        fprintf(emitter->outFile, "{}");
    } else {
        fprintf(emitter->outFile, "{");
        emitter->indentationLevel += 1;
        EmitNewLine(emitter);
        for (int32 index = 0; index < node->children.count; index += 1) {
            EmitStatement(emitter, node->children.nodes[index]);
            if (index == node->children.count - 1) {
                emitter->indentationLevel -= 1;
            }
            EmitNewLine(emitter);
        }
        fprintf(emitter->outFile, "}");
    }
}

static void EmitEnumDeclarationStatement(Emitter* emitter, ASTNode* node) {
    if (node->symbol->scopeKind == SymbolScopeKind_Extern) {
        return;
    }
    String enumName = node->symbol->name;
    fprintf(emitter->outFile, "enum %s; ", enumName.cstr);
    fprintf(emitter->outFile, "typedef enum %s %s;", enumName.cstr, enumName.cstr);
}

static void EmitEnumDefinitionStatement(Emitter* emitter, ASTNode* node) {
    if (node->symbol->scopeKind == SymbolScopeKind_Extern) {
        return;
    }
    EmitEnumDeclarationStatement(emitter, node);
    String enumName = node->symbol->name;
    fprintf(emitter->outFile, " enum %s ", enumName.cstr);
    fprintf(emitter->outFile, "{");
    emitter->indentationLevel += 1;
    EmitNewLine(emitter);
    int32 memberCount = node->symbol->membersSymbolTable->count;
    for (int32 index = 0; index < memberCount; index += 1) {
        Symbol* memberSymbol = node->symbol->membersSymbolTable->symbols[index];
        EmitEnumLiteralSymbol(emitter, memberSymbol);
        fprintf(emitter->outFile, " = %lld,", memberSymbol->enumValue);
        if (index == memberCount - 1) {
            emitter->indentationLevel -= 1;
        }
        EmitNewLine(emitter);
    }
    fprintf(emitter->outFile, "};");
}

static void EmitStructOrUnionDeclarationStatement(Emitter* emitter, ASTNode* node, bool isUnion) {
    if (node->symbol->scopeKind == SymbolScopeKind_Extern) {
        return;
    }
    String structName = node->symbol->name;
    fprintf(emitter->outFile, isUnion ? "union %s; " : "struct %s; ", structName.cstr);
    fprintf(emitter->outFile, isUnion ? "typedef union %s %s;" : "typedef struct %s %s;", structName.cstr, structName.cstr);
}

static void EmitStructOrUnionDefinitionStatement(Emitter* emitter, ASTNode* node, bool isUnion) {
    if (node->symbol->scopeKind == SymbolScopeKind_Extern) {
        return;
    }
    EmitStructOrUnionDeclarationStatement(emitter, node, isUnion);
    String structName = node->symbol->name;
    fprintf(emitter->outFile, isUnion ? " union %s" : " struct %s ", structName.cstr);
    fprintf(emitter->outFile, "{");
    emitter->indentationLevel += 1;
    EmitNewLine(emitter);
    int32 memberCount = node->symbol->membersSymbolTable->count;
    for (int32 index = 0; index < memberCount; index += 1) {
        EmitVariableDeclarationWithoutTerminator(emitter, node->symbol->membersSymbolTable->symbols[index]);
        fprintf(emitter->outFile, ";");
        if (index == memberCount - 1) {
            emitter->indentationLevel -= 1;
        }
        EmitNewLine(emitter);
    }
    fprintf(emitter->outFile, "};");
}

static void EmitFunctionDeclarationWithoutTerminator(Emitter* emitter, ASTNode* node) {
    Type returnType = node->symbol->type;
    EmitType(emitter, returnType);
    String funcName = node->symbol->name;
    fprintf(emitter->outFile, " %s(", funcName.cstr);
    for (int32 index = 0; index < node->symbol->membersSymbolTable->count; index += 1) {
        EmitVariableDeclarationWithoutTerminator(emitter, node->symbol->membersSymbolTable->symbols[index]);
        if (index != node->symbol->membersSymbolTable->count - 1) {
            fprintf(emitter->outFile, ", ");
        }
        if (node->symbol->isVariadric && index == node->symbol->membersSymbolTable->count - 1) {
            fprintf(emitter->outFile, ", ...");
        }
    }
    fprintf(emitter->outFile, ")");
}

static void EmitFunctionDeclarationStatement(Emitter* emitter, ASTNode* node) {
    if (node->symbol->scopeKind == SymbolScopeKind_Extern) {
        return;
    }
    EmitFunctionDeclarationWithoutTerminator(emitter, node);
    fprintf(emitter->outFile, ";");
}

static void EmitFunctionDefinitionStatement(Emitter* emitter, ASTNode* node) {
    fprintf(emitter->outFile, "static ");
    EmitFunctionDeclarationWithoutTerminator(emitter, node);
    fprintf(emitter->outFile, " ");
    EmitCompoundStatement(emitter, node->left);
}

static void EmitPreamble(Emitter* emitter) {
    fprintf(emitter->outFile, "//////////////////////////////////////////////////////////////////////\n");
    fprintf(emitter->outFile, "// This file was generated by piggi and should not be modified by hand\n");
    fprintf(emitter->outFile, "//////////////////////////////////////////////////////////////////////\n");
    EmitNewLine(emitter);
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "#include <stdio.h>");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "#include <stdarg.h>");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "#include <stdint.h>");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "#include <stdbool.h>");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "#include <stdlib.h>");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "#include <assert.h>");
    EmitNewLine(emitter);
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "typedef int8_t  int8;");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "typedef int16_t int16;");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "typedef int32_t int32;");
    EmitNewLine(emitter);
    fprintf(emitter->outFile, "typedef int64_t int64;");
    EmitNewLine(emitter);
    EmitNewLine(emitter);
}

static void EmitPostamble(Emitter* emitter) {
    fclose(emitter->outFile);
}

static void EmitStatement(Emitter* emitter, ASTNode* node) {
    switch (node->kind) {
        case ASTNodeKind_IfStatement: {
            EmitIfStatement(emitter, node);
            break;
        }
        case ASTNodeKind_DoWhileStatement: {
            EmitDoWhileStatement(emitter, node);
            break;
        }
        case ASTNodeKind_WhileStatement: {
            EmitWhileStatement(emitter, node);
            break;
        }
        case ASTNodeKind_ForStatement: {
            EmitForStatement(emitter, node);
            break;
        }
        case ASTNodeKind_ReturnStatement: {
            EmitReturnStatement(emitter, node);
            break;
        }
        case ASTNodeKind_BreakStatement: {
            EmitBreakStatement(emitter, node);
            break;
        }
        case ASTNodeKind_ContinueStatement: {
            EmitContinueStatement(emitter, node);
            break;
        }
        case ASTNodeKind_SwitchStatement: {
            EmitSwitchStatement(emitter, node);
            break;
        }
        case ASTNodeKind_EnumDeclarationStatement: {
            EmitEnumDeclarationStatement(emitter, node);
            break;
        }
        case ASTNodeKind_EnumDefinitionStatement: {
            EmitEnumDefinitionStatement(emitter, node);
            break;
        }
        case ASTNodeKind_UnionDeclarationStatement: {
            EmitStructOrUnionDeclarationStatement(emitter, node, true);
            break;
        }
        case ASTNodeKind_UnionDefinitionStatement: {
            EmitStructOrUnionDefinitionStatement(emitter, node, true);
            break;
        }
        case ASTNodeKind_StructDeclarationStatement: {
            EmitStructOrUnionDeclarationStatement(emitter, node, false);
            break;
        }
        case ASTNodeKind_StructDefinitionStatement: {
            EmitStructOrUnionDefinitionStatement(emitter, node, false);
            break;
        }
        case ASTNodeKind_FunctionDeclarationStatement: {
            EmitFunctionDeclarationStatement(emitter, node);
            break;
        }
        case ASTNodeKind_FunctionDefinitionStatement: {
            EmitFunctionDefinitionStatement(emitter, node);
            break;
        }
        case ASTNodeKind_VariableDeclarationStatement: // Fallthrough
        case ASTNodeKind_ArrayDeclarationStatement: {
            EmitVariableDeclarationStatement(emitter, node);
            break;
        }
        case ASTNodeKind_ExpressionStatement: {
            EmitExpressionStatement(emitter, node);
            break;
        }
        case ASTNodeKind_CompoundStatement: {
            EmitCompoundStatement(emitter, node);
            break;
        }
        default: {
            fprintf(stderr, "Unknown statement in emitter: %d\n", node->kind);
            exit(1);
        }
    }
}

static void EmitRoot(Emitter* emitter, ASTNode* node) {
    assert(node->kind == ASTNodeKind_Root);
    EmitPreamble(emitter);
    for (int32 index = 0; index < node->children.count; index += 1) {
        EmitStatement(emitter, node->children.nodes[index]);
        EmitNewLine(emitter);
        EmitNewLine(emitter);
    }
    EmitPostamble(emitter);
}

static SourceFile ReadFileToString(String filepath) {
    char* buffer = NULL;
    FILE* handle = fopen(filepath.cstr, "rb");
    if (handle == NULL) {
        fprintf(stderr, "Unable to open file '%s'\n", filepath.cstr);
        exit(1);
    }
    fseek(handle, 0, SEEK_END);
    int64 length = (int64)ftell(handle);
    fseek(handle, 0, SEEK_SET);
    buffer = (char*)malloc(length + 1);
    if (buffer) {
        fread(buffer, 1, length, handle);
    }
    buffer[length] = '\0';
    fclose(handle);
    SourceFile result;
    result.filepath = filepath;
    result.content.cstr = buffer;
    result.content.length = (int32)length;
    return result;
}

struct Preprocessor; typedef struct Preprocessor Preprocessor; struct Preprocessor {
    Source source;
};

static Preprocessor PreprocessorCreate() {
    Preprocessor result;
    result.source = SourceCreateEmpty();
    return result;
}

static void PreprocessorPreprocessFile(Preprocessor* preprocessor, String filepath) {
    if (SourceContainsFile(preprocessor->source, filepath)) {
        return;
    }
    SourceFile sourceFile = ReadFileToString(filepath);
    Source dummy = SourceCreateEmpty();
    SourceFileArrayPush(&dummy.files, sourceFile);
    dummy.content = sourceFile.content;
    Scanner scanner = ScannerCreate(dummy);
    String result = StringCreateEmpty();
    while (true) {
        Token token = NextToken(&scanner);
        if (token.kind == TokenKind_EndOfFile) {
            break;
        }
        if (token.kind != TokenKind_IncludeDirective) {
            continue;
        }
        token = NextToken(&scanner);
        if (token.kind == TokenKind_Less) {
            token = NextToken(&scanner);
            token = NextToken(&scanner);
            assert(token.kind == TokenKind_Dot);
            token = NextToken(&scanner);
            token = NextToken(&scanner);
            assert(token.kind == TokenKind_Greater);
        } else {
            if (token.kind == TokenKind_StringLiteral) {
                PreprocessorPreprocessFile(preprocessor, token.stringValue);
            } else {
                ReportError(TokenGetLocation(token), "Expected filepath after '#include' directive in '%s'", filepath.cstr);
            }
        }
    }
    SourceFileArrayPush(&preprocessor->source.files, sourceFile);
    preprocessor->source.content = StringAppend(preprocessor->source.content, sourceFile.content);
}

static Source PreprocessFile(String filepath) {
    Preprocessor preprocessor = PreprocessorCreate();
    PreprocessorPreprocessFile(&preprocessor, filepath);
    return preprocessor.source;
}

static void Compile(String inputFilepath, String outputFilepath) {
    Source source = PreprocessFile(inputFilepath);
    SymbolTable* symbolTable = SymbolTableCreate(NULL);
    Parser parser = ParserCreate(source, symbolTable);
    ASTNode* statement = ParseGlobalStatements(&parser);
    if (parser.tokenCur.kind != TokenKind_EndOfFile) {
        ReportError(TokenGetLocation(parser.tokenCur), "Expected EOF token after parsing file, instead got '%s'", TokenKindToString(parser.tokenCur.kind).cstr);
    }
    Emitter emitter = EmitterCreate(outputFilepath);
    EmitRoot(&emitter, statement);
}

static void main(int32 argc, char** argv) {
    if (argc != 3) {
        fprintf(stderr, "Expects two arguments: <inputfilepath> <outputfilepath>\n");
        exit(1);
    }
    Compile(StringCreateFromCStr(argv[1]), StringCreateFromCStr(argv[2]));
}

